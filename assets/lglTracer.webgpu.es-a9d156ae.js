class ur{constructor(e,t,r=1,s=!0){this._device=e,this._canvas=t,this._context=t.getContext("webgpu"),this._configure={alphaMode:s?"premultiplied":"opaque",device:this._device,format:this.format},this._context.configure(this._configure),this.pixelRatio=r}get device(){return this._device}get configure(){return this._configure}get format(){return navigator.gpu.getPreferredCanvasFormat()}get width(){return this._canvas.width}get height(){return this._canvas.height}get size(){return{width:this.width,height:this.height,depthOrArrayLayers:1}}getContext(){return this._context}createCurrentTextureView(){return this._context.getCurrentTexture().createView()}}class F extends Array{constructor(e=0,t=e,r=t){return typeof e=="string"&&([e,t,r]=F.hexToRGB(e)),e>1&&(e/=255,t/=255,r/=255),super(e,t,r),this}get isColor(){return!0}get r(){return this[0]}set r(e){this[0]=e}get g(){return this[1]}set g(e){this[1]=e}get b(){return this[2]}set b(e){this[2]=e}set(e,t,r){return typeof e=="string"&&([e,t,r]=F.hexToRGB(e)),e.length?this.copy(e):(this[0]=e,this[1]=t,this[2]=r,this)}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this}fromHex(e){const t=F.hexToRGB(e);this.fromArray(t)}getHex(){const[e,t,r]=this,s=a=>Math.round(255*a).toString(16).padStart(2,"0");return`#${s(e)}${s(t)}${s(r)}`}static hexToRGB(e){e.length===4&&(e=e[0]+e[1]+e[1]+e[2]+e[2]+e[3]+e[3]);const t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t||console.warn(`Unable to convert hex string ${e} to rgb values`),[parseInt(t[1],16)/255,parseInt(t[2],16)/255,parseInt(t[3],16)/255]}static rgbToHex(e){e.length&&e.length==3||console.error(`Unable to convert rgb array ${e} to hex value`);let t="#";for(let r=0;r<e.length;r++){let s=Number(e[r]).toString(16);s.length<2&&(s="0"+s),t+=s}return t}static hslToRGB(e,t,r){let s,a,n;if(t==0)s=a=n=r;else{let u=function(c,d,h){return h<0&&(h+=1),h>1&&(h-=1),h<.16666666666666666?c+6*(d-c)*h:h<.5?d:h<.6666666666666666?c+(d-c)*(.6666666666666666-h)*6:c},o=r<.5?r*(1+t):r+t-r*t,l=2*r-o;s=u(l,o,e+1/3),a=u(l,o,e),n=u(l,o,e-1/3)}return[s,a,n]}static rgbToHsl(e,t,r){e/=255,t/=255,r/=255;let s,a,n=Math.max(e,t,r),u=Math.min(e,t,r),o=(n+u)/2;if(n==u)s=a=0;else{let l=n-u;switch(a=o>.5?l/(2-n-u):l/(n+u),n){case e:s=(t-r)/l+(t<r?6:0);break;case t:s=(r-e)/l+2;break;case r:s=(e-t)/l+4}s/=6}return[s,a,o]}static rgbToHsv(e,t,r){let s,a,n;e/=255,t/=255,r/=255;let u=Math.min(e,t,r),o=n=Math.max(e,t,r),l=o-u;if(o==u)s=0;else{switch(o){case e:s=(t-r)/l+(t<r?6:0);break;case t:s=2+(r-e)/l;break;case r:s=4+(e-t)/l}s=Math.round(60*s)}return a=o==0?0:1-u/o,a=Math.round(100*a),n=Math.round(100*n),[s,a,n]}fromArray(e,t=0){return this[0]=e[t],this[1]=e[t+1],this[2]=e[t+2],this}toArray(){return Array.from(this)}SRGBToLinearSingle(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}SRGBToLinear(){return this[0]=this.SRGBToLinearSingle(this[0]),this[1]=this.SRGBToLinearSingle(this[1]),this[2]=this.SRGBToLinearSingle(this[2]),this}LinearToSRGBSingle(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}LinearToSRGB(){return this[0]=this.LinearToSRGBSingle(this[0]),this[1]=this.LinearToSRGBSingle(this[1]),this[2]=this.LinearToSRGBSingle(this[2]),this}luminance(){return .2126*this[0]+.7152*this[1]+.0722*this[2]}addColor(e,t){return this[0]=e[0]+t[0],this[1]=e[1]+t[1],this[2]=e[2]+t[2],this}scale(e){return this[0]=this[0]*e,this[1]=this[1]*e,this[2]=this[2]*e,this}}function tt(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function rt(i,e,t){let r=e[0],s=e[1],a=e[2],n=e[3],u=e[4],o=e[5],l=e[6],c=e[7],d=e[8],h=e[9],f=e[10],m=e[11],x=e[12],g=e[13],p=e[14],v=e[15],b=t[0],L=t[1],S=t[2],y=t[3];return i[0]=b*r+L*u+S*d+y*x,i[1]=b*s+L*o+S*h+y*g,i[2]=b*a+L*l+S*f+y*p,i[3]=b*n+L*c+S*m+y*v,b=t[4],L=t[5],S=t[6],y=t[7],i[4]=b*r+L*u+S*d+y*x,i[5]=b*s+L*o+S*h+y*g,i[6]=b*a+L*l+S*f+y*p,i[7]=b*n+L*c+S*m+y*v,b=t[8],L=t[9],S=t[10],y=t[11],i[8]=b*r+L*u+S*d+y*x,i[9]=b*s+L*o+S*h+y*g,i[10]=b*a+L*l+S*f+y*p,i[11]=b*n+L*c+S*m+y*v,b=t[12],L=t[13],S=t[14],y=t[15],i[12]=b*r+L*u+S*d+y*x,i[13]=b*s+L*o+S*h+y*g,i[14]=b*a+L*l+S*f+y*p,i[15]=b*n+L*c+S*m+y*v,i}function st(i,e){let t=e[0]+e[5]+e[10],r=0;return t>0?(r=2*Math.sqrt(t+1),i[3]=.25*r,i[0]=(e[6]-e[9])/r,i[1]=(e[8]-e[2])/r,i[2]=(e[1]-e[4])/r):e[0]>e[5]&&e[0]>e[10]?(r=2*Math.sqrt(1+e[0]-e[5]-e[10]),i[3]=(e[6]-e[9])/r,i[0]=.25*r,i[1]=(e[1]+e[4])/r,i[2]=(e[8]+e[2])/r):e[5]>e[10]?(r=2*Math.sqrt(1+e[5]-e[0]-e[10]),i[3]=(e[8]-e[2])/r,i[0]=(e[1]+e[4])/r,i[1]=.25*r,i[2]=(e[6]+e[9])/r):(r=2*Math.sqrt(1+e[10]-e[0]-e[5]),i[3]=(e[1]-e[4])/r,i[0]=(e[8]+e[2])/r,i[1]=(e[6]+e[9])/r,i[2]=.25*r),i}function it(i,e){let t=e[0],r=e[1],s=e[2],a=e[3],n=t+t,u=r+r,o=s+s,l=t*n,c=r*n,d=r*u,h=s*n,f=s*u,m=s*o,x=a*n,g=a*u,p=a*o;return i[0]=1-d-m,i[1]=c+p,i[2]=h-g,i[3]=0,i[4]=c-p,i[5]=1-l-m,i[6]=f+x,i[7]=0,i[8]=h+g,i[9]=f-x,i[10]=1-l-d,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}class A extends Array{constructor(e=1,t=0,r=0,s=0,a=0,n=1,u=0,o=0,l=0,c=0,d=1,h=0,f=0,m=0,x=0,g=1){return super(e,t,r,s,a,n,u,o,l,c,d,h,f,m,x,g),this}get isMatrix4(){return!0}set x(e){this[12]=e}get x(){return this[12]}set y(e){this[13]=e}get y(){return this[13]}set z(e){this[14]=e}get z(){return this[14]}set w(e){this[15]=e}get w(){return this[15]}set(e,t,r,s,a,n,u,o,l,c,d,h,f,m,x,g){return e.length?this.copy(e):(function(p,v,b,L,S,y,M,T,_,B,P,w,W,I,X,R,or){p[0]=v,p[1]=b,p[2]=L,p[3]=S,p[4]=y,p[5]=M,p[6]=T,p[7]=_,p[8]=B,p[9]=P,p[10]=w,p[11]=W,p[12]=I,p[13]=X,p[14]=R,p[15]=or}(this,e,t,r,s,a,n,u,o,l,c,d,h,f,m,x,g),this)}translate(e,t=this){return function(r,s,a){let n,u,o,l,c,d,h,f,m,x,g,p,v=a[0],b=a[1],L=a[2];s===r?(r[12]=s[0]*v+s[4]*b+s[8]*L+s[12],r[13]=s[1]*v+s[5]*b+s[9]*L+s[13],r[14]=s[2]*v+s[6]*b+s[10]*L+s[14],r[15]=s[3]*v+s[7]*b+s[11]*L+s[15]):(n=s[0],u=s[1],o=s[2],l=s[3],c=s[4],d=s[5],h=s[6],f=s[7],m=s[8],x=s[9],g=s[10],p=s[11],r[0]=n,r[1]=u,r[2]=o,r[3]=l,r[4]=c,r[5]=d,r[6]=h,r[7]=f,r[8]=m,r[9]=x,r[10]=g,r[11]=p,r[12]=n*v+c*b+m*L+s[12],r[13]=u*v+d*b+x*L+s[13],r[14]=o*v+h*b+g*L+s[14],r[15]=l*v+f*b+p*L+s[15])}(this,t,e),this}rotateX(e,t=this){return function(r,s,a){let n=Math.sin(a),u=Math.cos(a),o=s[4],l=s[5],c=s[6],d=s[7],h=s[8],f=s[9],m=s[10],x=s[11];s!==r&&(r[0]=s[0],r[1]=s[1],r[2]=s[2],r[3]=s[3],r[12]=s[12],r[13]=s[13],r[14]=s[14],r[15]=s[15]),r[4]=o*u+h*n,r[5]=l*u+f*n,r[6]=c*u+m*n,r[7]=d*u+x*n,r[8]=h*u-o*n,r[9]=f*u-l*n,r[10]=m*u-c*n,r[11]=x*u-d*n}(this,t,e),this}rotateY(e,t=this){return function(r,s,a){let n=Math.sin(a),u=Math.cos(a),o=s[0],l=s[1],c=s[2],d=s[3],h=s[8],f=s[9],m=s[10],x=s[11];s!==r&&(r[4]=s[4],r[5]=s[5],r[6]=s[6],r[7]=s[7],r[12]=s[12],r[13]=s[13],r[14]=s[14],r[15]=s[15]),r[0]=o*u-h*n,r[1]=l*u-f*n,r[2]=c*u-m*n,r[3]=d*u-x*n,r[8]=o*n+h*u,r[9]=l*n+f*u,r[10]=c*n+m*u,r[11]=d*n+x*u}(this,t,e),this}rotateZ(e,t=this){return function(r,s,a){let n=Math.sin(a),u=Math.cos(a),o=s[0],l=s[1],c=s[2],d=s[3],h=s[4],f=s[5],m=s[6],x=s[7];s!==r&&(r[8]=s[8],r[9]=s[9],r[10]=s[10],r[11]=s[11],r[12]=s[12],r[13]=s[13],r[14]=s[14],r[15]=s[15]),r[0]=o*u+h*n,r[1]=l*u+f*n,r[2]=c*u+m*n,r[3]=d*u+x*n,r[4]=h*u-o*n,r[5]=f*u-l*n,r[6]=m*u-c*n,r[7]=x*u-d*n}(this,t,e),this}scale(e,t=this){return function(r,s,a){let n=a[0],u=a[1],o=a[2];r[0]=s[0]*n,r[1]=s[1]*n,r[2]=s[2]*n,r[3]=s[3]*n,r[4]=s[4]*u,r[5]=s[5]*u,r[6]=s[6]*u,r[7]=s[7]*u,r[8]=s[8]*o,r[9]=s[9]*o,r[10]=s[10]*o,r[11]=s[11]*o,r[12]=s[12],r[13]=s[13],r[14]=s[14],r[15]=s[15]}(this,t,typeof e=="number"?[e,e,e]:e),this}multiply(e,t){return t?rt(this,e,t):rt(this,this,e),this}identity(){return tt(this),this}copy(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}fromPerspective({fov:e,aspect:t,near:r,far:s}={}){return function(a,n,u,o,l){let c=1/Math.tan(n/2),d=1/(o-l);a[0]=c/u,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=c,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=(l+o)*d,a[11]=-1,a[12]=0,a[13]=0,a[14]=2*l*o*d,a[15]=0}(this,e,t,r,s),this}fromOrthogonal({left:e,right:t,bottom:r,top:s,near:a,far:n}){return function(u,o,l,c,d,h,f){let m=1/(o-l),x=1/(c-d),g=1/(h-f);u[0]=-2*m,u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=-2*x,u[6]=0,u[7]=0,u[8]=0,u[9]=0,u[10]=2*g,u[11]=0,u[12]=(o+l)*m,u[13]=(d+c)*x,u[14]=(f+h)*g,u[15]=1}(this,e,t,r,s,a,n),this}fromQuaternion(e){return it(this,e),this}setPosition(e){return this.x=e[0],this.y=e[1],this.z=e[2],this}transpose(e=this){return function(t,r){if(t===r){let s=r[1],a=r[2],n=r[3],u=r[6],o=r[7],l=r[11];t[1]=r[4],t[2]=r[8],t[3]=r[12],t[4]=s,t[6]=r[9],t[7]=r[13],t[8]=a,t[9]=u,t[11]=r[14],t[12]=n,t[13]=o,t[14]=l}else t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12],t[4]=r[1],t[5]=r[5],t[6]=r[9],t[7]=r[13],t[8]=r[2],t[9]=r[6],t[10]=r[10],t[11]=r[14],t[12]=r[3],t[13]=r[7],t[14]=r[11],t[15]=r[15]}(this,e),this}inverse(e=this){return function(t,r){let s=r[0],a=r[1],n=r[2],u=r[3],o=r[4],l=r[5],c=r[6],d=r[7],h=r[8],f=r[9],m=r[10],x=r[11],g=r[12],p=r[13],v=r[14],b=r[15],L=s*l-a*o,S=s*c-n*o,y=s*d-u*o,M=a*c-n*l,T=a*d-u*l,_=n*d-u*c,B=h*p-f*g,P=h*v-m*g,w=h*b-x*g,W=f*v-m*p,I=f*b-x*p,X=m*b-x*v,R=L*X-S*I+y*W+M*w-T*P+_*B;R&&(R=1/R,t[0]=(l*X-c*I+d*W)*R,t[1]=(n*I-a*X-u*W)*R,t[2]=(p*_-v*T+b*M)*R,t[3]=(m*T-f*_-x*M)*R,t[4]=(c*w-o*X-d*P)*R,t[5]=(s*X-n*w+u*P)*R,t[6]=(v*y-g*_-b*S)*R,t[7]=(h*_-m*y+x*S)*R,t[8]=(o*I-l*w+d*B)*R,t[9]=(a*w-s*I-u*B)*R,t[10]=(g*T-p*y+b*L)*R,t[11]=(f*y-h*T-x*L)*R,t[12]=(l*P-o*W-c*B)*R,t[13]=(s*W-a*P+n*B)*R,t[14]=(p*S-g*M-v*L)*R,t[15]=(h*M-f*S+m*L)*R)}(this,e),this}compose(e,t,r){return function(s,a,n,u){let o=a[0],l=a[1],c=a[2],d=a[3],h=o+o,f=l+l,m=c+c,x=o*h,g=o*f,p=o*m,v=l*f,b=l*m,L=c*m,S=d*h,y=d*f,M=d*m,T=u[0],_=u[1],B=u[2];s[0]=(1-(v+L))*T,s[1]=(g+M)*T,s[2]=(p-y)*T,s[3]=0,s[4]=(g-M)*_,s[5]=(1-(x+L))*_,s[6]=(b+S)*_,s[7]=0,s[8]=(p+y)*B,s[9]=(b-S)*B,s[10]=(1-(x+v))*B,s[11]=0,s[12]=n[0],s[13]=n[1],s[14]=n[2],s[15]=1}(this,e,t,r),this}getRotation(e){return st(e,this),this}extractRotation(e){let t=[];return st(t,e),it(this,t),this}fromRotation(e,t){return function(r,s,a){let n,u,o,l=a[0],c=a[1],d=a[2],h=Math.sqrt(l*l+c*c+d*d);Math.abs(h)<1e-6||(h=1/h,l*=h,c*=h,d*=h,n=Math.sin(s),u=Math.cos(s),o=1-u,r[0]=l*l*o+u,r[1]=c*l*o+d*n,r[2]=d*l*o-c*n,r[3]=0,r[4]=l*c*o-d*n,r[5]=c*c*o+u,r[6]=d*c*o+l*n,r[7]=0,r[8]=l*d*o+c*n,r[9]=c*d*o-l*n,r[10]=d*d*o+u,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1)}(this,e,t),this}getTranslation(e){var t,r;return r=this,(t=e)[0]=r[12],t[1]=r[13],t[2]=r[14],this}getScaling(e){return function(t,r){let s=r[0],a=r[1],n=r[2],u=r[4],o=r[5],l=r[6],c=r[8],d=r[9],h=r[10];t[0]=Math.sqrt(s*s+a*a+n*n),t[1]=Math.sqrt(u*u+o*o+l*l),t[2]=Math.sqrt(c*c+d*d+h*h)}(e,this),this}getMaxScaleOnAxis(){return function(e){let t=e[0],r=e[1],s=e[2],a=e[4],n=e[5],u=e[6],o=e[8],l=e[9],c=e[10];const d=t*t+r*r+s*s,h=a*a+n*n+u*u,f=o*o+l*l+c*c;return Math.sqrt(Math.max(d,h,f))}(this)}lookAt(e,t,r){return function(s,a,n,u){let o=a[0],l=a[1],c=a[2],d=u[0],h=u[1],f=u[2],m=o-n[0],x=l-n[1],g=c-n[2],p=m*m+x*x+g*g;p>0&&(p=1/Math.sqrt(p),m*=p,x*=p,g*=p);let v=h*g-f*x,b=f*m-d*g,L=d*x-h*m;p=v*v+b*b+L*L,p>0&&(p=1/Math.sqrt(p),v*=p,b*=p,L*=p),s[0]=v,s[1]=b,s[2]=L,s[3]=0,s[4]=x*L-g*b,s[5]=g*v-m*L,s[6]=m*b-x*v,s[7]=0,s[8]=m,s[9]=x,s[10]=g,s[11]=0,s[12]=o,s[13]=l,s[14]=c,s[15]=1}(this,e,t,r),this}lookAtTarget(e,t,r){return function(s,a,n,u){let o,l,c,d,h,f,m,x,g,p,v=a[0],b=a[1],L=a[2],S=u[0],y=u[1],M=u[2],T=n[0],_=n[1],B=n[2];Math.abs(v-T)<1e-6&&Math.abs(b-_)<1e-6&&Math.abs(L-B)<1e-6?tt(s):(m=v-T,x=b-_,g=L-B,p=1/Math.sqrt(m*m+x*x+g*g),m*=p,x*=p,g*=p,o=y*g-M*x,l=M*m-S*g,c=S*x-y*m,p=Math.sqrt(o*o+l*l+c*c),p?(p=1/p,o*=p,l*=p,c*=p):(o=0,l=0,c=0),d=x*c-g*l,h=g*o-m*c,f=m*l-x*o,p=Math.sqrt(d*d+h*h+f*f),p?(p=1/p,d*=p,h*=p,f*=p):(d=0,h=0,f=0),s[0]=o,s[1]=d,s[2]=m,s[3]=0,s[4]=l,s[5]=h,s[6]=x,s[7]=0,s[8]=c,s[9]=f,s[10]=g,s[11]=0,s[12]=-(o*v+l*b+c*L),s[13]=-(d*v+h*b+f*L),s[14]=-(m*v+x*b+g*L),s[15]=1)}(this,e,t,r),this}determinant(){return function(e){let t=e[0],r=e[1],s=e[2],a=e[3],n=e[4],u=e[5],o=e[6],l=e[7],c=e[8],d=e[9],h=e[10],f=e[11],m=e[12],x=e[13],g=e[14],p=e[15];return(t*u-r*n)*(h*p-f*g)-(t*o-s*n)*(d*p-f*x)+(t*l-a*n)*(d*g-h*x)+(r*o-s*u)*(c*p-f*m)-(r*l-a*u)*(c*g-h*m)+(s*l-a*o)*(c*x-d*m)}(this)}fromArray(e,t=0){for(var r=0;r<16;r++)this[r]=e[r+t];return this}toArray(e=[],t=0){let r=this;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}static copyTo(e=[],t=[]){e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]}}function at(i,e,t){let r=e[0],s=e[1],a=e[2],n=e[3],u=e[4],o=e[5],l=e[6],c=e[7],d=e[8],h=t[0],f=t[1],m=t[2],x=t[3],g=t[4],p=t[5],v=t[6],b=t[7],L=t[8];return i[0]=h*r+f*n+m*l,i[1]=h*s+f*u+m*c,i[2]=h*a+f*o+m*d,i[3]=x*r+g*n+p*l,i[4]=x*s+g*u+p*c,i[5]=x*a+g*o+p*d,i[6]=v*r+b*n+L*l,i[7]=v*s+b*u+L*c,i[8]=v*a+b*o+L*d,i}new A;class Z extends Array{constructor(e=1,t=0,r=0,s=0,a=1,n=0,u=0,o=0,l=1){return super(e,t,r,s,a,n,u,o,l),this}get isMatrix3(){return!0}set(e,t,r,s,a,n,u,o,l){return e.length?this.copy(e):(function(c,d,h,f,m,x,g,p,v,b){c[0]=d,c[1]=h,c[2]=f,c[3]=m,c[4]=x,c[5]=g,c[6]=p,c[7]=v,c[8]=b}(this,e,t,r,s,a,n,u,o,l),this)}transpose(){return function(e){let t;t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t}(this),this}inverse(e=this){return function(t,r){let s=r[0],a=r[1],n=r[2],u=r[3],o=r[4],l=r[5],c=r[6],d=r[7],h=r[8],f=h*o-l*d,m=-h*u+l*c,x=d*u-o*c,g=s*f+a*m+n*x;g&&(g=1/g,t[0]=f*g,t[1]=(-h*a+n*d)*g,t[2]=(l*a-n*o)*g,t[3]=m*g,t[4]=(h*s-n*c)*g,t[5]=(-l*s+n*u)*g,t[6]=x*g,t[7]=(-d*s+a*c)*g,t[8]=(o*s-a*u)*g)}(this,e),this}translate(e,t=this){return function(r,s,a){let n=s[0],u=s[1],o=s[2],l=s[3],c=s[4],d=s[5],h=s[6],f=s[7],m=s[8],x=a[0],g=a[1];r[0]=n,r[1]=u,r[2]=o,r[3]=l,r[4]=c,r[5]=d,r[6]=x*n+g*l+h,r[7]=x*u+g*c+f,r[8]=x*o+g*d+m}(this,t,e),this}rotate(e,t=this){return function(r,s,a){let n=s[0],u=s[1],o=s[2],l=s[3],c=s[4],d=s[5],h=s[6],f=s[7],m=s[8],x=Math.sin(a),g=Math.cos(a);r[0]=g*n+x*l,r[1]=g*u+x*c,r[2]=g*o+x*d,r[3]=g*l-x*n,r[4]=g*c-x*u,r[5]=g*d-x*o,r[6]=h,r[7]=f,r[8]=m}(this,t,e),this}scale(e,t=this){return function(r,s,a){let n=a[0],u=a[1];r[0]=n*s[0],r[1]=n*s[1],r[2]=n*s[2],r[3]=u*s[3],r[4]=u*s[4],r[5]=u*s[5],r[6]=s[6],r[7]=s[7],r[8]=s[8]}(this,t,e),this}multiply(e,t){return t?at(this,e,t):at(this,this,e),this}identity(){var e;return(e=this)[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,this}copy(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}fromMatrix4(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[4],t[4]=r[5],t[5]=r[6],t[6]=r[8],t[7]=r[9],t[8]=r[10],this}fromQuaternion(e){return function(t,r){let s=r[0],a=r[1],n=r[2],u=r[3],o=s+s,l=a+a,c=n+n,d=s*o,h=a*o,f=a*l,m=n*o,x=n*l,g=n*c,p=u*o,v=u*l,b=u*c;t[0]=1-f-g,t[3]=h-b,t[6]=m+v,t[1]=h+b,t[4]=1-d-g,t[7]=x-p,t[2]=m-v,t[5]=x+p,t[8]=1-d-f}(this,e),this}fromBasis(e,t,r){return this.set(e[0],e[1],e[2],t[0],t[1],t[2],r[0],r[1],r[2]),this}getNormalMatrix(e){return function(t,r){let s=r[0],a=r[1],n=r[2],u=r[3],o=r[4],l=r[5],c=r[6],d=r[7],h=r[8],f=r[9],m=r[10],x=r[11],g=r[12],p=r[13],v=r[14],b=r[15],L=s*l-a*o,S=s*c-n*o,y=s*d-u*o,M=a*c-n*l,T=a*d-u*l,_=n*d-u*c,B=h*p-f*g,P=h*v-m*g,w=h*b-x*g,W=f*v-m*p,I=f*b-x*p,X=m*b-x*v,R=L*X-S*I+y*W+M*w-T*P+_*B;R&&(R=1/R,t[0]=(l*X-c*I+d*W)*R,t[1]=(c*w-o*X-d*P)*R,t[2]=(o*I-l*w+d*B)*R,t[3]=(n*I-a*X-u*W)*R,t[4]=(s*X-n*w+u*P)*R,t[5]=(a*w-s*I-u*B)*R,t[6]=(p*_-v*T+b*M)*R,t[7]=(v*y-g*_-b*S)*R,t[8]=(g*T-p*y+b*L)*R)}(this,e),this}clone(){return new Z().copy(this)}fromArray(e,t=0){for(var r=0;r<9;r++)this[r]=e[r+t];return this}toArray(){return Array.from(this)}toWebGPUFormat(){const e=new Float32Array(12);return e[3]=0,e[7]=0,e[11]=0,e[0]=this[0],e[1]=this[1],e[2]=this[2],e[4]=this[3],e[5]=this[4],e[6]=this[5],e[8]=this[6],e[9]=this[7],e[10]=this[8],e}}function nt(i,e,t){return i[0]=e[0]+t[0],i[1]=e[1]+t[1],i[2]=e[2]+t[2],i}function ot(i,e,t){return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i[2]=e[2]-t[2],i}function Be(i,e,t){return i[0]=e[0]*t,i[1]=e[1]*t,i[2]=e[2]*t,i}function pe(i,e){let t=e[0],r=e[1],s=e[2],a=t*t+r*r+s*s;return a>0&&(a=1/Math.sqrt(a),i[0]=e[0]*a,i[1]=e[1]*a,i[2]=e[2]*a),i}function ut(i,e){return i[0]*e[0]+i[1]*e[1]+i[2]*e[2]}function Wt(i,e,t){let r=e[0],s=e[1],a=e[2],n=t[3]*r+t[7]*s+t[11]*a+t[15];return n=n||1,i[0]=(t[0]*r+t[4]*s+t[8]*a+t[12])/n,i[1]=(t[1]*r+t[5]*s+t[9]*a+t[13])/n,i[2]=(t[2]*r+t[6]*s+t[10]*a+t[14])/n,i}function Ct(i,e,t){let r=e[0],s=e[1],a=e[2];return i[0]=r*t[0]+s*t[3]+a*t[6],i[1]=r*t[1]+s*t[4]+a*t[7],i[2]=r*t[2]+s*t[5]+a*t[8],i}const Fe=function(){let i=[];return function(e,t,r,s,a,n){let u,o;for(t||(t=3),r||(r=0),o=s?Math.min(s*t+r,e.length):e.length,u=r;u<o;u+=t)i[0]=e[u],i[1]=e[u+1],i[2]=e[u+2],a(i,i,n),e[u]=i[0],e[u+1]=i[1],e[u+2]=i[2];return e}}();function lt(i,e,t){let r=e[0],s=e[1],a=e[2],n=e[3],u=t[0],o=t[1],l=t[2],c=t[3];return i[0]=r*c+n*u+s*l-a*o,i[1]=s*c+n*o+a*u-r*l,i[2]=a*c+n*l+r*o-s*u,i[3]=n*c-r*u-s*o-a*l,i}const lr=function(i,e){return i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i},cr=function(i,e,t,r,s){return i[0]=e,i[1]=t,i[2]=r,i[3]=s,i},dr=function(i,e){return i[0]*e[0]+i[1]*e[1]+i[2]*e[2]+i[3]*e[3]},hr=function(i,e){let t=e[0],r=e[1],s=e[2],a=e[3],n=t*t+r*r+s*s+a*a;return n>0&&(n=1/Math.sqrt(n),i[0]=t*n,i[1]=r*n,i[2]=s*n,i[3]=a*n),i};class fr extends Array{constructor(e=0,t=0,r=0,s=1){return super(e,t,r,s),this.onChange=()=>{},this}get isQuaternion(){return!0}get x(){return this[0]}set x(e){this[0]=e,this.onChange()}get y(){return this[1]}set y(e){this[1]=e,this.onChange()}get z(){return this[2]}set z(e){this[2]=e,this.onChange()}get w(){return this[3]}set w(e){this[3]=e,this.onChange()}identity(){var e;return(e=this)[0]=0,e[1]=0,e[2]=0,e[3]=1,this.onChange(),this}set(e,t,r,s){return e.length?this.copy(e):(cr(this,e,t,r,s),this.onChange(),this)}rotateX(e){return function(t,r,s){s*=.5;let a=r[0],n=r[1],u=r[2],o=r[3],l=Math.sin(s),c=Math.cos(s);t[0]=a*c+o*l,t[1]=n*c+u*l,t[2]=u*c-n*l,t[3]=o*c-a*l}(this,this,e),this.onChange(),this}rotateY(e){return function(t,r,s){s*=.5;let a=r[0],n=r[1],u=r[2],o=r[3],l=Math.sin(s),c=Math.cos(s);t[0]=a*c-u*l,t[1]=n*c+o*l,t[2]=u*c+a*l,t[3]=o*c-n*l}(this,this,e),this.onChange(),this}rotateZ(e){return function(t,r,s){s*=.5;let a=r[0],n=r[1],u=r[2],o=r[3],l=Math.sin(s),c=Math.cos(s);t[0]=a*c+n*l,t[1]=n*c-a*l,t[2]=u*c+o*l,t[3]=o*c-u*l}(this,this,e),this.onChange(),this}inverse(e=this){return function(t,r){let s=r[0],a=r[1],n=r[2],u=r[3],o=s*s+a*a+n*n+u*u,l=o?1/o:0;t[0]=-s*l,t[1]=-a*l,t[2]=-n*l,t[3]=u*l}(this,e),this.onChange(),this}conjugate(e=this){var t,r;return r=e,(t=this)[0]=-r[0],t[1]=-r[1],t[2]=-r[2],t[3]=r[3],this.onChange(),this}copy(e){return lr(this,e),this.onChange(),this}normalize(e=this){return hr(this,e),this.onChange(),this}multiply(e,t){return t?lt(this,e,t):lt(this,this,e),this.onChange(),this}dot(e){return dr(this,e)}fromMatrix3(e){return function(t,r){let s,a=r[0]+r[4]+r[8];if(a>0)s=Math.sqrt(a+1),t[3]=.5*s,s=.5/s,t[0]=(r[5]-r[7])*s,t[1]=(r[6]-r[2])*s,t[2]=(r[1]-r[3])*s;else{let n=0;r[4]>r[0]&&(n=1),r[8]>r[3*n+n]&&(n=2);let u=(n+1)%3,o=(n+2)%3;s=Math.sqrt(r[3*n+n]-r[3*u+u]-r[3*o+o]+1),t[n]=.5*s,s=.5/s,t[3]=(r[3*u+o]-r[3*o+u])*s,t[u]=(r[3*u+n]+r[3*n+u])*s,t[o]=(r[3*o+n]+r[3*n+o])*s}}(this,e),this.onChange(),this}fromEuler(e){return function(t,r,s="YXZ"){let a=Math.sin(.5*r[0]),n=Math.cos(.5*r[0]),u=Math.sin(.5*r[1]),o=Math.cos(.5*r[1]),l=Math.sin(.5*r[2]),c=Math.cos(.5*r[2]);s==="XYZ"?(t[0]=a*o*c+n*u*l,t[1]=n*u*c-a*o*l,t[2]=n*o*l+a*u*c,t[3]=n*o*c-a*u*l):s==="YXZ"?(t[0]=a*o*c+n*u*l,t[1]=n*u*c-a*o*l,t[2]=n*o*l-a*u*c,t[3]=n*o*c+a*u*l):s==="ZXY"?(t[0]=a*o*c-n*u*l,t[1]=n*u*c+a*o*l,t[2]=n*o*l+a*u*c,t[3]=n*o*c-a*u*l):s==="ZYX"?(t[0]=a*o*c-n*u*l,t[1]=n*u*c+a*o*l,t[2]=n*o*l-a*u*c,t[3]=n*o*c+a*u*l):s==="YZX"?(t[0]=a*o*c+n*u*l,t[1]=n*u*c+a*o*l,t[2]=n*o*l-a*u*c,t[3]=n*o*c-a*u*l):s==="XZY"&&(t[0]=a*o*c-n*u*l,t[1]=n*u*c-a*o*l,t[2]=n*o*l+a*u*c,t[3]=n*o*c+a*u*l)}(this,e,e.order),this}slerp(e,t,r){return function(s,a,n,u){let o,l,c,d,h,f=a[0],m=a[1],x=a[2],g=a[3],p=n[0],v=n[1],b=n[2],L=n[3];l=f*p+m*v+x*b+g*L,l<0&&(l=-l,p=-p,v=-v,b=-b,L=-L),1-l>1e-6?(o=Math.acos(l),c=Math.sin(o),d=Math.sin((1-u)*o)/c,h=Math.sin(u*o)/c):(d=1-u,h=u),s[0]=d*f+h*p,s[1]=d*m+h*v,s[2]=d*x+h*b,s[3]=d*g+h*L}(this,e,t,r),this}fromArray(e,t=0){return this[0]=e[t],this[1]=e[t+1],this[2]=e[t+2],this[3]=e[t+3],this}toArray(){return Array.from(this)}}function ct(i,e,t){return i[0]=e[0]+t[0],i[1]=e[1]+t[1],i}function dt(i,e,t){return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i}function Re(i,e,t){return i[0]=e[0]*t,i[1]=e[1]*t,i}function ht(i){var e=i[0],t=i[1];return Math.sqrt(e*e+t*t)}class Se extends Array{constructor(e=0,t=e){return super(e,t),this}get isVector2(){return!0}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get width(){return this[0]}set width(e){this[0]=e}get height(){return this[1]}set height(e){this[1]=e}set(e,t=e){return e.length?this.copy(e):(function(r,s,a){r[0]=s,r[1]=a}(this,e,t),this)}copy(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],this}add(e,t){return t?ct(this,e,t):ct(this,this,e),this}sub(e,t){return t?dt(this,e,t):dt(this,this,e),this}multiply(e){var t,r,s;return e.length?(r=this,s=e,(t=this)[0]=r[0]*s[0],t[1]=r[1]*s[1]):Re(this,this,e),this}divide(e){var t,r,s;return e.length?(r=this,s=e,(t=this)[0]=r[0]/s[0],t[1]=r[1]/s[1]):Re(this,this,1/e),this}scale(e){return Re(this,this,e),this}distance(e){return e?(t=this,s=(r=e)[0]-t[0],a=r[1]-t[1],Math.sqrt(s*s+a*a)):ht(this);var t,r,s,a}squaredDistance(e){return e?(t=this,s=(r=e)[0]-t[0],a=r[1]-t[1],s*s+a*a):function(n){var u=n[0],o=n[1];return u*u+o*o}(this);var t,r,s,a}len(){return ht(this)}squaredLength(){return this.squaredDistance()}negate(e=this){var t,r;return r=e,(t=this)[0]=-r[0],t[1]=-r[1],this}inverse(e=this){var t,r;return r=e,(t=this)[0]=1/r[0],t[1]=1/r[1],this}normalize(){var e,t,r,s,a;e=this,r=(t=this)[0],s=t[1],(a=r*r+s*s)>0&&(a=1/Math.sqrt(a),e[0]=t[0]*a,e[1]=t[1]*a)}dot(e){return r=e,(t=this)[0]*r[0]+t[1]*r[1];var t,r}cross(e,t){return s=t,(r=e)[0]*s[1]-r[1]*s[0];var r,s}lerp(e,t,r){(function(s,a,n,u){var o=a[0],l=a[1];s[0]=o+u*(n[0]-o),s[1]=l+u*(n[1]-l)})(this,e,t,r)}applyMatrix3(e){var t,r,s,a,n;return t=this,s=e,a=(r=this)[0],n=r[1],t[0]=s[0]*a+s[3]*n+s[6],t[1]=s[1]*a+s[4]*n+s[7],this}applyMatrix4(e){return function(t,r,s){let a=r[0],n=r[1];t[0]=s[0]*a+s[4]*n+s[12],t[1]=s[1]*a+s[5]*n+s[13]}(this,this,e),this}equals(e){return r=e,(t=this)[0]===r[0]&&t[1]===r[1];var t,r}clone(){return new Se(this[0],this[1])}fromArray(e,t=0){return this[0]=e[t],this[1]=e[t+1],this}toArray(){return Array.from(this)}}class G extends Array{constructor(e=0,t=e,r=e){return super(e,t,r),this.constant=1,this}get isVector3(){return!0}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get z(){return this[2]}set z(e){this[2]=e}set(e,t=e,r=e){return e.length?this.copy(e):(function(s,a,n,u){s[0]=a,s[1]=n,s[2]=u}(this,e,t,r),this)}copy(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],t[2]=r[2],this}add(e,t){return t?nt(this,e,t):nt(this,this,e),this}sub(e,t){return t?ot(this,e,t):ot(this,this,e),this}multiply(e){var t,r,s;return e.length?(r=this,s=e,(t=this)[0]=r[0]*s[0],t[1]=r[1]*s[1],t[2]=r[2]*s[2]):Be(this,this,e),this}divide(e){var t,r,s;return e.length?(r=this,s=e,(t=this)[0]=r[0]/s[0],t[1]=r[1]/s[1],t[2]=r[2]/s[2]):Be(this,this,1/e),this}scale(e){return Be(this,this,e),this}distance(e){return e?function(t,r){let s=r[0]-t[0],a=r[1]-t[1],n=r[2]-t[2];return Math.sqrt(s*s+a*a+n*n)}(this,e):function(t){let r=t[0],s=t[1],a=t[2];return Math.sqrt(r*r+s*s+a*a)}(this)}squaredDistance(e){return e?function(t,r){let s=r[0]-t[0],a=r[1]-t[1],n=r[2]-t[2];return s*s+a*a+n*n}(this,e):function(t){let r=t[0],s=t[1],a=t[2];return r*r+s*s+a*a}(this)}squaredLength(){return this.squaredDistance()}negate(e=this){var t,r;return r=e,(t=this)[0]=-r[0],t[1]=-r[1],t[2]=-r[2],this}reflect(e){let t=e.clone();return this.sub(t.multiply(2*this.dot(e)))}inverse(e=this){var t,r;return r=e,(t=this)[0]=1/r[0],t[1]=1/r[1],t[2]=1/r[2],this}normalize(){return pe(this,this),this}dot(e){return ut(this,e)}cross(e,t){return function(r,s,a){let n=s[0],u=s[1],o=s[2],l=a[0],c=a[1],d=a[2];r[0]=u*d-o*c,r[1]=o*l-n*d,r[2]=n*c-u*l}(this,e,t),this}lerp(e,t,r){return function(s,a,n,u){let o=a[0],l=a[1],c=a[2];s[0]=o+u*(n[0]-o),s[1]=l+u*(n[1]-l),s[2]=c+u*(n[2]-c)}(this,e,t,r),this}hermite(e,t,r,s,a){return function(n,u,o,l,c,d){let h=d*d,f=h*(2*d-3)+1,m=h*(d-2)+d,x=h*(d-1),g=h*(3-2*d);n[0]=u[0]*f+o[0]*m+l[0]*x+c[0]*g,n[1]=u[1]*f+o[1]*m+l[1]*x+c[1]*g,n[2]=u[2]*f+o[2]*m+l[2]*x+c[2]*g}(this,e,t,r,s,a),this}bezier(e,t,r,s,a){return function(n,u,o,l,c,d){let h=1-d,f=h*h,m=d*d,x=f*h,g=3*d*f,p=3*m*h,v=m*d;n[0]=u[0]*x+o[0]*g+l[0]*p+c[0]*v,n[1]=u[1]*x+o[1]*g+l[1]*p+c[1]*v,n[2]=u[2]*x+o[2]*g+l[2]*p+c[2]*v}(this,e,t,r,s,a),this}applyMatrix4(e){return Wt(this,this,e),this}applyMatrix3(e){return Ct(this,this,e),this}applyQuaternion(e){return function(t,r,s){let a=r[0],n=r[1],u=r[2],o=s[0],l=s[1],c=s[2],d=s[3],h=d*a+l*u-c*n,f=d*n+c*a-o*u,m=d*u+o*n-l*a,x=-o*a-l*n-c*u;t[0]=h*d+x*-o+f*-c-m*-l,t[1]=f*d+x*-l+m*-o-h*-c,t[2]=m*d+x*-c+h*-l-f*-o}(this,this,e),this}setFromMatrixPosition(e){return this.x=e[12],this.y=e[13],this.z=e[14],this}angle(e){return function(t,r){let s=[...t],a=[...r];pe(s,s),pe(a,a);let n=ut(s,a);return n>1?0:n<-1?Math.PI:Math.acos(n)}(this,e)}equals(e){return r=e,(t=this)[0]===r[0]&&t[1]===r[1]&&t[2]===r[2];var t,r}clone(){return new G(this[0],this[1],this[2])}fromArray(e,t=0){return this[0]=e[t],this[1]=e[t+1],this[2]=e[t+2],this}min(e){return this[0]=Math.min(this[0],e.x),this[1]=Math.min(this[1],e.y),this[2]=Math.min(this[2],e.z),this}max(e){return this[0]=Math.max(this[0],e.x),this[1]=Math.max(this[1],e.y),this[2]=Math.max(this[2],e.z),this}toArray(){return Array.from(this)}static copyTo(e,t){e[0]=t[0],e[1]=t[1],e[2]=t[2]}}const U=[new G,new G,new G,new G,new G,new G,new G,new G];class N{constructor(e=new G(1/0),t=new G(-1/0)){this.min=e,this.max=t}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.add(this.min,this.max).multiply(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.sub(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}applyMatrix4(e){return this.isEmpty()||(U[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),U[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),U[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),U[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),U[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),U[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),U[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),U[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(U)),this}}class Ye{constructor(){this.focus=10,this.aperture=0,this.zoom=1,this.tempVec3a=new G,this.tempVec3b=new G,this.type="PerspectiveCamera",this.viewToWorldMat=new A,this.worldToViewMat=new A,this.viewToClipMat=new A,this.clipToViewMat=new A,this.position=new G}copy(e){return this.type=e.type,this.focus=e.focus,this.aperture=e.aperture,this.zoom=e.zoom,this.viewToWorldMat.copy(e.viewToWorldMat),this.worldToViewMat.copy(e.worldToViewMat),this.viewToClipMat.copy(e.viewToClipMat),this.clipToViewMat.copy(e.clipToViewMat),this.position.copy(e.position),this}clone(){return new Ye().copy(this)}updateFrustum(){this.frustum||(this.frustum=[new G,new G,new G,new G,new G,new G]);const e=new A().multiply(this.viewToClipMat,this.worldToViewMat);this.frustum[0].set(e[3]-e[0],e[7]-e[4],e[11]-e[8]).constant=e[15]-e[12],this.frustum[1].set(e[3]+e[0],e[7]+e[4],e[11]+e[8]).constant=e[15]+e[12],this.frustum[2].set(e[3]+e[1],e[7]+e[5],e[11]+e[9]).constant=e[15]+e[13],this.frustum[3].set(e[3]-e[1],e[7]-e[5],e[11]-e[9]).constant=e[15]-e[13],this.frustum[4].set(e[3]-e[2],e[7]-e[6],e[11]-e[10]).constant=e[15]-e[14],this.frustum[5].set(e[3]+e[2],e[7]+e[6],e[11]+e[10]).constant=e[15]+e[14];for(let t=0;t<6;t++){const r=1/this.frustum[t].distance();this.frustum[t].multiply(r),this.frustum[t].constant*=r}}frustumIntersectsMesh(e){if(!e.geometry.position||!e.geometry.aabb)return!0;const t=e.geometry.aabb;t.getCenter(this.tempVec3a);const r=this.tempVec3a,s=t.min.distance(t.max)/2;r.applyMatrix4(e.localToWorldMat);const a=s*e.localToWorldMat.getMaxScaleOnAxis();return this.frustumIntersectsSphere(r,a)}frustumIntersectsSphere(e,t){const r=this.tempVec3b;for(let s=0;s<6;s++){const a=this.frustum[s];if(r.copy(a).dot(e)+a.constant<-t)return!1}return!0}}class le{constructor(e=new pr,t=new de){this.geometry=e,this.material=t,this.visible=!0,this.tlasMask=!1,this.localToWorldMat=new A}get worldToLocalMat(){return new A().inverse(this.localToWorldMat)}copy(e){return this.geometry=e.geometry,this.material.copy(e.material),this.localToWorldMat.copy(e.localToWorldMat),this}clone(e=!0){let t=this.material;e&&(t=this.material.clone());const r=new le(this.geometry,t);return r.localToWorldMat.copy(this.localToWorldMat),r}}class qe{constructor(e=new G,t=0,r=new G,s=0,a=new G,n=0,u=new G,o=!0){this.position=e,this.radius=t,this.emission=r,this.area=s,this.p1=a,this.type=n,this.p2=u,this.visible=o}copy(e){return this.position.copy(e.position),this.radius=e.radius,this.emission.copy(e.emission),this.area=e.area,this.p1.copy(e.p1),this.type=e.type,this.p2.copy(e.p2),this.visible=e.visible,this}clone(){return new qe(this.position,this.radius,this.emission,this.area,this.p1,this.type,this.p2,this.visible)}}class C{constructor(e,t){this.array=e,this.itemSize=t}getItem(e,t){const r=this.array,s=this.itemSize,a=t*s;for(let n=0;n<s;n++)e[n]=r[a+n]}get count(){return this.array.length/this.itemSize}}class Pe{constructor(e,t,r,s){this.position=e,this.normal=t,this.uv=r,this.indices=s}}class pr extends Pe{constructor(){const e=new Float32Array([.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,-.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,.5,-.5,.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,-.5,-.5,.5,-.5,.5,-.5,-.5,-.5,-.5,-.5]),t=new Float32Array([1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),r=new Float32Array([0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0]),s=new Uint16Array([0,2,1,2,3,1,4,6,5,6,7,5,8,10,9,10,11,9,12,14,13,14,15,13,16,18,17,18,19,17,20,22,21,22,23,21]);super(new C(e,3),new C(t,3),new C(r,2),new C(s,1)),this.name="LGL_DefaultCubeGeometry",this.aabb=new N(new G(-.5,-.5,-.5),new G(.5,.5,.5))}}class mr{constructor(e){this.image=e,this.isTexture=!0,this.uvTransMat=new Z,this.wrapS=0,this.wrapT=0}}class Xt{constructor(){this.name="",this.type="",this.isRayTracingMaterial=!0}setValues(e){if(e!==void 0)for(const t in e){const r=e[t];if(r===void 0){console.warn(`${this.name}: ${t} parameter is undefined.`);continue}const s=this[t];s!==void 0&&(s&&s.isColor?s.set(r):s&&s.isVector3&&r&&r.isVector3?s.copy(r):this[t]=r)}}copy(e){}}class de extends Xt{constructor(e){super(),this.type="PrincipleBSDF",this.workflow="Metalness",this.color=new F(1,1,1),this.roughness=.5,this.metalness=0,this.transmission=0,this.ior=1.5,this.clearcoat=0,this.clearcoatRoughness=0,this.sheen=0,this.sheenTint=.5,this.specularTint=0,this.atDistance=1,this.extinction=new F(1,1,1),this.anisotropic=0,this.subsurface=0,this.subsurfaceColor=new F(1,1,1),this.subsurfaceMFP=.05,this.emissiveColor=new F(0,0,0),this.normalScale=new Se(1,1),this.alpha=1,this.map=null,this.normalMap=null,this.roughnessMap=null,this.metalnessMap=null,this.emissiveMap=null,this.specularColor=new F(1,1,1),this.glossiness=1,this.specularMap=null,this.glossinessMap=null,this.setValues(e)}isIncludeTexture(){return!!(this.map||this.normalMap||this.roughnessMap||this.metalnessMap||this.emissiveMap||this.specularMap||this.glossinessMap)}copy(e){return this.name=`copy_${e.name}`,this.type=e.type,this.workflow=e.workflow,this.color=new F().copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.transmission=e.transmission,this.ior=e.ior,this.specularTint=e.specularTint,this.clearcoat=e.clearcoat,this.clearcoatRoughness=e.clearcoatRoughness,this.sheen=e.sheen,this.sheenTint=e.sheenTint,this.atDistance=e.atDistance,this.anisotropic=e.anisotropic,this.extinction=new F().copy(e.extinction),this.subsurface=e.subsurface,this.subsurfaceColor=new F().copy(e.subsurfaceColor),this.subsurfaceMFP=e.subsurfaceMFP,this.emissiveColor=new F().copy(e.emissiveColor),this.normalScale=new Se().copy(e.normalScale),this.alpha=e.alpha,this.map=e.map,this.normalMap=e.normalMap,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.emissiveMap=e.emissiveMap,this.specularColor=new F().copy(e.specularColor),this.glossiness=e.glossiness,this.specularMap=e.specularMap,this.glossinessMap=e.glossinessMap,this}clone(){return new de().copy(this)}}class Je{constructor(e,t,r="f32",s=1,a=GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM){switch(this.rg=e,r){case"u32":this.data=new Uint32Array(s);break;case"f32":this.data=new Float32Array(s);break;case"i32":this.data=new Int32Array(s)}this.rawBuffer=e.resourcePool.getOrCreateResource(t,{size:this.data.byteLength,usage:a}).raw}setData(e,t){this.data[e]=t}submit(){this.rg.device.queue.writeBuffer(this.rawBuffer,0,this.data)}destroy(){this.rawBuffer.destroy()}}const we={i32:{align:4,size:4,count:1},u32:{align:4,size:4,count:1},f32:{align:4,size:4,count:1},atomic:{align:4,size:4,count:1},"vec2<f32>":{align:8,size:8,count:2},"vec3<f32>":{align:16,size:12,count:3},"vec4<f32>":{align:16,size:16,count:4},"vec2<u32>":{align:8,size:8,count:2},"vec3<u32>":{align:16,size:12,count:3},"vec4<u32>":{align:16,size:16,count:4},"vec2<i32>":{align:8,size:8,count:2},"vec3<i32>":{align:16,size:12,count:3},"vec4<i32>":{align:16,size:16,count:4},"mat2x2<f32>":{align:8,size:16,count:4},"mat3x3<f32>":{align:16,size:48,count:12},"mat4x4<f32>":{align:16,size:64,count:16}};function ft(i){return!!(i&&typeof i=="object"&&(Array.isArray(i)||ArrayBuffer.isView(i)&&!(i instanceof DataView)))}class ie{static get desc(){throw new Error("This method must be implemented!")}static getStride(){const e=this.desc;let t=Math.max(...e.map(s=>this.getMemberAlignment(s))),r=0;for(const s of e){const a=this.getMemberAlignment(s),n=r%a;r%a!=0&&(r+=a-n),r+=this.getMemberSize(s)}return r%t!=0&&(r+=t-r%t),r}static getMemberAlignment(e){return we[e.type].align}static getMemberSize(e){return we[e.type].size}constructor(e){const t=this.constructor.desc,r=/<(.*?)>/,s=[];for(const a of t){const n={};n.name=a.name,n.type=a.type;const u=e[a.name];if(u===void 0)throw new Error(`Unexpected member value for: ${a.name}`);if(n.value=u,n.count=we[a.type].count,(ft(u)?u:[u]).length!==n.count)throw new Error(`Unexpected member length: ${a.name} ${u}`);if(n.count===1)n.format=n.type;else{let o=n.type.match(r);if(!o)throw new Error(`Unexpected member format: ${n.type}`);n.format=o[1]}s.push(n)}this.members=s}toArrayBuffer(){const e=new ArrayBuffer(this.constructor.getStride()),t=new DataView(e);let r=0;for(const s of this.members){let a=r+this.constructor.getMemberSize(s);for(let n=0;n<s.count;n++){const u=ft(s.value)?s.value:[s.value];switch(s.format){case"i32":t.setInt32(r,u[n],!0);break;case"f32":t.setFloat32(r,u[n],!0);break;case"u32":t.setUint32(r,u[n],!0);break;default:throw new Error(`Unsupported member type: ${s.format}`)}r+=4}r=a}return e}}const gr=4,xr=!0,Qe=!0,br=4,Ft=!1,Dt=.05,Nt=.02,At=.35,vr={size:1,usage:GPUBufferUsage.UNIFORM},Lr={size:{width:1,height:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING};class yr{constructor(e){this.device=e,this.passNodes=[],this.resourceNodes=[],this.frameGraphPasses=[],this.computePipelines=new Map,this.renderPipelines=new Map,this.bindGroups=new Map,this.needsResize=!1,this.resourcePool=new Tr(e),this.samplers={llc:e.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),llr:e.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"repeat",addressModeV:"repeat"}),nnc:e.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),nnr:e.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"repeat",addressModeV:"repeat"})}}async getOrCreateComputePipeline(e,t,r){const{device:s}=this,a=`${e}-${t}`;if(this.computePipelines.get(a))return this.computePipelines.get(a);{const n=await s.createComputePipelineAsync({layout:"auto",compute:{module:s.createShaderModule({code:r}),entryPoint:"main"}});return this.computePipelines.set(a,n),n}}getComputePipeline(e,t=""){const r=`${e}-${t}`;return this.computePipelines.get(r)}getRenderPipeline(e,t=""){const r=`${e}-${t}`;return this.renderPipelines.get(r)}setRenderPipeline(e,t="",r){const s=`${e}-${t}`;return this.renderPipelines.set(s,r)}getPassResFromPool(e){const{resourcePool:t}=this;if(e){const r=this.getResourceNode(e).resource;return t.getOrCreateResource(r.name,r.descriptor,r.syncResize)}}getPassRawResFromPool(e){return this.getPassResFromPool(e).raw}getRawResFromPool(e){return this.resourcePool.getResourceByName(e).raw}getBindGroupByHandles(e,t,r,s){var a;let n="";r.forEach(o=>{const l=this.getResourceNode(o).resource,c=l.name,d=JSON.stringify(l.descriptor);n+=`-${c}/${d}`});const u=`${e}-${n}`;if(this.bindGroups.get(u))return this.bindGroups.get(u);{const o=[];if(r.forEach((c,d)=>{const h=this.getPassResFromPool(c),{raw:f,type:m}=h;o.push({binding:d,resource:m=="Texture"?f.createView():{buffer:f}})}),(a=s==null?void 0:s.samplers)==null?void 0:a.length){const c=o.length;s.samplers.forEach((d,h)=>{const f=this.samplers[d];o.push({binding:c+h,resource:f})})}const l=this.device.createBindGroup({layout:t.getBindGroupLayout(0),entries:o});return this.bindGroups.set(u,l),l}}getBindGroup(e,t,r,s){const a=[...r.reads,...r.writes];return this.getBindGroupByHandles(e,t,a,s)}checkResourceNodeCache(e){let t=null;return this.resourceNodes.forEach((r,s)=>{if(e==r.resource.name)return t=new pt,void(t.index=s)}),t}importResource(e,t=!1){const r=new Ie;return r.name=e,r.imported=!0,r.syncResize=t,this.createResourceNode(r)}createTexture(e,t=Lr,r=!1){const s=new Ie;return s.name=e,s.descriptor=t,s.syncResize=r,this.createResourceNode(s)}createBuffer(e,t=vr,r=!1){const s=new Ie;return s.name=e,s.descriptor=t,s.syncResize=r,this.createResourceNode(s)}createResourceNode(e){const t=this.checkResourceNodeCache(e.name);if(t)return t;const r=new Gr;r.resource=e,this.resourceNodes.push(r);const s=new pt;return s.index=this.resourceNodes.length-1,s}getPass(e){return this.frameGraphPasses.find(t=>t.name===e)}getResourceNode(e){return this.resourceNodes[e.index]}addPass(e,t){const r=new Sr;r.execute=t.execute.bind(t),t.tearDown&&(r.tearDown=t.tearDown.bind(t)),r.name=e;const s=new Mr;return s.name=e,this.passNodes.push(s),this.frameGraphPasses.push(r),t.setup(this,s,r),r}setDebugHookPass(){this.passNodes[this.passNodes.length-1].name}addDebugHook(){}execute(e){this.compile(),this.executePassNodes(e)}compile(){for(const t of this.passNodes)t.refCount=t.writes.length+(t.hasSideEffect?1:0),t.reads.forEach(r=>{this.resourceNodes[r.index].readerCount++});const e=[];for(const t of this.resourceNodes)t.readerCount===0&&e.push(t);for(;e.length;){const t=e.pop(),r=t&&t.writer;if(r&&--r.refCount==0)for(const s of r.reads){const a=this.resourceNodes[s.index];--a.readerCount==0&&e.push(a)}}this.resourceNodes.forEach(t=>{t.resource.refs+=t.readerCount})}executePassNodes(e){for(const[t,r]of this.passNodes.entries())if(r.refCount){const s=this.frameGraphPasses[t];s.execute(this,s,r,e)}this.reset()}setSize(){this.needsResize=!0,this.destroyPreSizeRes(),this.forceUpdateBG()}forceUpdateBG(){this.bindGroups=new Map}destroyPreSizeRes(){const e=this.resourcePool.getPool();for(const t in e)e[t].syncResize&&this.resourcePool.destoryResourceByName(t)}reset(){this.passNodes=[],this.resourceNodes=[],this.frameGraphPasses=[]}tearDown(){this.frameGraphPasses.forEach(e=>{e.tearDown&&e.tearDown()}),this.reset()}}class Sr{}class Mr{constructor(){this.refCount=0,this.hasSideEffect=!1,this.devirtualize=[],this.destroy=[],this.reads=[],this.writes=[]}read(e){return this.reads.find(t=>t.index===e.index)||this.reads.push(e),e}write(e,t,r=!1){if(this.writes.find(n=>n.index===t.index))return t;const s=e.getResourceNode(t);s.resource.version++,(s.resource.imported||r)&&(this.hasSideEffect=!0);const a=e.createResourceNode(s.resource);return e.getResourceNode(a).writer=this,r||this.writes.push(a),a}}class Ie extends class{}{constructor(){super(...arguments),this.version=0,this.refs=0}devirtualize(){}destroy(){}}class pt{}class Gr{constructor(){this.readerCount=0}}class Tr{constructor(e){this.device=e,this.resourcePool={}}getOrCreateResource(e,t,r=!1){const{device:s}=this;return this.resourcePool[e]||(function(a){return"format"in a}(t)?this.resourcePool[e]={raw:s.createTexture(t),type:"Texture",syncResize:r}:this.resourcePool[e]={raw:s.createBuffer(t),type:"Buffer",syncResize:r}),this.resourcePool[e]}getResourceByName(e){return this.resourcePool[e]}destoryResourceByName(e){this.resourcePool[e]&&(this.resourcePool[e].raw.destroy(),delete this.resourcePool[e])}setResource(e,t,r,s=!1){this.destoryResourceByName(e),this.resourcePool[e]={raw:t,type:r,syncResize:s}}updateResource(e,t,r,s=!1){this.destoryResourceByName(e),this.resourcePool[e]={raw:t,type:r,syncResize:s}}createOrUpdateResource(e){return this.resourcePool[e.name]&&this.destoryResourceByName(e.name),this.getOrCreateResource(e.name,e.descriptor,e.syncResize),this.resourcePool[e.name]}getPool(){return this.resourcePool}destroy(){for(const e in this.resourcePool)this.resourcePool[e].raw.destroy();this.resourcePool={}}}function mt(i,e,t){var r;return Object.assign({},t,{lightNum:(r=i.lights)==null?void 0:r.length,enableSSS:i.includeSSS,enableVolume:i.includeVolume,enableAtomsphere:i.includeAtomsphere})}const _r=["color","roughness","metalness","transmission","ior","clearcoat","clearcoatRoughness","sheen","sheenTint","specularTint","atDistance","extinction","anisotropic","subsurface","subsurfaceColor","subsurfaceMFP","normalScale","alpha","specularColor","glossiness","glossiness","emissiveIntensity","emissive"],De=["map","normalMap","roughnessMap","metalnessMap","specularMap","glossinessMap","emissiveMap"],gt={1e3:0,1001:1,1002:2};function Ne(i){const e=new Map;for(const t of i){const r=t.material;let s=e.get(r);s===void 0&&(s=e.size,e.set(r,s))}return e.size==0&&e.set(new Xt,0),e}function ze(i,e=!1,t=new Map){i.updateMatrixWorld(!0);const r=[],s=[];if(e){const o=new le;o.name="LGLDefaultMesh",o.material.name="LGLDefaultMaterial",o.visible=!1,r.push(o)}let a=!1;const n=new Map;i.traverse(o=>{if(o.isMesh){let l=o;if(l.geometry){let c=l.material;if(l.material||(c=new de),!c.isRayTracingMaterial){const f=n.get(c);f?c=f:(c=me(l.material),n.set(l.material,c))}c.subsurface>0&&(a=!0);let d=t.get(l.geometry.id);d||(d=Vt(l.geometry),t.set(l.geometry.id,d));const h=new le(d,c);re.linkMeshWithTHREEMesh(h,l),r.push(h)}else console.warn(`${o.name} need geometry data`)}if(o.isLight){const l=Ae(o);s.push(l)}});const u=Ne(r);return{meshes:r,materialIndexMap:u,materials:Array.from(u.keys()),geometryConvertMap:t,lights:s,includeSSS:a,includeVolume:!1,includeAtomsphere:!1}}function Ae(i){const e=new A,t=new fr,r=i,s=new qe,a=new G;switch(r.updateWorldMatrix(!0,!1),a.setFromMatrixPosition(r.matrixWorld.elements),s.position=a,s.emission=new G().fromArray(r.color.toArray()).multiply(r.intensity),s.radius=r.radius||0,s.area=0,s.visible=r.visible,s.p1=new G,s.p2=new G,r.type){case"RectAreaLight":if(s.type=0,r.matrix.compose(r.position,r.quaternion,r.scale),e.fromArray(r.matrixWorld.elements),e.getRotation(t),r.width&&r.height){const n=new G(r.width,0,0);n.applyQuaternion(t);const u=new G(0,r.height,0);u.applyQuaternion(t),s.p1.copy(u),s.p2.copy(n),s.area=new G().cross(s.p1,s.p2).distance()}break;case"PointLight":s.type=2,s.area=0;break;case"DirectionalLight":s.type=1,r.target&&s.p1.fromArray(r.target.position.toArray()),s.area=0;break;default:console.warn(`Current no support light type: ${r.type}`)}return re.linkLightWithTHREELight(s,i),s}function xt(i,e){i.updateMatrixWorld(!0);const t=e||new Ye;return t.type=i.type,t.viewToWorldMat.fromArray(i.matrixWorld.elements),t.worldToViewMat.fromArray(i.matrixWorldInverse.elements),t.clipToViewMat.fromArray(i.projectionMatrixInverse.elements),t.viewToClipMat.fromArray(i.projectionMatrix.elements),t.position.fromArray(i.position.toArray()),i.aperture!=null&&(t.aperture=i.aperture||0),i.focus!=null&&(t.focus=i.focus||0),i.zoom!=null&&(t.zoom=i.zoom||1),t}function We(i,e){const t=i.getAttribute(e);return t!=null&&t.isInterleavedBufferAttribute?t.clone():t}function Vt(i){var e,t;const r=We(i,"position"),s=We(i,"normal"),a=We(i,"uv"),n=i.getIndex(),u=new Pe(r&&new C(r.array,r.itemSize),s&&new C(s.array,s.itemSize),a&&new C(a.array,a.itemSize),n&&new C(n.array,n.itemSize));return u.id=`LGL_${i.id}`,u.name=`LGL_${i.name}`,i.boundingBox||i.computeBoundingBox(),u.aabb=new N,u.aabb.min.fromArray((e=i.boundingBox)==null?void 0:e.min.toArray()),u.aabb.max.fromArray((t=i.boundingBox)==null?void 0:t.max.toArray()),u}function Ut(i,e){De.forEach(t=>{const r=i[t],s=e[t];r&&(r.updateMatrix(),s.uvTransMat.fromArray(r.matrix.toArray()),s.wrapS=gt[r.wrapS],s.wrapT=gt[r.wrapT])})}function O(i){return i?new mr(i.image):null}function me(i,e){var t,r,s,a,n,u,o,l,c;Array.isArray(i)&&(i=i[0]);const d=e||new de;return d.name=`LGL_${i.name}`,function(h,f){_r.forEach(m=>{if(h[m]==null&&h.userData[m]==null)switch(m){case"emissive":h.userData[m]=f.emissiveColor.toArray();break;case"emissiveIntensity":h.userData[m]=1;break;default:h.userData[m]=f[m].toArray?f[m].toArray():f[m]}})}(i,d),i.color?d.color.fromArray(i.color.toArray()):d.color.fromArray(i.userData.color),d.roughness=(t=i.roughness)!=null?t:i.userData.roughness,d.metalness=(r=i.metalness)!=null?r:i.userData.metalness,d.transmission=(s=i.transmission)!=null?s:i.userData.transmission,d.ior=(a=i.ior)!=null?a:i.userData.ior,i.emissive?d.emissiveColor.fromArray(i.emissive.toArray()).scale(i.emissiveIntensity):d.emissiveColor.fromArray(i.userData.emissive).scale(i.userData.emissiveIntensity),i.normalScale?d.normalScale.fromArray(i.normalScale.toArray()):d.normalScale.fromArray(i.userData.normalScale),d.clearcoat=(n=i.clearcoat)!=null?n:i.userData.clearcoat,d.clearcoatRoughness=(u=i.clearcoatRoughness)!=null?u:i.userData.clearcoatRoughness,d.sheen=(o=i.sheen)!=null?o:i.userData.sheen,d.sheenTint=(l=i.sheenTint)!=null?l:i.userData.sheenTint,d.alpha=(c=i.opacity)!=null?c:i.userData.alpha,d.map=O(i.map),d.normalMap=O(i.normalMap),d.emissiveMap=O(i.emissiveMap),d.roughnessMap=O(i.roughnessMap),d.metalnessMap=O(i.metalnessMap),i.isGLTFSpecularGlossinessMaterial&&(d.workflow="Specular",d.specularColor.fromArray(i.specular.toArray()),d.glossiness=i.glossiness,d.specularMap=O(i.specularMap),d.glossinessMap=O(i.glossinessMap)),d.subsurface=i.userData.subsurface,d.subsurfaceMFP=i.userData.subsurfaceMFP,d.subsurfaceColor.fromArray(i.userData.subsurfaceColor),d.specularTint=i.userData.specularTint,d.atDistance=i.userData.atDistance,d.extinction.fromArray(i.userData.extinction),d.anisotropic=i.userData.anisotropic,Ut(i,d),d}const he=Pr();function Pr(){const i=new ArrayBuffer(4),e=new Float32Array(i),t=new Uint32Array(i),r=new Uint32Array(512),s=new Uint32Array(512);for(let o=0;o<256;++o){const l=o-127;l<-27?(r[o]=0,r[256|o]=32768,s[o]=24,s[256|o]=24):l<-14?(r[o]=1024>>-l-14,r[256|o]=1024>>-l-14|32768,s[o]=-l-1,s[256|o]=-l-1):l<=15?(r[o]=l+15<<10,r[256|o]=l+15<<10|32768,s[o]=13,s[256|o]=13):l<128?(r[o]=31744,r[256|o]=64512,s[o]=24,s[256|o]=24):(r[o]=31744,r[256|o]=64512,s[o]=13,s[256|o]=13)}const a=new Uint32Array(2048),n=new Uint32Array(64),u=new Uint32Array(64);for(let o=1;o<1024;++o){let l=o<<13,c=0;for(;!(8388608&l);)l<<=1,c-=8388608;l&=-8388609,c+=947912704,a[o]=l|c}for(let o=1024;o<2048;++o)a[o]=939524096+(o-1024<<13);for(let o=1;o<31;++o)n[o]=o<<23;n[31]=1199570944,n[32]=2147483648;for(let o=33;o<63;++o)n[o]=2147483648+(o-32<<23);n[63]=3347054592;for(let o=1;o<64;++o)o!==32&&(u[o]=1024);return{floatView:e,uint32View:t,baseTable:r,shiftTable:s,mantissaTable:a,exponentTable:n,offsetTable:u}}function Br(i,e,t){return .2126*i+.7152*e+.0722*t}function kt(i,e,t){return Math.min(Math.max(i,e),t)}function bt(i,e,t=1e-4){for(let r=0;r<i.length;r++)if(Math.abs(i[r]-e[r])>t)return!1;return!0}function vt(i){return Number(i.replace("px",""))}function Rr(i){if(i instanceof Uint16Array)return i;const e=new Uint16Array(i.length);return i.map((t,r)=>e[r]=function(s){Math.abs(s)>65504&&console.warn("toHalfFloat(): Value out of range."),s=Math.max(-65504,Math.min(65504,s)),he.floatView[0]=s;const a=he.uint32View[0],n=a>>23&511;return he.baseTable[n]+((8388607&a)>>he.shiftTable[n])}(t)),e}function Lt(i,e,t=0,r=i.length){let s=t,a=t+r-1;for(;s<a;){const n=s+a>>1;i[n]<e?s=n+1:a=n}return s-t}const wr={width:1,height:1,data:new Float32Array(4)},q=class{constructor(i,e){this.device=i,this.resourcePool=e,this.totalSumValue=1}destory(){const{resourcePool:i}=this;i.destoryResourceByName(q.ENVMAP_RES_NAME),i.destoryResourceByName(q.ENVMAP_MARGINAL_WEIGHTS_RES_NAME),i.destoryResourceByName(q.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME)}load(i){i||(i=wr);const{device:e,resourcePool:t}=this;this.destory();const r=i.width,s=i.height,a=Rr(i.data),n={size:{width:r,height:s},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},u=e.createTexture(n);e.queue.writeTexture({texture:u},a,{bytesPerRow:2*r*4,rowsPerImage:s},{width:r,height:s,depthOrArrayLayers:1});const{marginalDataArray:o,conditionalDataArray:l,totalSumValue:c}=function(x){const{width:g,height:p,data:v}=x,b=new Float32Array(g*p),L=new Float32Array(g*p),S=new Float32Array(p),y=new Float32Array(p);let M=0,T=0;for(let P=0;P<p;P++){let w=0;for(let W=0;W<g;W++){const I=P*g+W,X=Br(v[4*I+0],v[4*I+1],v[4*I+2]);w+=X,M+=X,b[I]=X,L[I]=w}if(w!==0)for(let W=P*g,I=P*g+g;W<I;W++)b[W]/=w,L[W]/=w;T+=w,S[P]=w,y[P]=T}if(T!==0)for(let P=0,w=S.length;P<w;P++)S[P]/=T,y[P]/=T;const _=new Float32Array(p),B=new Float32Array(g*p);for(let P=0;P<p;P++){const w=Lt(y,(P+1)/p);_[P]=(w+.5)/p}for(let P=0;P<p;P++)for(let w=0;w<g;w++){const W=P*g+w,I=Lt(L,(w+1)/g,P*g,g);B[W]=(I+.5)/g}return{marginalDataArray:_,conditionalDataArray:B,totalSumValue:M}}(i);this.totalSumValue=c;const d={size:{width:s,height:1},format:"r32float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},h=e.createTexture(d);e.queue.writeTexture({texture:h},o,{bytesPerRow:4*s,rowsPerImage:1},{width:s,height:1,depthOrArrayLayers:1});const f={size:{width:r,height:s},format:"r32float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},m=e.createTexture(f);e.queue.writeTexture({texture:m},l,{bytesPerRow:4*r,rowsPerImage:s},{width:r,height:s,depthOrArrayLayers:1}),t.setResource(q.ENVMAP_RES_NAME,u,"Texture"),t.setResource(q.ENVMAP_MARGINAL_WEIGHTS_RES_NAME,h,"Texture"),t.setResource(q.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME,m,"Texture")}};let j=q;function Ve(i,e=!1){const t=new Map;let r=0,s=0,a=0,n=0;const u=[];u.push({vertexSplitIndex:0,indicesSplitIndex:0});for(const o of i){let l=o.geometry;if(t.get(l)==null){l.indices||zr(l),l.uv||Wr(l),e&&(l=Ir(l,o.localToWorldMat)),l.normal?Fe(l.normal.array,3,0,void 0,pe,void 0):Cr(l),a+=l.position.count,n+=l.indices.count,u.push({vertexSplitIndex:3*a,indicesSplitIndex:n});const c=t.size;t.set(l,c),o.geometry=l}r+=l.position.count,s+=l.indices.count}return{vertexTotalCount:a,indicesTotalCount:n,geoInfoSplitIndex:u,renderVertexCount:r,renderIndicesCount:s,geometryIndexMap:t}}function Ir(i,e){const t=new Pe(new C(i.position.array.slice(),i.position.itemSize),i.normal&&new C(i.normal.array.slice(),i.normal.itemSize),i.uv&&new C(i.uv.array,i.uv.itemSize),i.indices&&new C(i.indices.array,i.indices.itemSize)),r=new Z().getNormalMatrix(e);return Fe(t.position.array,3,0,null,Wt,e),t.normal&&Fe(t.normal.array,3,0,null,Ct,r),t}function zr(i){const e=i.position;if(!e)return void console.error("This model no position data");const t=new Uint32Array(e.count);for(let r=0;r<t.length;r++)t[r]=r;return i.indices=new C(t,1),i}function Wr(i){const e=i.position,t=new Float32Array(2*e.count);for(let r=0;r<t.length;r++)t[r]=Math.random();return i.uv=new C(t,2),i}function Cr(i){const e=i.indices.array,t=i.position.array;i.normal=new C(new Float32Array(t.length),3);const r=i.normal.array,s=new G,a=new G,n=new G,u=new G,o=new G,l=new G,c=e.length;let d,h,f;for(let m=0;m<c;){e?(d=e[m++],h=e[m++],f=e[m++]):(d=m++,h=m++,f=m++),s.set(t[3*d],t[3*d+1],t[3*d+2]),a.set(t[3*h],t[3*h+1],t[3*h+2]),n.set(t[3*f],t[3*f+1],t[3*f+2]),u.sub(s,a),o.sub(a,n),l.cross(u,o);for(let x=0;x<3;x++)r[3*d+x]=r[3*d+x]+l[x],r[3*h+x]=r[3*h+x]+l[x],r[3*f+x]=r[3*f+x]+l[x]}for(let m=0;m<r.length;)l.set(r[m],r[m+1],r[m+2]),l.normalize(),r[m++]=l[0],r[m++]=l[1],r[m++]=l[2]}function Ce(i,e,t){const r=[],{renderVertexCount:s,renderIndicesCount:a}=t;for(const u of i){let o=u.geometry;const l=u.material;let c=e.get(l);r.push({geometry:o,materialIndex:c})}return{geometry:function(u,o,l){const c=new C(new Float32Array(3*o),3),d=new C(new Float32Array(3*o),3),h=new C(new Float32Array(2*o),2),f=new C(new Uint32Array(l),1),m=new C(new Int32Array(2*o),2),x=new Pe(c,d,h,f);x.materialMeshIndex=m;let g=0,p=0,v=0;for(const{geometry:b,materialIndex:L}of u){const S=b.position.count;["position","normal","uv"].forEach(M=>{b[M]&&x[M].array.set(b[M].array,g*b[M].itemSize)});const y=b.indices.array;for(let M=0;M<y.length;M++)f.array[p+M]=g+y[M];for(let M=0;M<2*S;)m.array[2*g+M++]=L,m.array[2*g+M++]=v;g+=S,p+=y.length,v++}return x}(r,s,a),vertexCount:s,IndicesCount:a,visible:!0}}j.ENVMAP_RES_NAME="EnvMapTexture",j.ENVMAP_MARGINAL_WEIGHTS_RES_NAME="EnvMapMarginalWeightsTexture",j.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME="EnvMapConditionalWeightsTexture";var Et=()=>"struct VertexOutput{@builtin(position)position : vec4<f32>,@location(0)uv : vec2<f32>};@vertex fn main(@builtin(vertex_index)VertexIndex : u32)->VertexOutput{var output : VertexOutput;output.uv=vec2<f32>(f32((VertexIndex<<1)&2),f32(VertexIndex&2));output.position=vec4<f32>(output.uv*2.0-1.0,0.0,1.0);return output;}",Xr=()=>"@group(0)@binding(0)var inputTex : texture_2d<f32>;@group(0)@binding(1)var screenSampler : sampler;struct VertexOutput{@builtin(position)position : vec4<f32>,@location(0)uv : vec2<f32>};@fragment fn main(vo : VertexOutput)->@location(0)vec4<f32>{var uv=vo.uv;uv.y=1.-uv.y;return textureSample(inputTex,screenSampler,uv);}";async function Fr(i,e){const t=new Map;let r=0;e.forEach(n=>{Object.keys(n).forEach(u=>{var o;if((o=n[u])!=null&&o.isTexture){const l=n[u].image;let c=t.get(l);c===void 0&&r<255&&(c=t.size,t.set(l,c),r++)}})});let s,a=Array.from(t.keys());return r==255&&console.warn("Material limit exceeded. Some material information will be lost"),a.length==0?s=function(n){return n.createTexture({size:{width:1,height:1,depthOrArrayLayers:2},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT})}(i):(a.length==1&&(a=[a[0],a[0]]),s=await async function(n,u){const o=n.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"}),l=await n.createRenderPipelineAsync({layout:"auto",vertex:{module:n.createShaderModule({code:Et()}),entryPoint:"main"},fragment:{module:n.createShaderModule({code:Xr()}),entryPoint:"main",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list"}}),c=n.createTexture({size:{width:2048,height:2048,depthOrArrayLayers:u.length},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),d=n.createCommandEncoder(),h=[];for(let f=0;f<u.length;f++){const m=u[f],x=n.createTexture({size:{width:m.width,height:m.height},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});h.push(x),n.queue.copyExternalImageToTexture({source:m,flipY:!1},{texture:x},{width:m.width,height:m.height});const g=x,p=n.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:g.createView()},{binding:1,resource:o}]}),v=c.createView({dimension:"2d",baseArrayLayer:f,arrayLayerCount:1}),b=d.beginRenderPass({colorAttachments:[{view:v,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});b.setPipeline(l),b.setBindGroup(0,p),b.draw(6,1,0,0),b.end()}return n.queue.submit([d.finish()]),await n.queue.onSubmittedWorkDone(),h.forEach(f=>f.destroy()),c}(i,a)),{textureImages:a,textureImageMap:t,textureArrayRes:s}}function Y(i,e){return e!=null&&e.image?i.get(e.image):-1}function je(i,e,t){const r=[];e.map(o=>{r.push(...o.color),r.push(o.workflow==="Metalness"?0:1),r.push(kt(o.roughness,.001,1)),r.push(o.metalness),r.push(o.transmission),r.push(o.ior),r.push(o.sheen),r.push(o.sheenTint),r.push(o.clearcoat),r.push(o.clearcoatRoughness),r.push(...o.emissiveColor),r.push(o.alpha),r.push(o.specularTint),r.push(o.atDistance),r.push(...o.normalScale),r.push(...o.subsurfaceColor),r.push(o.subsurface),r.push(...o.extinction),r.push(Math.max(o.subsurfaceMFP,.01)),r.push(...o.specularColor),r.push(o.glossiness),r.push(0,0,0,0,0,0,0,0)});const s=40*Float32Array.BYTES_PER_ELEMENT,a=s*e.length,n=i.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),u=new Float32Array(n.getMappedRange());return u.set(r,0),e.map((o,l)=>{const c=s*l+32*Float32Array.BYTES_PER_ELEMENT,d=new Int32Array(u.buffer,c,8);d[0]=Y(t,o.map),d[1]=Y(t,o.normalMap),d[2]=Y(t,o.roughnessMap),d[3]=Y(t,o.metalnessMap),d[4]=Y(t,o.emissiveMap),d[5]=Y(t,o.specularMap),d[6]=Y(t,o.glossinessMap),d[7]=0}),n.unmap(),n}async function Me(i,e){const{textureImageMap:t,textureArrayRes:r}=await Fr(i,e);return{textureImageMap:t,materialBuffer:je(i,e,t),textureArrayRes:r}}function Kt(i){const{mapNum:e,perMatrixLength:t,perWrappingDataLength:r,bufferSize:s}=function(l){const c=De.length;return{mapNum:c,perMatrixLength:12,perWrappingDataLength:4,bufferSize:l.size*c*16}}(i),a=new Float32Array(s),n=new Z,u=e*t,o=e*r+u;return i.forEach((l,c)=>{De.forEach((d,h)=>{const f=c[`${d}`];let m=n.toWebGPUFormat();f&&(m=f.uvTransMat.toWebGPUFormat());const x=o*l;for(let b=0;b<t;b++)a[x+h*t+b]=m[b];let g=0,p=0;f&&(g=f.wrapS,p=f.wrapT);const v=x+u+h*r;a[v+0]=g,a[v+1]=p,a[v+2]=0,a[v+3]=0})}),{bufferSize:s,uvTransformBufferData:a}}function Ht(i,e,t){const{uvTransformBufferData:r}=Kt(e);i.queue.writeBuffer(t,0,r)}function Ge(i,e){const{bufferSize:t,uvTransformBufferData:r}=Kt(e),s=i.createBuffer({mappedAtCreation:!0,size:t*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});return new Float32Array(s.getMappedRange()).set(r,0),s.unmap(),s}function Zt(i,e){const t=256*Float32Array.BYTES_PER_ELEMENT,r=i.createBuffer({size:t,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return $e(i,r,e),r}function $e(i,e,t){if(!t||!(t!=null&&t.length)){const a=new Float32Array(256);return void i.queue.writeBuffer(e,0,a)}const r=new Float32Array(256);let s=0;return t.forEach((a,n)=>{if(n>=16)return;const u=function(o){return[...o.position,o.radius,...o.emission,o.area,...o.p1,o.type,...o.p2,Number(o.visible)]}(a);r.set(u,s),s+=16}),i.queue.writeBuffer(e,0,r),e}class Dr{constructor(e){this.device=e,this.device=e,this.data=new Float32Array(8),this.input={buffer:e.createBuffer({size:this.data.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),data:this.data.buffer,min:this.data.subarray(0,3),range:this.data.subarray(4,7),triangleCount:new Uint32Array(this.data.buffer,28,1)}}get buffer(){return this.input.buffer}set(e,t){const{device:r,input:s}=this;G.copyTo(s.min,e.min),G.copyTo(s.range,new G().sub(e.max,e.min)),s.triangleCount[0]=t,r.queue.writeBuffer(s.buffer,0,s.data)}destroy(){const{input:e}=this;e.buffer.destroy()}}function yt(i){var e=i-1;return e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,(e|=e>>16)+1}function St(i,e,t){var r=[],s=[],a=Math.ceil(e/i.limits.maxComputeWorkgroupsPerDimension),n=i.createBuffer({size:256*a,usage:GPUBufferUsage.UNIFORM,mappedAtCreation:!0}),u=null;if(t){var o=t;t.buffer&&(o=t.buffer),o.byteLength,u=new Uint8Array(o)}for(var l=n.getMappedRange(),c=0;c<a;++c){r.push(256*c),c+1<a?s.push(i.limits.maxComputeWorkgroupsPerDimension):s.push(e%i.limits.maxComputeWorkgroupsPerDimension);var d=new Uint32Array(l,256*c,2);d[0]=i.limits.maxComputeWorkgroupsPerDimension*c,d[1]=e,u&&new Uint8Array(l,256*c+8,248).set(u)}return n.unmap(),{nOffsets:a,gpuBuffer:n,dynamicOffsets:r=new Uint32Array(r),dispatchSizes:s}}class Nr{constructor(e){this.device=e,this.bgLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.radixSortBGLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.mergeBGLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.numWorkGroupsBGLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.pushConstantsBGLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{hasDynamicOffset:!0,type:"uniform"}}]}),this.sortPipeline=this.device.createComputePipeline({layout:this.device.createPipelineLayout({bindGroupLayouts:[this.bgLayout,this.radixSortBGLayout,this.pushConstantsBGLayout]}),compute:{module:this.device.createShaderModule({code:`struct PushConstants {

	work_group_offset : u32,
  
  }
  
  
  
  struct BufferInfo {
  
	size : u32,
  
  }
  
  
  
  alias RTArr = array<u32>;
  
  
  
  alias RTArr_1 = array<u32>;
  
  
  
  struct Keys {
  
	keys : RTArr_1,
  
  }
  
  
  
  struct Values {
  
	values : RTArr_1,
  
  }
  
  
  
  @group(2) @binding(0) var<uniform> x_11 : PushConstants;
  
  
  
  var<private> gl_GlobalInvocationID : vec3<u32>;
  
  
  
  @group(0) @binding(0) var<uniform> x_30 : BufferInfo;
  
  
  
  var<workgroup> key_buf : array<u32, 64u>;
  
  
  
  var<private> gl_LocalInvocationID : vec3<u32>;
  
  
  
  @group(1) @binding(0) var<storage, read_write> x_46 : Keys;
  
  
  
  var<workgroup> val_buf : array<u32, 64u>;
  
  
  
  @group(1) @binding(1) var<storage, read_write> x_58 : Values;
  
  
  
  var<workgroup> scratch : array<u32, 64u>;
  
  
  
  var<workgroup> total_false : u32;
  
  
  
  var<workgroup> sorted_key_buf : array<u32, 64u>;
  
  
  
  var<workgroup> sorted_val_buf : array<u32, 64u>;
  
  
  
  fn main_1() {
  
	var item_idx : u32;
  
	var i : u32;
  
	var mask : u32;
  
	var offs : u32;
  
	var d : i32;
  
	var a : u32;
  
	var b : u32;
  
	var d_1 : i32;
  
	var a_1 : u32;
  
	var b_1 : u32;
  
	var tmp : u32;
  
	var f : u32;
  
	var t : u32;
  
	let x_16 : u32 = x_11.work_group_offset;
  
	let x_25 : u32 = gl_GlobalInvocationID.x;
  
	item_idx = ((x_16 * 64u) + x_25);
  
	let x_27 : u32 = item_idx;
  
	let x_32 : u32 = x_30.size;
  
	if ((x_27 < x_32)) {
  
	  let x_42 : u32 = gl_LocalInvocationID.x;
  
	  let x_47 : u32 = item_idx;
  
	  let x_49 : u32 = x_46.keys[x_47];
  
	  key_buf[x_42] = x_49;
  
	  let x_54 : u32 = gl_LocalInvocationID.x;
  
	  let x_59 : u32 = item_idx;
  
	  let x_61 : u32 = x_58.values[x_59];
  
	  val_buf[x_54] = x_61;
  
	} else {
  
	  let x_65 : u32 = gl_LocalInvocationID.x;
  
	  key_buf[x_65] = 4294967295u;
  
	  let x_69 : u32 = gl_LocalInvocationID.x;
  
	  val_buf[x_69] = 4294967295u;
  
	}
  
	i = 0u;
  
	loop {
  
	  let x_77 : u32 = i;
  
	  if ((x_77 < 32u)) {
  
	  } else {
  
		break;
  
	  }
  
	  workgroupBarrier();
  
	  let x_84 : u32 = i;
  
	  mask = bitcast<u32>((1i << x_84));
  
	  let x_89 : u32 = gl_LocalInvocationID.x;
  
	  let x_91 : u32 = gl_LocalInvocationID.x;
  
	  let x_93 : u32 = key_buf[x_91];
  
	  let x_94 : u32 = mask;
  
	  scratch[x_89] = bitcast<u32>(select(1i, 0i, ((x_93 & x_94) != 0u)));
  
	  offs = 1u;
  
	  d = 32i;
  
	  loop {
  
		let x_110 : i32 = d;
  
		if ((x_110 > 0i)) {
  
		} else {
  
		  break;
  
		}
  
		workgroupBarrier();
  
		let x_113 : u32 = gl_LocalInvocationID.x;
  
		let x_114 : i32 = d;
  
		if ((x_113 < bitcast<u32>(x_114))) {
  
		  let x_120 : u32 = offs;
  
		  let x_122 : u32 = gl_LocalInvocationID.x;
  
		  a = ((x_120 * ((2u * x_122) + 1u)) - 1u);
  
		  let x_128 : u32 = offs;
  
		  let x_130 : u32 = gl_LocalInvocationID.x;
  
		  b = ((x_128 * ((2u * x_130) + 2u)) - 1u);
  
		  let x_135 : u32 = b;
  
		  let x_136 : u32 = a;
  
		  let x_138 : u32 = scratch[x_136];
  
		  let x_140 : u32 = scratch[x_135];
  
		  scratch[x_135] = (x_140 + x_138);
  
		}
  
		let x_143 : u32 = offs;
  
		offs = (x_143 << bitcast<u32>(1i));
  
  
  
		continuing {
  
		  let x_145 : i32 = d;
  
		  d = (x_145 >> bitcast<u32>(1i));
  
		}
  
	  }
  
	  let x_148 : u32 = gl_LocalInvocationID.x;
  
	  if ((x_148 == 0u)) {
  
		let x_155 : u32 = scratch[63i];
  
		total_false = x_155;
  
		scratch[63i] = 0u;
  
	  }
  
	  d_1 = 1i;
  
	  loop {
  
		let x_163 : i32 = d_1;
  
		if ((x_163 < 64i)) {
  
		} else {
  
		  break;
  
		}
  
		let x_166 : u32 = offs;
  
		offs = (x_166 >> bitcast<u32>(1i));
  
		workgroupBarrier();
  
		let x_169 : u32 = gl_LocalInvocationID.x;
  
		let x_170 : i32 = d_1;
  
		if ((x_169 < bitcast<u32>(x_170))) {
  
		  let x_176 : u32 = offs;
  
		  let x_178 : u32 = gl_LocalInvocationID.x;
  
		  a_1 = ((x_176 * ((2u * x_178) + 1u)) - 1u);
  
		  let x_184 : u32 = offs;
  
		  let x_186 : u32 = gl_LocalInvocationID.x;
  
		  b_1 = ((x_184 * ((2u * x_186) + 2u)) - 1u);
  
		  let x_192 : u32 = a_1;
  
		  let x_194 : u32 = scratch[x_192];
  
		  tmp = x_194;
  
		  let x_195 : u32 = a_1;
  
		  let x_196 : u32 = b_1;
  
		  let x_198 : u32 = scratch[x_196];
  
		  scratch[x_195] = x_198;
  
		  let x_200 : u32 = b_1;
  
		  let x_201 : u32 = tmp;
  
		  let x_203 : u32 = scratch[x_200];
  
		  scratch[x_200] = (x_203 + x_201);
  
		}
  
  
  
		continuing {
  
		  let x_206 : i32 = d_1;
  
		  d_1 = (x_206 << bitcast<u32>(1i));
  
		}
  
	  }
  
	  workgroupBarrier();
  
	  let x_210 : u32 = gl_LocalInvocationID.x;
  
	  let x_212 : u32 = scratch[x_210];
  
	  f = x_212;
  
	  let x_215 : u32 = gl_LocalInvocationID.x;
  
	  let x_216 : u32 = f;
  
	  let x_218 : u32 = total_false;
  
	  t = ((x_215 - x_216) + x_218);
  
	  let x_221 : u32 = gl_LocalInvocationID.x;
  
	  let x_223 : u32 = key_buf[x_221];
  
	  let x_224 : u32 = mask;
  
	  if (((x_223 & x_224) != 0u)) {
  
		let x_230 : u32 = t;
  
		let x_232 : u32 = gl_LocalInvocationID.x;
  
		let x_234 : u32 = key_buf[x_232];
  
		sorted_key_buf[x_230] = x_234;
  
		let x_237 : u32 = t;
  
		let x_239 : u32 = gl_LocalInvocationID.x;
  
		let x_241 : u32 = val_buf[x_239];
  
		sorted_val_buf[x_237] = x_241;
  
	  } else {
  
		let x_244 : u32 = f;
  
		let x_246 : u32 = gl_LocalInvocationID.x;
  
		let x_248 : u32 = key_buf[x_246];
  
		sorted_key_buf[x_244] = x_248;
  
		let x_250 : u32 = f;
  
		let x_252 : u32 = gl_LocalInvocationID.x;
  
		let x_254 : u32 = val_buf[x_252];
  
		sorted_val_buf[x_250] = x_254;
  
	  }
  
	  workgroupBarrier();
  
	  let x_257 : u32 = gl_LocalInvocationID.x;
  
	  let x_259 : u32 = gl_LocalInvocationID.x;
  
	  let x_261 : u32 = sorted_key_buf[x_259];
  
	  key_buf[x_257] = x_261;
  
	  let x_264 : u32 = gl_LocalInvocationID.x;
  
	  let x_266 : u32 = gl_LocalInvocationID.x;
  
	  let x_268 : u32 = sorted_val_buf[x_266];
  
	  val_buf[x_264] = x_268;
  
  
  
	  continuing {
  
		let x_270 : u32 = i;
  
		i = (x_270 + bitcast<u32>(1i));
  
	  }
  
	}
  
	workgroupBarrier();
  
	let x_272 : u32 = item_idx;
  
	let x_274 : u32 = gl_LocalInvocationID.x;
  
	let x_276 : u32 = key_buf[x_274];
  
	x_46.keys[x_272] = x_276;
  
	let x_278 : u32 = item_idx;
  
	let x_280 : u32 = gl_LocalInvocationID.x;
  
	let x_282 : u32 = val_buf[x_280];
  
	x_58.values[x_278] = x_282;
  
	return;
  
  }
  
  
  
  @compute @workgroup_size(64i, 1i, 1i)
  
  fn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>, @builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>) {
  
	gl_GlobalInvocationID = gl_GlobalInvocationID_param;
  
	gl_LocalInvocationID = gl_LocalInvocationID_param;
  
	main_1();
  
  }
  
  `}),entryPoint:"main"}}),this.mergePipeline=this.device.createComputePipeline({layout:this.device.createPipelineLayout({bindGroupLayouts:[this.bgLayout,this.mergeBGLayout,this.numWorkGroupsBGLayout,this.pushConstantsBGLayout]}),compute:{module:this.device.createShaderModule({code:`alias RTArr = array<u32>;
  
  
  
  alias RTArr_1 = array<u32>;
  
  
  
  struct InputKeys {
  
	input_keys : RTArr_1,
  
  }
  
  
  
  struct BufferInfo {
  
	size : u32,
  
  }
  
  
  
  struct NumWorkGroups {
  
	work_groups_x : u32,
  
  }
  
  
  
  struct PushConstants {
  
	work_group_offset : u32,
  
  }
  
  
  
  alias RTArr_2 = array<u32>;
  
  
  
  struct OutputKeys {
  
	output_keys : RTArr_1,
  
  }
  
  
  
  alias RTArr_3 = array<u32>;
  
  
  
  struct OutputValues {
  
	output_values : RTArr_1,
  
  }
  
  
  
  struct InputValues {
  
	input_values : RTArr_1,
  
  }
  
  
  
  @group(1) @binding(0) var<storage, read_write> x_75 : InputKeys;
  
  
  
  @group(0) @binding(0) var<uniform> x_132 : BufferInfo;
  
  
  
  @group(2) @binding(0) var<uniform> x_149 : NumWorkGroups;
  
  
  
  @group(3) @binding(0) var<uniform> x_159 : PushConstants;
  
  
  
  var<private> gl_WorkGroupID : vec3<u32>;
  
  
  
  var<private> gl_LocalInvocationID : vec3<u32>;
  
  
  
  @group(1) @binding(2) var<storage, read_write> x_237 : OutputKeys;
  
  
  
  @group(1) @binding(3) var<storage, read_write> x_246 : OutputValues;
  
  
  
  @group(1) @binding(1) var<storage, read_write> x_251 : InputValues;
  
  
  
  fn next_pow2_u1_(x : ptr<function, u32>) -> u32 {
  
	let x_23 : u32 = *(x);
  
	*(x) = (x_23 - 1u);
  
	let x_26 : u32 = *(x);
  
	let x_30 : u32 = *(x);
  
	*(x) = (x_30 | (x_26 >> bitcast<u32>(1i)));
  
	let x_32 : u32 = *(x);
  
	let x_35 : u32 = *(x);
  
	*(x) = (x_35 | (x_32 >> bitcast<u32>(2i)));
  
	let x_37 : u32 = *(x);
  
	let x_40 : u32 = *(x);
  
	*(x) = (x_40 | (x_37 >> bitcast<u32>(4i)));
  
	let x_42 : u32 = *(x);
  
	let x_45 : u32 = *(x);
  
	*(x) = (x_45 | (x_42 >> bitcast<u32>(8i)));
  
	let x_47 : u32 = *(x);
  
	let x_50 : u32 = *(x);
  
	*(x) = (x_50 | (x_47 >> bitcast<u32>(16i)));
  
	let x_52 : u32 = *(x);
  
	return (x_52 + 1u);
  
  }
  
  
  
  fn upper_bound_u1_u1_u1_(start : ptr<function, u32>, count : ptr<function, u32>, element : ptr<function, u32>) -> u32 {
  
	var i : u32;
  
	loop {
  
	  let x_61 : u32 = *(count);
  
	  if ((x_61 > 0u)) {
  
	  } else {
  
		break;
  
	  }
  
	  let x_66 : u32 = *(start);
  
	  let x_67 : u32 = *(count);
  
	  i = (x_66 + (x_67 / 2u));
  
	  let x_71 : u32 = *(element);
  
	  let x_77 : u32 = i;
  
	  let x_80 : u32 = x_75.input_keys[x_77];
  
	  if ((x_71 >= x_80)) {
  
		let x_84 : u32 = i;
  
		*(start) = (x_84 + 1u);
  
		let x_86 : u32 = *(count);
  
		let x_89 : u32 = *(count);
  
		*(count) = (x_89 - ((x_86 / 2u) + 1u));
  
	  } else {
  
		let x_92 : u32 = *(count);
  
		*(count) = (x_92 / 2u);
  
	  }
  
	}
  
	let x_94 : u32 = *(start);
  
	return x_94;
  
  }
  
  
  
  fn lower_bound_u1_u1_u1_(start_1 : ptr<function, u32>, count_1 : ptr<function, u32>, element_1 : ptr<function, u32>) -> u32 {
  
	var i_1 : u32;
  
	loop {
  
	  let x_102 : u32 = *(count_1);
  
	  if ((x_102 > 0u)) {
  
	  } else {
  
		break;
  
	  }
  
	  let x_105 : u32 = *(start_1);
  
	  let x_106 : u32 = *(count_1);
  
	  i_1 = (x_105 + (x_106 / 2u));
  
	  let x_109 : u32 = i_1;
  
	  let x_111 : u32 = x_75.input_keys[x_109];
  
	  let x_112 : u32 = *(element_1);
  
	  if ((x_111 < x_112)) {
  
		let x_116 : u32 = i_1;
  
		*(start_1) = (x_116 + 1u);
  
		let x_118 : u32 = *(count_1);
  
		let x_121 : u32 = *(count_1);
  
		*(count_1) = (x_121 - ((x_118 / 2u) + 1u));
  
	  } else {
  
		let x_124 : u32 = *(count_1);
  
		*(count_1) = (x_124 / 2u);
  
	  }
  
	}
  
	let x_126 : u32 = *(start_1);
  
	return x_126;
  
  }
  
  
  
  fn main_1() {
  
	var aligned_size : u32;
  
	var param : u32;
  
	var merge_output_size : u32;
  
	var merge_chunk_size : u32;
  
	var offs : u32;
  
	var i_2 : u32;
  
	var a_in : u32;
  
	var b_in : u32;
  
	var base_idx : u32;
  
	var a_loc : u32;
  
	var param_1 : u32;
  
	var param_2 : u32;
  
	var param_3 : u32;
  
	var b_loc : u32;
  
	var param_4 : u32;
  
	var param_5 : u32;
  
	var param_6 : u32;
  
	let x_134 : u32 = x_132.size;
  
	param = u32(ceil((f32(x_134) / 64.0f)));
  
	let x_142 : u32 = next_pow2_u1_(&(param));
  
	aligned_size = (x_142 * 64u);
  
	let x_146 : u32 = aligned_size;
  
	let x_151 : u32 = x_149.work_groups_x;
  
	merge_output_size = (x_146 / x_151);
  
	let x_154 : u32 = merge_output_size;
  
	merge_chunk_size = (x_154 / 2u);
  
	let x_161 : u32 = x_159.work_group_offset;
  
	let x_167 : u32 = gl_WorkGroupID.x;
  
	let x_169 : u32 = merge_output_size;
  
	offs = ((x_161 + x_167) * x_169);
  
	i_2 = 0u;
  
	loop {
  
	  let x_177 : u32 = i_2;
  
	  let x_178 : u32 = merge_chunk_size;
  
	  if ((x_177 < (x_178 / 64u))) {
  
	  } else {
  
		break;
  
	  }
  
	  let x_182 : u32 = offs;
  
	  let x_183 : u32 = i_2;
  
	  let x_188 : u32 = gl_LocalInvocationID.x;
  
	  a_in = ((x_182 + (x_183 * 64u)) + x_188);
  
	  let x_191 : u32 = offs;
  
	  let x_192 : u32 = merge_chunk_size;
  
	  let x_194 : u32 = i_2;
  
	  let x_198 : u32 = gl_LocalInvocationID.x;
  
	  b_in = (((x_191 + x_192) + (x_194 * 64u)) + x_198);
  
	  let x_202 : u32 = gl_LocalInvocationID.x;
  
	  let x_203 : u32 = i_2;
  
	  base_idx = (x_202 + (x_203 * 64u));
  
	  let x_207 : u32 = base_idx;
  
	  let x_208 : u32 = offs;
  
	  let x_209 : u32 = merge_chunk_size;
  
	  let x_211 : u32 = a_in;
  
	  param_1 = (x_208 + x_209);
  
	  let x_214 : u32 = merge_chunk_size;
  
	  param_2 = x_214;
  
	  let x_217 : u32 = x_75.input_keys[x_211];
  
	  param_3 = x_217;
  
	  let x_218 : u32 = upper_bound_u1_u1_u1_(&(param_1), &(param_2), &(param_3));
  
	  let x_220 : u32 = merge_chunk_size;
  
	  a_loc = ((x_207 + x_218) - x_220);
  
	  let x_223 : u32 = base_idx;
  
	  let x_224 : u32 = b_in;
  
	  let x_226 : u32 = offs;
  
	  param_4 = x_226;
  
	  let x_228 : u32 = merge_chunk_size;
  
	  param_5 = x_228;
  
	  let x_231 : u32 = x_75.input_keys[x_224];
  
	  param_6 = x_231;
  
	  let x_232 : u32 = lower_bound_u1_u1_u1_(&(param_4), &(param_5), &(param_6));
  
	  b_loc = (x_223 + x_232);
  
	  let x_238 : u32 = a_loc;
  
	  let x_239 : u32 = a_in;
  
	  let x_241 : u32 = x_75.input_keys[x_239];
  
	  x_237.output_keys[x_238] = x_241;
  
	  let x_247 : u32 = a_loc;
  
	  let x_252 : u32 = a_in;
  
	  let x_254 : u32 = x_251.input_values[x_252];
  
	  x_246.output_values[x_247] = x_254;
  
	  let x_256 : u32 = b_loc;
  
	  let x_257 : u32 = b_in;
  
	  let x_259 : u32 = x_75.input_keys[x_257];
  
	  x_237.output_keys[x_256] = x_259;
  
	  let x_261 : u32 = b_loc;
  
	  let x_262 : u32 = b_in;
  
	  let x_264 : u32 = x_251.input_values[x_262];
  
	  x_246.output_values[x_261] = x_264;
  
  
  
	  continuing {
  
		let x_266 : u32 = i_2;
  
		i_2 = (x_266 + bitcast<u32>(1i));
  
	  }
  
	}
  
	return;
  
  }
  
  
  
  @compute @workgroup_size(64i, 1i, 1i)
  
  fn main(@builtin(workgroup_id) gl_WorkGroupID_param : vec3<u32>, @builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>) {
  
	gl_WorkGroupID = gl_WorkGroupID_param;
  
	gl_LocalInvocationID = gl_LocalInvocationID_param;
  
	main_1();
  
  }
  
  `}),entryPoint:"main"}})}getAlignedSize(e){return 64*yt(Math.ceil(e/64))}async sort(e,t,r){var s=yt(Math.ceil(r/64)),a=64*s,n=Math.log2(s),u={keys:e,values:t},o={keys:this.device.createBuffer({size:4*a,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),values:this.device.createBuffer({size:4*a,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST})},l=this.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint32Array(l.getMappedRange()).set([r]),l.unmap();for(var c=this.device.createBuffer({size:256*Math.max(n,1),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),d=new Uint32Array(c.getMappedRange()),h=0;h<n;++h)d[64*h]=s/(2<<h);c.unmap();var f=this.device.createBindGroup({layout:this.bgLayout,entries:[{binding:0,resource:{buffer:l}}]}),m=this.device.createBindGroup({layout:this.radixSortBGLayout,entries:[{binding:0,resource:{buffer:u.keys}},{binding:1,resource:{buffer:u.values}}]}),x=[this.device.createBindGroup({layout:this.mergeBGLayout,entries:[{binding:0,resource:{buffer:u.keys}},{binding:1,resource:{buffer:u.values}},{binding:2,resource:{buffer:o.keys}},{binding:3,resource:{buffer:o.values}}]}),this.device.createBindGroup({layout:this.mergeBGLayout,entries:[{binding:0,resource:{buffer:o.keys}},{binding:1,resource:{buffer:o.values}},{binding:2,resource:{buffer:u.keys}},{binding:3,resource:{buffer:u.values}}]})],g=(S=this.device.createCommandEncoder()).beginComputePass(),p=St(this.device,s),v=this.device.createBindGroup({layout:this.pushConstantsBGLayout,entries:[{binding:0,resource:{buffer:p.gpuBuffer,size:4}}]});for(g.setPipeline(this.sortPipeline),g.setBindGroup(0,f),g.setBindGroup(1,m),h=0;h<p.nOffsets;++h)g.setBindGroup(2,v,p.dynamicOffsets,h,1),g.dispatchWorkgroups(p.dispatchSizes[h],1,1);for(g.end(),(g=S.beginComputePass()).setPipeline(this.mergePipeline),g.setBindGroup(0,f),h=0;h<n;++h){var b=this.device.createBindGroup({layout:this.numWorkGroupsBGLayout,entries:[{binding:0,resource:{buffer:c,size:4,offset:256*h}}]});p=St(this.device,s/(2<<h)),v=this.device.createBindGroup({layout:this.pushConstantsBGLayout,entries:[{binding:0,resource:{buffer:p.gpuBuffer,size:4}}]}),g.setBindGroup(1,x[h%2]),g.setBindGroup(2,b);for(var L=0;L<p.nOffsets;++L)g.setBindGroup(3,v,p.dynamicOffsets,L,1),g.dispatchWorkgroups(p.dispatchSizes[L],1,1)}g.end(),this.device.queue.submit([S.finish()]);var S=this.device.createCommandEncoder();n%2==0||(S.copyBufferToBuffer(o.values,0,u.values,0,4*r),S.copyBufferToBuffer(o.keys,0,u.keys,0,4*r)),this.device.queue.submit([S.finish()]),await this.device.queue.onSubmittedWorkDone(),o.keys.destroy(),o.values.destroy(),l.destroy(),c.destroy()}}var Ar=()=>"struct SceneAABB{min : vec3<f32>,range : vec3<f32>,triangleCount : u32}@group(0)@binding(0)var<storage,read>position : array<array<f32,3>>;@group(0)@binding(1)var<storage,read>indices : array<array<u32,3>>;@group(0)@binding(2)var<uniform>sceneAABB : SceneAABB;@group(0)@binding(3)var<storage,read_write>mortonBuffer : array<u32>;@group(0)@binding(4)var<storage,read_write>idsBuffer : array<u32>;fn LGL_BS(vIn : u32)->u32{var v=vIn;v=(v*0x00010001u)&0xFF0000FFu;v=(v*0x00000101u)&0x0F00F00Fu;v=(v*0x00000011u)&0xC30C30C3u;v=(v*0x00000005u)&0x49249249u;return v;}fn LGL_BT(xIn : f32,yIn : f32,zIn : f32)->u32{let x=clamp(xIn*1024.,0.,1023.);let y=clamp(yIn*1024.,0.,1023.);let z=clamp(zIn*1024.,0.,1023.);let xx=LGL_BS(u32(x));let yy=LGL_BS(u32(y));let zz=LGL_BS(u32(z));return xx*4+yy*2+zz;}fn LGL_Ad(triIndex : u32)->vec3<u32>{return vec3<u32>(indices[triIndex][0],indices[triIndex][1],indices[triIndex][2]);}fn LGL_Ae(indice : u32)->vec3<f32>{return vec3<f32>(position[indice][0],position[indice][1],position[indice][2]);}@compute @workgroup_size(128,1,1)fn main(@builtin(global_invocation_id)GID : vec3<u32>){if(GID.x>=sceneAABB.triangleCount){return;}let triID=GID.x;let triIndices=LGL_Ad(triID);let pos=(1./3.)*(LGL_Ae(triIndices.x)+LGL_Ae(triIndices.y)+LGL_Ae(triIndices.z));var x=(pos.x-sceneAABB.min.x)/sceneAABB.range.x;var y=(pos.y-sceneAABB.min.y)/sceneAABB.range.y;var z=(pos.z-sceneAABB.min.z)/sceneAABB.range.z;x=clamp(x,0.,1.);y=clamp(y,0.,1.);z=clamp(z,0.,1.);mortonBuffer[triID]=LGL_BT(x,y,z);idsBuffer[triID]=triID;}";class Vr{constructor(e){this.device=e}async compute(e,t,r,s,a,n){const{device:u}=this,o=u.createCommandEncoder(),l=await u.createComputePipelineAsync({layout:"auto",compute:{module:u.createShaderModule({code:Ar()}),entryPoint:"main"}}),c=u.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:s}},{binding:3,resource:{buffer:a}},{binding:4,resource:{buffer:n}}]}),d=o.beginComputePass();d.setPipeline(l),d.setBindGroup(0,c),d.dispatchWorkgroups(Math.ceil(e/128)),d.end(),u.queue.submit([o.finish()]),await u.queue.onSubmittedWorkDone()}}var Ur=i=>`struct BVHNode{childA: u32,childB: u32,parent: u32,triIndicesID: u32,aabbMin : vec3<f32>,materialID: u32,aabbMax : vec3<f32>,visited: atomic<u32>,}@group(0)@binding(0)var<storage,read>idsBuffer : array<u32>;@group(0)@binding(1)var<storage,read>position : array<array<f32,3>>;@group(0)@binding(2)var<storage,read>indices : array<array<u32,3>>;@group(0)@binding(3)var<storage,read>materialMeshIndexBuffer : array<array<u32,2>>;@group(0)@binding(4)var<storage,read_write>bvhNodes : array<BVHNode>;fn LGL_Ad(triIndex : u32)->vec3<u32>{return vec3<u32>(indices[triIndex][0],indices[triIndex][1],indices[triIndex][2]);}fn LGL_Ae(indice : u32)->vec3<f32>{return vec3<f32>(position[indice][0],position[indice][1],position[indice][2]);}fn LGL_BO(indice : u32)->u32{return materialMeshIndexBuffer[indice][0];}fn LGL_BP(indice : u32)->u32{return materialMeshIndexBuffer[indice][1];}@compute @workgroup_size(128,1,1)fn main(@builtin(global_invocation_id)GID : vec3<u32>){if(GID.x>=${i}){return;}let leafID=${i-1}+GID.x;bvhNodes[leafID].triIndicesID=idsBuffer[GID.x];let triIndices=LGL_Ad(idsBuffer[GID.x]);bvhNodes[leafID].materialID=LGL_BO(triIndices.x);bvhNodes[leafID].childA=LGL_BP(triIndices.x);let posU=LGL_Ae(triIndices.x);let posV=LGL_Ae(triIndices.y);let posW=LGL_Ae(triIndices.z);bvhNodes[leafID].aabbMin=min(posU,min(posV,posW));bvhNodes[leafID].aabbMax=max(posU,max(posV,posW));let internalID=GID.x;if(internalID>=${i-1}){return;}bvhNodes[internalID].parent=0xFFFFFFFF;bvhNodes[internalID].triIndicesID=0xFFFFFFFF;}`;class kr{constructor(e){this.device=e}async compute(e,t,r,s,a,n){const{device:u}=this,o=u.createCommandEncoder(),l=await u.createComputePipelineAsync({layout:"auto",compute:{module:u.createShaderModule({code:Ur(e)}),entryPoint:"main"}}),c=u.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:s}},{binding:3,resource:{buffer:a}},{binding:4,resource:{buffer:n}}]}),d=o.beginComputePass();d.setPipeline(l),d.setBindGroup(0,c),d.dispatchWorkgroups(Math.ceil(e/128)),d.end(),u.queue.submit([o.finish()]),await u.queue.onSubmittedWorkDone()}}var Er=i=>`struct BVHNode{childA: u32,childB: u32,parent: u32,triIndicesID: u32,aabbMin : vec3<f32>,materialID: u32,aabbMax : vec3<f32>,visited: atomic<u32>,}@group(0)@binding(0)var<storage,read>mortonBuffer : array<u32>;@group(0)@binding(1)var<storage,read_write>bvhNodes : array<BVHNode>;fn delta(a : i32,b : i32,n : u32,ka : u32)->i32{if(b<0||b>i32(n-1)){return-1;}let kb=mortonBuffer[b];if(ka==kb){return i32(32+countLeadingZeros(u32(a)^ u32(b)));}return i32(countLeadingZeros(ka ^ kb));}fn LGL_BQ(n : u32,i : i32)->vec2<i32>{let ki=mortonBuffer[i];let deltaL=delta(i,i-1,n,ki);let deltaR=delta(i,i+1,n,ki);var d : i32;var deltaMin : i32;if(deltaR<deltaL){d=-1;deltaMin=deltaR;}else{d=1;deltaMin=deltaL;}var lMax : i32=2;while(delta(i,i+lMax*d,n,ki)>deltaMin){lMax<<=1;}var l : i32=0;for(var t : i32=lMax>>1;t>0;t>>=1){if(delta(i,i+(l+t)*d,n,ki)>deltaMin){l+=t;}}let j=i+l*d;return select(vec2<i32>(j,i),vec2<i32>(i,j),i<j);}fn LGL_BR(first : i32,last : i32,n : u32)->i32{let firstCode=mortonBuffer[first];let commonPrefix=delta(first,last,n,firstCode);var split=first;var searchStep=last-first;while(searchStep>1){searchStep=(searchStep+1)>>1;let newSplit=split+searchStep;if(newSplit<last){let splitPrefix=delta(first,newSplit,n,firstCode);if(splitPrefix>commonPrefix){split=newSplit;}}};return split;}@compute @workgroup_size(128,1,1)fn main(@builtin(global_invocation_id)GID : vec3<u32>){if(GID.x>=${i-1}){return;}let nodeID=GID.x;let range=LGL_BQ(${i},i32(nodeID));let split=LGL_BR(range.x,range.y,${i});bvhNodes[nodeID].childA=u32(split);bvhNodes[nodeID].childB=u32(split+1);if(range.x==split){bvhNodes[nodeID].childA+=${i-1};}if(range.y==split+1){bvhNodes[nodeID].childB+=${i-1};}bvhNodes[bvhNodes[nodeID].childA].parent=nodeID;bvhNodes[bvhNodes[nodeID].childB].parent=nodeID;}`;class Kr{constructor(e){this.device=e}async compute(e,t,r,s){const{device:a}=this,n=a.createCommandEncoder(),u=await a.createComputePipelineAsync({layout:"auto",compute:{module:a.createShaderModule({code:Er(e)}),entryPoint:"main"}}),o=a.createBindGroup({layout:u.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:s}}]}),l=n.beginComputePass();l.setPipeline(u),l.setBindGroup(0,o),l.dispatchWorkgroups(Math.ceil(e/128)),l.end(),a.queue.submit([n.finish()]),await a.queue.onSubmittedWorkDone()}}var Hr=(i,e)=>`struct BVHNode{childA: u32,childB: u32,parent: u32,triIndicesID: u32,aabbMin : vec3<f32>,materialID: u32,aabbMax : vec3<f32>,visited: atomic<u32>,}@group(0)@binding(0)var<storage,read_write>bvhNodes : array<BVHNode>;@compute @workgroup_size(128,1,1)fn main(@builtin(global_invocation_id)GID : vec3<u32>){if(GID.x>=${e}){return;}let leafID=${e-1}+GID.x;var curNodeID=bvhNodes[leafID].parent;var depth=1u;while(curNodeID!=0xFFFFFFFF){if(depth<${i}){curNodeID=bvhNodes[curNodeID].parent;depth++;continue;}else if(depth>${i}){break;}depth++;let visited=atomicAdd(&bvhNodes[curNodeID].visited,1);if(visited==0){break;}let childAID=bvhNodes[curNodeID].childA;let childBID=bvhNodes[curNodeID].childB;bvhNodes[curNodeID].aabbMin=min(bvhNodes[childAID].aabbMin,bvhNodes[childBID].aabbMin);bvhNodes[curNodeID].aabbMax=max(bvhNodes[childAID].aabbMax,bvhNodes[childBID].aabbMax);curNodeID=bvhNodes[curNodeID].parent;}}`;class Zr{constructor(e){this.device=e}async compute(e,t,r){const{device:s}=this,a=s.createCommandEncoder(),n=await s.createComputePipelineAsync({layout:"auto",compute:{module:s.createShaderModule({code:Hr(e,t)}),entryPoint:"main"}}),u=s.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r}}]}),o=a.beginComputePass();o.setPipeline(n),o.setBindGroup(0,u),o.dispatchWorkgroups(Math.ceil(t/128)),o.end(),s.queue.submit([a.finish()]),await s.queue.onSubmittedWorkDone()}}var Or=()=>"@group(0)@binding(0)var outputTex : texture_storage_2d<rgba32float,write>;@compute @workgroup_size(8,8,1)fn main(@builtin(global_invocation_id)GlobalInvocationID : vec3<u32>){let screenSize=textureDimensions(outputTex);if(any(GlobalInvocationID.xy>screenSize)){return;}let screenPos=vec2<i32>(i32(GlobalInvocationID.x),i32(GlobalInvocationID.y));let clearColor=vec4<f32>(0.);textureStore(outputTex,screenPos,clearColor);}";const Ue=class{constructor(i,e,t){this.device=i,this.context=e,this.rg=t}async createPipeline(){const{rg:i}=this;await i.getOrCreateComputePipeline(Ue.ID,"",Or())}clear(i,e){const{rg:t,device:r,context:s}=this,a=t.getComputePipeline(Ue.ID,""),n=r.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:e.createView()}]}),u=i.beginComputePass();u.setPipeline(a),u.setBindGroup(0,n),u.dispatchWorkgroups(Math.ceil(s.width/8),Math.ceil(s.height/8)),u.end()}};let Ot=Ue;Ot.ID="ClearTexPass";var Yr=(i,e)=>i`@group(0)@binding(0)var inputTex : texture_2d<f32>;@group(0)@binding(1)var<uniform>setting : Setting;@group(0)@binding(2)var screenSampler : sampler;struct Setting{toneMapping : u32,downsamplingFactor : u32,}struct VertexOutput{@builtin(position)position : vec4<f32>,@location(0)uv : vec2<f32>};fn LGL_Ao(color : vec3<f32>)->vec3<f32>{return clamp((color*(2.51*color+0.03))/(color*(2.43*color+0.59)+0.14),vec3<f32>(0.0),vec3<f32>(1.0));}fn LGL_S(linear : vec3<f32>)->vec3<f32>{return clamp(pow(linear,vec3<f32>(1.0/2.2)),vec3f(0.),vec3f(1.));}@fragment fn main(vo : VertexOutput)->@location(0)vec4<f32>{var scaleUV=vo.uv/f32(setting.downsamplingFactor);var accAndAlpha=textureSample(inputTex,screenSampler,scaleUV);var acc=accAndAlpha.rgb;if(setting.toneMapping==1){acc=LGL_Ao(acc);}acc=LGL_S(acc);
#if ${e.supportCanvasAlpha}
return vec4<f32>(acc*accAndAlpha.a,accAndAlpha.a);
#else
return vec4<f32>(acc,accAndAlpha.a);
#endif
}`;const qr=/#([^\s]*)(\s*)/gm;function z(i,...e){const t=[];let r={string:"",elseIsValid:!1,expression:!0},s=1;for(let a=0;a<i.length;++a){const n=i[a],u=n.matchAll(qr);let o=0,l=!1;for(const c of u){switch(r.string+=n.substring(o,c.index),c[1]){case"if":if(c.index+c[0].length!=n.length)throw new Error("#if must be immediately followed by a template expression (ie: ${value})");l=!0,t.push(r),s++,r={string:"",elseIsValid:!0,expression:!!e[a]};break;case"elif":if(c.index+c[0].length!=n.length)throw new Error("#elif must be immediately followed by a template expression (ie: ${value})");if(!r.elseIsValid)throw new Error("#elif not preceeded by an #if or #elif");l=!0,r.expression&&t.length!=s&&t.push(r),r={string:"",elseIsValid:!0,expression:!!e[a]};break;case"else":if(!r.elseIsValid)throw new Error("#else not preceeded by an #if or #elif");r.expression&&t.length!=s&&t.push(r),r={string:c[2],elseIsValid:!1,expression:!0};break;case"endif":if(!t.length)throw new Error("#endif not preceeded by an #if");const d=t.length==s?t.pop():r;r=t.pop(),s--,d.expression&&(r.string+=d.string),r.string+=c[2];break;default:r.string+=c[0]}o=c.index+c[0].length}o!=n.length&&(r.string+=n.substring(o,n.length)),!l&&e.length>a&&(r.string+=e[a])}if(t.length)throw new Error("Mismatched #if/#endif count");return r.string}const ke=class{constructor(i,e,t){this.device=i,this.context=e,this.rg=t,this.toneMappingVal=0,this.downsamplingFactor=1}async createPipeline(i){this.renderSetting=i,this.toneMappingVal=i.toneMapping;const{rg:e,device:t,context:r}=this;this.settingBuffer=new Je(e,"ScreenPassSettingBuffer","u32",2),this.settingBuffer.setData(0,this.toneMappingVal),this.settingBuffer.setData(1,this.downsamplingFactor),this.settingBuffer.submit(),i.renderToScreen||(this.outputTex=e.resourcePool.getOrCreateResource("ScreenPassOutputTexture",{size:{width:r.width,height:r.height},format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING}).raw);let s=e.getRenderPipeline(ke.ID);s||(s=await t.createRenderPipelineAsync({layout:"auto",vertex:{module:t.createShaderModule({code:Et()}),entryPoint:"main"},fragment:{module:t.createShaderModule({code:Yr(z,i)}),entryPoint:"main",targets:[{format:i.renderToScreen?"bgra8unorm":"rgba16float"}]},primitive:{topology:"triangle-list"}}),e.setRenderPipeline(ke.ID,"",s))}setSize(){const{rg:i,device:e,context:t,renderSetting:r}=this;r.renderToScreen||(this.outputTex=e.createTexture({size:{width:t.width,height:t.height},format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING}),i.resourcePool.updateResource("ScreenPassOutputTexture",this.outputTex,"Texture"))}setToneMapping(i){const{settingBuffer:e,toneMappingVal:t}=this;t!=i&&(this.toneMappingVal=i,e.setData(0,i),e.submit())}setDownsamplingFactor(i){const{settingBuffer:e,downsamplingFactor:t}=this;t!=i&&(this.downsamplingFactor=i,e.setData(1,i),e.submit())}setInputPass(i){this.inputPass=this.rg.getPass(i)}setup(i,e,t){const r={};r.input=e.read(this.inputPass.data.output),r.settingBuffer=e.read(i.importResource("ScreenPassSettingBuffer")),r.samplers=["llr"],t.data=r,e.hasSideEffect=!0}execute(i,e,t,r){const{context:s,renderSetting:a}=this,n=i.getRenderPipeline(e.name,""),u=i.getBindGroup(e.name,n,t,e.data);let o;o=a.renderToScreen?s.createCurrentTextureView():i.getRawResFromPool("ScreenPassOutputTexture").createView();const l=r.beginRenderPass({colorAttachments:[{view:o,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});l.setPipeline(n),l.setBindGroup(0,u),l.draw(6,1,0,0),l.end()}};let ge=ke;ge.ID="ScreenPass";class ne extends ie{static get desc(){return[{name:"cameraViewMatrix",type:"mat4x4<f32>"},{name:"cameraProjViewMatrix",type:"mat4x4<f32>"},{name:"renderSize",type:"vec2<u32>"}]}}ne.RES_NAME="GBufferUniformBuffer",ne.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class oe extends ie{static get desc(){return[{name:"localToWorldMat",type:"mat4x4<f32>"},{name:"normalMat",type:"mat3x3<f32>"},{name:"meshID",type:"u32"},{name:"matID",type:"u32"}]}}oe.RES_NAME="GBufferMeshUniformBuffer",oe.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class k extends ie{static get desc(){return[{name:"viewToWorldMat",type:"mat4x4<f32>"},{name:"clipToViewMat",type:"mat4x4<f32>"},{name:"sampleCount",type:"u32"},{name:"strataSize",type:"f32"},{name:"jitter",type:"vec2<f32>"},{name:"cameraAperture",type:"f32"},{name:"cameraFocus",type:"f32"}]}}k.RES_NAME="RTFrameUniformBuffer",k.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class E extends ie{static get desc(){return[{name:"envRotMatrix",type:"mat3x3<f32>"},{name:"invEnvRotMatrix",type:"mat3x3<f32>"},{name:"backgroundColor",type:"vec3<f32>"},{name:"envMapIntensity",type:"f32"},{name:"renderSize",type:"vec2<u32>"},{name:"bounces",type:"i32"},{name:"enableBackgroundColor",type:"u32"},{name:"backgroundAlpha",type:"f32"},{name:"totalSumValue",type:"f32"},{name:"lightNum",type:"u32"}]}}E.RES_NAME="RTSceneUniformBuffer",E.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class Q extends ie{static get desc(){return[{name:"tileOffset",type:"vec2<u32>"},{name:"tileSize",type:"vec2<u32>"},{name:"tileEnable",type:"u32"}]}}Q.RES_NAME="RTTileUniformBuffer",Q.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class J extends ie{static get desc(){return[{name:"sigColor",type:"f32"},{name:"sigNormal",type:"f32"},{name:"sigPosition",type:"f32"}]}}J.RES_NAME="AToursUniformBuffer",J.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;var Yt=(i,e)=>i`const EPS: f32=1.0e-4;const LGL_A: f32=1000000.0;const LGL_B: f32=3.14159265359;const TWO_LGL_B: f32=6.28318530718;const INV_LGL_B: f32=0.31830988618;const INV_LGL_B2: f32=0.10132118364;const LGL_F: f32=0.001;const LGL_G: f32=99999.0;const LGL_H: f32=1.2;const LGL_I: u32=4;
#if ${e.geoType=="Mesh"}
#if ${e.LGL_Ar=="Hybrid"}
const LGL_J: f32=0.0015;
#else
const LGL_J: f32=0.0001;
#endif
#endif
const LGL_L: i32=32;fn LGL_M(color : vec3<f32>)->f32{return dot(color,vec3<f32>(0.2125999927520752,0.7152000069618225,0.0722000002861023));}fn LGL_N(v : vec3<f32>)->f32{return max(max(v.x,v.y),v.z);}fn LGL_O(v : vec3<f32>)->f32{return((v.x+v.y+v.z)/3.0);}fn LGL_P(color : vec3<f32>)->bool{return length(color)==0.0;}fn LGL_Q(color : vec3<f32>)->bool{return((color.x*color.y*color.z)==0.0);}fn LGL_R(srgb : vec3<f32>)->vec3<f32>{return pow(srgb,vec3<f32>(2.2));}fn LGL_S(linear : vec3<f32>)->vec3<f32>{return pow(linear,vec3<f32>(0.454545));}`,Jr=(i,e)=>i`struct Ray{o: vec3<f32>,d: vec3<f32>};struct Path{ray: Ray,li: vec3<f32>,alpha: f32,beta: vec3<f32>,abort: bool,misWeight: f32,absorption: vec3<f32>,specularBounce: bool};struct LightSampleRec{normal: vec3<f32>,emission: vec3<f32>,direction: vec3<f32>,dist: f32,pdf: f32,};
#if ${e.sceneMode=="Static"}
struct BVHNode{childA: u32,childB: u32,parent: u32,triIndicesID: u32,aabbMin : vec3<f32>,materialID: u32,aabbMax : vec3<f32>,visited: u32,}
#else
struct TLASNode{idInfoOrAABBMin: vec3<f32>,typeFlag: f32,meshInfoOraabbMax: vec3<f32>,nextPtr: f32}struct BLASNode{indicesOrMin: vec3<f32>,typeFlag: f32,aabbMax: vec3<f32>,nextPtr: f32}struct TLASTransNode{LGL_sMat : mat4x4<f32>,LGL_rMat : mat4x4<f32>,}
#endif
struct SurfaceInteraction{hit: bool,isEmitter: bool,t: f32,matID: u32,position: vec3<f32>,normal: vec3<f32>,faceNormal: vec3<f32>,ffnormal: vec3<f32>,tangent: vec3<f32>,bitangent: vec3<f32>,eta: f32,materialType: i32,meshID: u32,roughness: f32};struct BSDFSampleRec{L: vec3<f32>,f: vec3<f32>,pdf: f32};struct Basis{T: vec3<f32>,B: vec3<f32>,N: vec3<f32>};fn LGL_o(coord : vec2<f32>)->vec3<f32>{let worldPos : vec4<f32>=frameUniform.viewToWorldMat*frameUniform.clipToViewMat*vec4<f32>(coord,-1.0,1.0);return worldPos.xyz/worldPos.w;}fn LGL_p(N : vec3<f32>)->Basis{var basis : Basis;basis.N=N;if(N.z<-0.999999){basis.T=vec3<f32>(0.,-1.,0.);basis.B=vec3<f32>(-1.,0.,0.);}else{let a=1.0/(1.+N.z);let b=-N.x*N.y*a;basis.T=vec3<f32>(1.0-N.x*N.x*a,b,-N.x);basis.B=vec3<f32>(b,1.-N.y*N.y*a,-N.y);}return basis;}fn LGL_q(r : Ray,bMin : vec3<f32>,bMax : vec3<f32>,invDir : vec3<f32>,tMax : f32)->bool{let tBot=(bMin-r.o)*invDir;let tTop=(bMax-r.o)*invDir;let tNear=min(tBot,tTop);let tFar=max(tBot,tTop);let t0=max(tNear.x,max(tNear.y,tNear.z));let t1=min(tFar.x,min(tFar.y,tFar.z));return max(0.,t0)<=min(tMax,t1);}fn LGL_r(world : vec3<f32>,basis : Basis)->vec3<f32>{return vec3<f32>(dot(world,basis.T),dot(world,basis.B),dot(world,basis.N));}fn LGL_s(local : vec3<f32>,basis : Basis)->vec3<f32>{return basis.T*local.x+basis.B*local.y+basis.N*local.z;}`,Qr=(i,e,t=!0)=>i`var<private>seed: u32;fn LGL_Z(frame : u32,vCoord : vec2<f32>,texSize : vec2<u32>){var pixel=vec2<u32>((vCoord*vec2<f32>(texSize)));seed=(pixel.x*1973u+pixel.y*9277u+frame*26699u)|1u;seed=hash();}fn hash()->u32{var state=seed;seed=seed*747796405u+2891336453u;var word=((state>>((state>>28u)+4u))^ state)*277803737u;return(word>>22u)^ word;}fn LGL_a(p: vec2f)->f32{return fract(sin(dot(p,vec2f(12.9898,78.233)))*43758.5453);}fn rand()->f32{return f32(hash())/4294967296.0;}fn rand2()->vec2<f32>{return vec2<f32>(rand(),rand());}fn LGL_b()->f32{var state=seed;seed=seed*747796405u+2891336453u;var p=f32(state)/4294967296.0;p=fract(p*.1031);p*=p+33.33;p*=p+p;return fract(p);}fn LGL_b2()->vec2<f32>{return vec2<f32>(LGL_b(),LGL_b());}
#if ${t}
var<private>sampleIndex: u32=0u;var<private>pixelSeed: f32;fn LGL_c(frame : u32,vCoord : vec2<f32>,texSize : vec2<u32>){var pixelSize=1./vec2<f32>(texSize);let noiseSize=vec2<f32>(textureDimensions(noiseTex));pixelSeed=textureSampleLevel(noiseTex,noiseSampler,vCoord/(pixelSize*noiseSize),0.).r;}fn LGL_cMix(frame : u32,vCoord : vec2<f32>,texSize : vec2<u32>){var pixelSize=1./vec2<f32>(texSize);var pixel=vec2<u32>((vCoord*vec2<f32>(texSize)));seed=(pixel.x*1973u+pixel.y*9277u+frame*26699u)|1u;let noiseSize=vec2<f32>(textureDimensions(noiseTex));pixelSeed=rand()*textureSampleLevel(noiseTex,noiseSampler,vCoord/(pixelSize*noiseSize),0.).r;}struct StratifiedSamplesUniforms{data: array<vec4<f32>,16>,}struct LGL_e{s1: vec2<f32>,s2: vec2<f32>,s3: vec2<f32>,s4: vec2<f32>,}fn LGL_f()->f32{let rowIndex=sampleIndex/4;let columnIndex=sampleIndex % 4;let stratifiedSample=stratifiedSamples.data[rowIndex][columnIndex];sampleIndex++;var random=fract((stratifiedSample+pixelSeed)*frameUniform.strataSize);return EPS+(1.0-2.0*EPS)*random;}fn LGL_fVec2()->vec2<f32>{return vec2<f32>(LGL_f(),LGL_f());}fn LGL_g()->LGL_e{var samples: LGL_e;samples.s1=LGL_fVec2();samples.s2=LGL_fVec2();samples.s3=LGL_fVec2();samples.s4=LGL_fVec2();return samples;}fn getOneTurnHashRandom()->LGL_e{var samples: LGL_e;samples.s1=rand2();samples.s2=rand2();samples.s3=rand2();samples.s4=rand2();return samples;}
#endif
`,jr=(i,e)=>i`fn LGL_h(p1 : vec2<f32>)->vec2<f32>{var p=2.0*p1-1.0;var greater=abs(p.x)>abs(p.y);var r=select(p.y,p.x,greater);var theta=select(LGL_B*(0.5-0.25*p.x/p.y),0.25*LGL_B*p.y/p.x,greater);return r*vec2<f32>(cos(theta),sin(theta));}fn LGL_i(r1 : f32,r2 : f32)->vec3<f32>{var dir : vec3<f32>;let r=sqrt(r1);let phi=TWO_LGL_B*r2;dir.x=r*cos(phi);dir.y=r*sin(phi);dir.z=sqrt(max(0.0,1.0-dir.x*dir.x-dir.y*dir.y));return dir;}fn LGL_iWithPDF(r1 : f32,r2 : f32,pdf : ptr<function,f32>)->vec3<f32>{var dir : vec3<f32>;let r=sqrt(r1);let phi=TWO_LGL_B*r2;dir.x=r*cos(phi);dir.y=r*sin(phi);dir.z=sqrt(max(0.0,1.0-dir.x*dir.x-dir.y*dir.y));*pdf=abs(dir.z)/LGL_B;return dir;}fn LGL_iPdf(wiL : vec3<f32>)->f32{if(wiL.z<0.0){return 0.0;}return wiL.z/LGL_B;}fn LGL_l(f : f32,g : f32)->f32{return(f*f)/(f*f+g*g);}fn LGL_m(mu: f32,anisotropy: f32)->f32{var g=anisotropy;var gSqr=g*g;return(1.0/(4.0*LGL_B))*(1.0-gSqr)/pow(1.0-2.0*g*mu+gSqr,1.5);}fn LGL_n(rayDir: vec3<f32>,anisotropy: f32,s1: vec2<f32>)->vec3<f32>{var g=anisotropy;var costheta: f32;if(abs(g)<1.0e-3){costheta=1.0-2.0*s1.x;}else{costheta=1.0/(2.0*g)*(1.0+g*g-((1.0-g*g)*(1.0-g+2.0*g*s1.x)));}var sintheta=sqrt(max(0.0,1.0-costheta*costheta));var phi=TWO_LGL_B*s1.y;var basis=LGL_p(rayDir);return costheta*rayDir+sintheta*(cos(phi)*basis.T+sin(phi)*basis.B);}fn EmitterSample(r: Ray,depth: i32,lightSampleRec: LightSampleRec,bsdfSampleRec: BSDFSampleRec)->vec3f{var Le=vec3f(0.);if(depth==0){Le=lightSampleRec.emission;}else{Le=LGL_l(bsdfSampleRec.pdf,lightSampleRec.pdf)*lightSampleRec.emission;}return Le;}`,$r=(i,e)=>i`fn LGL_T(pointOnSphere : vec3<f32>)->vec2<f32>{var phi=atan2(pointOnSphere.z,pointOnSphere.x)/TWO_LGL_B;var theta=acos(pointOnSphere.y);return vec2<f32>(phi+0.5,theta*INV_LGL_B);}fn LGL_U(uvIn : vec2<f32>)->vec3<f32>{var uv=uvIn;uv.x-=0.5;let theta=uv.x*2.0*LGL_B;let phi=uv.y*LGL_B;let sinPhi=sin(phi);return vec3<f32>(sinPhi*cos(theta),cos(phi),sinPhi*sin(theta));}fn LGL_V(d : vec3<f32>)->vec3<f32>{var uv=LGL_T(d);var irr=textureSampleLevel(envMap,texSampler,uv,0.).rgb;return irr;}fn LGL_W(dir : vec3<f32>)->f32{let uv=LGL_T(dir);let sinTheta=sin(uv.y*LGL_B);if(sinTheta==0.0){return 0.0;}return INV_LGL_B2/(2.0*sinTheta);}fn LGL_X(dir : vec3<f32>)->f32{let uv=LGL_T(dir);let color=textureSampleLevel(envMap,texSampler,uv,0.).rgb;let lum=LGL_M(color);let totalSum=sceneUniform.totalSumValue;let size=vec2<f32>(textureDimensions(envMap,0));return(size.x*size.y)*(lum/totalSum)*LGL_W(dir);}fn LGL_Y(random : vec2<f32>,uv : ptr<function,vec2<f32>>,pdf : ptr<function,f32>)->vec3<f32>{let size=vec2<f32>(textureDimensions(envMap,0));let sizeMarginalWeights=size.y;var v=textureLoad(envMarginalWeights,vec2<u32>(u32(random.x*sizeMarginalWeights),0),0).x;var u=textureLoad(envConditionalWeights,vec2<u32>(u32(random.y*size.x),u32(v*size.y)),0).x;*uv=vec2<f32>(u,v);let dir=LGL_U(*uv);let color=textureSampleLevel(envMap,texSampler,*uv,0.).rgb;let lum=LGL_M(color);let totalSum=sceneUniform.totalSumValue;*(pdf)=(size.x*size.y)*(lum/totalSum)*LGL_W(dir);return dir;}`,qt=(i,e)=>i`struct PrincipledBSDF{color: vec3<f32>,workflow: f32,roughness: f32,metalness: f32,transmission: f32,ior: f32,specularColor: vec3<f32>,glossiness: f32,sheen: f32,sheenTint: f32,clearcoat: f32,clearcoatRoughness: f32,extinction: vec3<f32>,atDistance: f32,subsurfaceMFP: f32,subsurfaceColor: vec3<f32>,subsurface: f32,specularTint: f32,alpha: f32,oriRoughness: f32,emissiveColor: vec3<f32>,}var<private>principledBSDFMaterial: PrincipledBSDF;struct Material{color: vec3<f32>,workflow: f32,roughness: f32,metalness: f32,transmission: f32,ior: f32,sheen: f32,sheenTint: f32,clearcoat: f32,clearcoatRoughness: f32,emissiveColor: vec3<f32>,alpha: f32,specularTint: f32,atDistance: f32,normalScale: vec2<f32>,subsurfaceColor: vec3<f32>,subsurface: f32,extinction: vec3<f32>,subsurfaceMFP: f32,specularColor: vec3<f32>,glossiness: f32,map: i32,normalMap: i32,roughnessMap: i32,metalnessMap: i32,emissiveMap: i32,specularMap: i32,glossinessMap: i32,materialType: i32,}
#if ${e.supportUVTrans||e.supportTexWrap}
const UV_TRANS_MAPS_LEN: i32=7;struct TexUVTrans{texUVTransMat : array<mat3x3<f32>,UV_TRANS_MAPS_LEN>,texWrapping: array<vec4<f32>,UV_TRANS_MAPS_LEN>,}
#endif
`,Jt=(i,e)=>i`
#if ${e.supportTexWrap}
fn applyTextureWrapping(uv: vec2f,wrapping: vec2f)->vec2f{var result: vec2f=uv;if(uv.x<=0.||uv.x>=1.){let warpS=i32(wrapping.x);if(warpS==1){result.x=select(0.0,1.0,uv.x<=0.0);}else if(warpS==2){result.x=1.0-abs(fract(uv.x*0.5)*2.0-1.0);}else{result.x=fract(uv.x);}}if(uv.y<=0.0||uv.y>=1.){let warpT=i32(wrapping.y);if(warpT==1){result.y=select(0.0,1.0,uv.y<=0.0);}else if(warpT==2){result.y=1.0-abs(fract(uv.y*0.5)*2.0-1.0);}else{result.y=fract(uv.y);}}return result;}
#endif
#if ${e.supportSGWorkflow}
fn LGL_AJ(v: vec3f)->f32{return max(v.x,max(v.y,v.z));}fn LGL_AK(specularColor : vec3f)->f32{return LGL_AJ(specularColor);}fn LGL_AL(baseColor : vec3f,metallic : f32)->vec3f{return baseColor*(1.0-metallic);}fn LGL_AM(matID: u32,uvIn: vec2<f32>)->vec3<f32>{var specularColor=materials[matID].specularColor;let texIndex=materials[matID].specularMap;if(texIndex>-1){var uv=uvIn;
#if ${e.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[4];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${e.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[4];uv=applyTextureWrapping(uv,warpping.xy);
#endif
specularColor*=LGL_R(textureSampleLevel(textureArray,texSampler,uv,texIndex,0).rgb);}return specularColor;}fn LGL_AN(matID: u32,uvIn: vec2<f32>)->f32{var glossiness=materials[matID].glossiness;let texIndex=materials[matID].glossinessMap;if(texIndex>-1){var uv=uvIn;
#if ${e.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[5];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${e.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[5];uv=applyTextureWrapping(uv,warpping.xy);
#endif
glossiness*=textureSampleLevel(textureArray,texSampler,uv,texIndex,0).a;}return glossiness;}
#endif
fn LGL_AO(matID: u32,uvIn: vec2<f32>)->vec4<f32>{var color=materials[matID].color;var alpha=materials[matID].alpha;var uv=uvIn;
#if ${e.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[0];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${e.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[0];uv=applyTextureWrapping(uv,warpping.xy);
#endif
let texIndex=materials[matID].map;if(texIndex>-1){let texData=textureSampleLevel(textureArray,texSampler,uv,texIndex,0);color*=LGL_R(texData.rgb);alpha*=texData.a;}
#if ${e.supportSGWorkflow}
let workflow=materials[matID].workflow;if(workflow>0.){let specularFactor=LGL_AM(matID,uv);color=LGL_AL(color,LGL_AK(specularFactor));}
#endif
return vec4f(color,alpha);}fn LGL_AP(matID : u32,uvIn : vec2<f32>)->f32{let workflow=materials[matID].workflow;var roughness=0.;
#if ${e.supportSGWorkflow}
if(workflow>0.){roughness=1.0-LGL_AN(matID,uvIn);}else
#endif
{roughness=materials[matID].roughness;let texIndex=materials[matID].roughnessMap;if(texIndex>-1){var uv=uvIn;
#if ${e.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[2];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${e.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[2];uv=applyTextureWrapping(uv,warpping.xy);
#endif
roughness*=textureSampleLevel(textureArray,texSampler,uv,texIndex,0).g;}}return roughness;}fn LGL_AQ(matID : u32,uvIn : vec2<f32>)->f32{let workflow=materials[matID].workflow;var metalness=0.;
#if ${e.supportSGWorkflow}
if(workflow>0.){let specularFactor=LGL_AM(matID,uvIn);metalness=LGL_AK(specularFactor);}else
#endif
{metalness=materials[matID].metalness;let texIndex=materials[matID].metalnessMap;if(texIndex>-1){var uv=uvIn;
#if ${e.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[3];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${e.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[3];uv=applyTextureWrapping(uv,warpping.xy);
#endif
metalness*=textureSampleLevel(textureArray,texSampler,uv,texIndex,0).b;}}return metalness;}fn LGL_AR(matID : u32,uvIn : vec2<f32>)->vec3<f32>{var emissiveColor=materials[matID].emissiveColor;let texIndex=materials[matID].emissiveMap;if(texIndex>-1){var uv=uvIn;
#if ${e.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[6];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${e.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[6];uv=applyTextureWrapping(uv,warpping.xy);
#endif
emissiveColor*=LGL_R(textureSampleLevel(textureArray,texSampler,uv,texIndex,0).rgb);}return emissiveColor;}fn LGL_AS(matID : u32,uvIn : vec2<f32>,normalIn : vec3<f32>,faceNormal : vec3<f32>,dp1 : vec3<f32>,dp2 : vec3<f32>,duv1 : vec2<f32>,duv2 : vec2<f32>)->vec3<f32>{var normal=normalIn;normal=normal*sign(dot(normal,faceNormal));let dp2perp=cross(dp2,normal);let dp1perp=cross(normal,dp1);var dpdu=dp2perp*duv1.x+dp1perp*duv2.x;var dpdv=dp2perp*duv1.y+dp1perp*duv2.y;let invmax=inverseSqrt(max(dot(dpdu,dpdu),dot(dpdv,dpdv)));dpdu*=invmax;dpdv*=invmax;let texIndex=materials[matID].normalMap;if(texIndex>-1){var uv=uvIn;
#if ${e.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[1];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${e.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[1];uv=applyTextureWrapping(uv,warpping.xy);
#endif
var n=2.*textureSampleLevel(textureArray,texSampler,uv,texIndex,0).rgb-1.;n.x*=materials[matID].normalScale.x;n.y*=materials[matID].normalScale.y;
#if ${e.LGL_Ar=="Hybrid"}
n.x*=-1.;n.y*=-1.;
#endif
var tbn=mat3x3(dpdu,dpdv,normal);return normalize(tbn*n);}return normal;}fn LGL_AT(matID : u32,uv : vec2<f32>)->PrincipledBSDF{var material : PrincipledBSDF;material.workflow=materials[matID].workflow;var colorAlpha=LGL_AO(matID,uv);material.color=colorAlpha.rgb;material.alpha=colorAlpha.a;material.oriRoughness=LGL_AP(matID,uv);material.roughness=clamp(material.oriRoughness*material.oriRoughness,LGL_F,1.0);material.metalness=LGL_AQ(matID,uv);material.emissiveColor=LGL_AR(matID,uv);material.transmission=materials[matID].transmission;material.ior=materials[matID].ior;
#if ${e.supportSGWorkflow}
material.specularColor=LGL_AM(matID,uv);material.glossiness=materials[matID].glossiness;
#endif
material.sheen=materials[matID].sheen;material.sheenTint=materials[matID].sheenTint;material.clearcoat=materials[matID].clearcoat;material.clearcoatRoughness=materials[matID].clearcoatRoughness;material.extinction=materials[matID].extinction;material.specularTint=materials[matID].specularTint;material.atDistance=materials[matID].atDistance;material.subsurfaceColor=materials[matID].subsurfaceColor;material.subsurface=materials[matID].subsurface;material.subsurfaceMFP=materials[matID].subsurfaceMFP;return material;}`,es=(i,e)=>i`fn LGL_t(eta : f32)->f32{let sqrtR0 : f32=((eta-1.0)/(eta+1.0));return(sqrtR0*sqrtR0);}fn LGL_u(u : f32)->f32{let m : f32=clamp((1.0-u),0.0,1.0);let m2=m*m;return m2*m2*m;}fn LGL_v(F0 : f32,cosTheta : f32)->f32{return mix(F0,1.0,LGL_u(cosTheta));}fn LGL_vVec3(F0 : vec3<f32>,cosTheta : f32)->vec3<f32>{return mix(F0,vec3<f32>(1.0),LGL_u(cosTheta));}fn LGL_x(cosThetaI1 : f32,eta1 : f32)->f32{var cosThetaI=cosThetaI1;var eta=eta1;cosThetaI=clamp(cosThetaI,-(1.0),1.0);let entering : bool=cosThetaI>0.0;if(!entering){eta=1.0/eta;cosThetaI=abs(cosThetaI);}let sinThetaTSq=eta*eta*(1.0-cosThetaI*cosThetaI);if(sinThetaTSq>1.0){return 1.0;}let cosThetaT=sqrt(max(1.0-sinThetaTSq,0.0));let rs=(eta*cosThetaT-cosThetaI)/(eta*cosThetaT+cosThetaI);let rp=(eta*cosThetaI-cosThetaT)/(eta*cosThetaI+cosThetaT);return 0.5*(rs*rs+rp*rp);}fn LGL_y(metalness : f32,eta : f32,cosThetaI : f32)->f32{let FrSchlick=LGL_u(cosThetaI);let FrDielectric=LGL_x(cosThetaI,eta);return mix(FrDielectric,FrSchlick,metalness);}fn LGL_z(NDotV : f32,alphaG : f32)->f32{let a=alphaG*alphaG;let b=NDotV*NDotV;return 1.0/(NDotV+sqrt(a+b-a*b));}fn LGL_AA(NDotH : f32,alpha : f32)->f32{let alpha2=alpha*alpha;let t=1.0+(alpha2-1.0)*NDotH*NDotH;return(alpha2-1.0)/(LGL_B*log(alpha2)*t);}fn LGL_AB(NDotH : f32,a : f32)->f32{let a2=a*a;let t=1.0+(a2-1.0)*NDotH*NDotH;return a2/(LGL_B*t*t);}fn ISLGL_AA(rgh : f32,r1 : f32,r2 : f32)->vec3<f32>{let a=max(0.001,rgh);let a2=a*a;let phi=r1*TWO_LGL_B;let cosTheta=sqrt((1.0-pow(a2,1.0-r1))/(1.0-a2));let sinTheta=clamp(sqrt(1.0-(cosTheta*cosTheta)),0.0,1.0);let sinPhi=sin(phi);let cosPhi=cos(phi);return vec3<f32>(sinTheta*cosPhi,sinTheta*sinPhi,cosTheta);}fn ISLGL_AB(rgh : f32,r1 : f32,r2 : f32)->vec3<f32>{let a=max(0.001,rgh);let phi=r1*TWO_LGL_B;let cosTheta=sqrt((1.0-r2)/(1.0+(a*a-1.0)*r2));let sinTheta=clamp(sqrt(1.0-(cosTheta*cosTheta)),0.0,1.0);let sinPhi=sin(phi);let cosPhi=cos(phi);return vec3<f32>(sinTheta*cosPhi,sinTheta*sinPhi,cosTheta);}`,ts=(i,e)=>i`
#if ${e.enableSSS}
const LGL_AE: u32=5;const LGL_AF: u32=2;fn LGL_AG(material: PrincipledBSDF,Cspec0: vec3<f32>)->f32{let diffuseWt=(1.0-material.subsurface)*max(LGL_M(material.color),material.sheen)*(1.0-material.metalness)*(1.0-material.transmission);let specularWt=LGL_M(Cspec0);let transWt=(1.0-material.subsurface)*(1.0-material.metalness)*material.transmission*LGL_M(material.color);let clearcoatWt=material.clearcoat*(1.0-material.metalness);let sssWt=material.subsurface*LGL_M(material.subsurfaceColor)*5.;let weightSum=diffuseWt+specularWt+transWt+clearcoatWt+sssWt;return clamp(sssWt/weightSum,0.,1.);}fn LGL_AH(si: SurfaceInteraction,material: PrincipledBSDF,basis: Basis,s1: vec2<f32>,s2: vec2<f32>,throughput : ptr<function,vec3<f32>>,siExit: ptr<function,SurfaceInteraction>,lightSampleRec : ptr<function,LightSampleRec>)->bool{let lengthScale=.5;let subsurfaceAnisotropy=0.;var walkPos=si.position-LGL_J*si.normal;var walkDirL=LGL_i(s1.x,s1.y);var walkDirW=-LGL_s(walkDirL,basis);*throughput=vec3<f32>(1.0);var sssRay : Ray;for(var n=0u;n<LGL_AE;n++){var walkDist=-log(rand())*material.subsurfaceMFP*lengthScale;sssRay.o=walkPos;sssRay.d=walkDirW;var siScatter : SurfaceInteraction;LGL_Ak(&siScatter,sssRay,lightSampleRec,1,walkDist);if(siScatter.hit){*siExit=siScatter;return true;}if(n>LGL_AF){let continuationProb=clamp(10.0*LGL_N(*throughput),0.0,1.0);let terminationProb=1.0-continuationProb;if(rand()<terminationProb){break;}*throughput/=continuationProb;}walkDirW=LGL_n(walkDirW,subsurfaceAnisotropy,s2);walkPos+=walkDist*walkDirW;*throughput=*throughput*material.subsurfaceColor;}return false;}fn LGL_AI(si: SurfaceInteraction,material: PrincipledBSDF,basis: Basis,s1: vec2<f32>,s2: vec2<f32>)->vec3<f32>{var surfacePos=si.position+LGL_J*basis.N;var Li=vec3<f32>(0.0);var bsdfSampleRec : BSDFSampleRec;var woutputL : vec3<f32>;var woutputW : vec3<f32>;var uv : vec2<f32>;var lightPdf : f32;bsdfSampleRec.f=material.color/LGL_B;woutputW=sceneUniform.invEnvRotMatrix*LGL_Y(s1,&uv,&lightPdf);woutputL=LGL_r(woutputW,basis);var ray=Ray(surfacePos,woutputW);if(!LGL_Al(ray,LGL_A)){var irr=textureSampleLevel(envMap,texSampler,uv,0.).rgb*sceneUniform.envMapIntensity;bsdfSampleRec.pdf=LGL_iPdf(woutputL);var misWeight=LGL_l(lightPdf,bsdfSampleRec.pdf);Li+=misWeight*bsdfSampleRec.f*irr*abs(woutputL.z)/lightPdf;}
#if ${e.supportLightSource}
var lightSampleRec: LightSampleRec;var i=i32(s2.x*f32(sceneUniform.lightNum));var lightData=lights.data[i];var light=Light(lightData.position,lightData.radius,lightData.emission,lightData.area,lightData.p1,lightData.lightType,lightData.p2,lightData.visible);sampleOneLight(light,surfacePos,&lightSampleRec,s2);if(dot(lightSampleRec.direction,lightSampleRec.normal)<0.0){var ray=Ray(surfacePos,lightSampleRec.direction);if(!LGL_Al(ray,lightSampleRec.dist-EPS)){woutputW=lightSampleRec.direction;woutputL=LGL_r(woutputW,basis);bsdfSampleRec.pdf=LGL_iPdf(woutputL);var misWeight=1.0;if(light.area>0.0&&bsdfSampleRec.pdf>0.0){misWeight=LGL_l(lightSampleRec.pdf,bsdfSampleRec.pdf);}if(misWeight>0.0){Li+=misWeight*bsdfSampleRec.f*lightSampleRec.emission*abs(woutputL.z)/lightSampleRec.pdf;}}}
#endif
return Li;}
#endif
`,rs=(i,e)=>i`fn LGL_AU(material : PrincipledBSDF,Csheen : vec3<f32>,V : vec3<f32>,L : vec3<f32>,H : vec3<f32>,pdf : ptr<function,f32>)->vec3<f32>{if((L.z<=0.0)){return vec3<f32>(0.0);}*pdf=L.z*INV_LGL_B;let LDotH=dot(L,H);let FL=LGL_u(L.z);let FV=LGL_u(V.z);let Fh=LGL_u(LDotH);let Fd90=0.5+2.0*LDotH*LDotH*material.roughness;let Fd=mix(1.0,Fd90,FL)*mix(1.0,Fd90,FV);
#if ${e.LGL_Ar=="PT"}
let Fsheen=Fh*material.sheen*Csheen;return(INV_LGL_B*Fd*material.color+Fsheen)*(1.0-material.metalness)*(1.0-material.transmission);
#else
return(INV_LGL_B*Fd*material.color)*(1.0-material.metalness)*(1.0-material.transmission);
#endif
}fn LGL_AV(material : PrincipledBSDF,eta : f32,Cspec0 : vec3<f32>,V : vec3<f32>,L : vec3<f32>,H : vec3<f32>,pdf : ptr<function,f32>)->vec3<f32>{if((L.z<=0.0)){return vec3<f32>(0.0);}let LDotH=dot(L,H);let D=LGL_AB(H.z,material.roughness);*pdf=D*H.z/(4.0*LDotH);let FMix=LGL_y(material.metalness,eta,LDotH);let F=mix(Cspec0,vec3<f32>(1.0),FMix);let G=LGL_z(abs(L.z),material.roughness)*LGL_z(abs(V.z),material.roughness);return F*D*G;}fn LGL_AW(material : PrincipledBSDF,eta : f32,Cspec : vec3<f32>,V : vec3<f32>,L : vec3<f32>,H : vec3<f32>,pdf : ptr<function,f32>)->vec3<f32>{if((L.z>=0.0)){return vec3<f32>(0.0);}let F=LGL_x(abs(dot(V,H)),eta);let D=LGL_AB(H.z,material.roughness);let denomSqrt=dot(L,H)+dot(V,H)*eta;*pdf=D*H.z*abs(dot(L,H))/(denomSqrt*denomSqrt);let G=LGL_z(abs(L.z),material.roughness)*LGL_z(abs(V.z),material.roughness);let specColor=pow(material.color,vec3<f32>(0.5));return specColor*(1.0-material.metalness)*material.transmission*(1.0-F)*D*G*abs(dot(V,H))*abs(dot(L,H))*4.0*eta*eta/(denomSqrt*denomSqrt);}
#if ${e.LGL_Ar=="PT"}
fn LGL_AX(material : PrincipledBSDF,V : vec3<f32>,L : vec3<f32>,H : vec3<f32>,pdf : ptr<function,f32>)->vec3<f32>{if((L.z<=0.0)){return vec3<f32>(0.0);}let LDotH=dot(L,H);let F=LGL_v(.04,LDotH);let D=LGL_AA(H.z,mix(0.1,0.001,1.-material.clearcoatRoughness));*pdf=D*H.z/(4.0*LDotH);let G=LGL_z(L.z,0.25)*LGL_z(V.z,0.25);return vec3<f32>(0.25*material.clearcoat*F*D*G);}
#endif
fn LGL_AY(baseColor : vec3<f32>)->vec3<f32>{let LGL_M=LGL_M(baseColor);return select(vec3<f32>(1.),baseColor/LGL_M,LGL_M>0.0);}fn LGL_AZ(material : PrincipledBSDF,eta : f32,Cspec0 : ptr<function,vec3<f32>>,Csheen : ptr<function,vec3<f32>>){
#if ${e.supportSGWorkflow}
if(material.workflow>0.){*Cspec0=material.specularColor;}else
#endif
{
#if ${e.LGL_Ar=="PT"}
let tint=LGL_AY(material.color);*Cspec0=mix(LGL_t(eta)*mix(vec3<f32>(1.0),tint,material.specularTint),material.color,material.metalness);*Csheen=mix(vec3<f32>(1.0),tint,material.sheenTint);
#else
*Cspec0=mix(vec3f(LGL_t(eta)),material.color,material.metalness);
#endif
}}fn LGL_Aa(material : PrincipledBSDF,Cspec0 : vec3<f32>,fresnelWeight : f32,diffuseWt : ptr<function,f32>,specularWt : ptr<function,f32>,transWt : ptr<function,f32>,clearcoatWt : ptr<function,f32>){*specularWt=LGL_M(mix(Cspec0,vec3<f32>(1.0),fresnelWeight));*transWt=(1.0-fresnelWeight)*(1.0-material.metalness)*material.transmission*LGL_M(material.color);
#if ${e.LGL_Ar=="PT"}
*diffuseWt=max(LGL_M(material.color),material.sheen)*(1.0-material.metalness)*(1.0-material.transmission);*clearcoatWt=material.clearcoat*(1.0-material.metalness);
#else
*diffuseWt=LGL_M(material.color)*(1.0-material.metalness)*(1.0-material.transmission);*clearcoatWt=0.;
#endif
let weightSum=*diffuseWt+*specularWt+*transWt+*clearcoatWt;*diffuseWt/=weightSum;*specularWt/=weightSum;*transWt/=weightSum;*clearcoatWt/=weightSum;}fn LGL_Ab(si : SurfaceInteraction,material : PrincipledBSDF,basis : Basis,LGL_f : vec2<f32>,V : vec3<f32>,N : vec3<f32>,L : ptr<function,vec3<f32>>,pdf : ptr<function,f32>)->vec3<f32>{var f=vec3<f32>(0.0);*pdf=0.0;var r1=LGL_f.x;var r2=LGL_f.y;var Cspec0 : vec3<f32>;var Csheen : vec3<f32>;LGL_AZ(material,si.eta,&Cspec0,&Csheen);var diffuseWt : f32;var specularWt : f32;var transWt : f32;var clearcoatWt : f32;var fresnelWeight=LGL_y(material.metalness,si.eta,V.z);LGL_Aa(material,Cspec0,fresnelWeight,&diffuseWt,&specularWt,&transWt,&clearcoatWt);var weight : array<f32,4u>;weight[0]=diffuseWt;weight[1]=weight[0]+specularWt;weight[2]=weight[1]+transWt;weight[3]=weight[2]+clearcoatWt;if(r1<weight[0]){r1/=weight[0];*L=LGL_i(r1,r2);var H=normalize(*L+V);f=LGL_AU(material,Csheen,V,*L,H,pdf);*pdf*=diffuseWt;}else if(r1<weight[1]){r1=(r1-weight[0])/(weight[1]-weight[0]);var H=ISLGL_AB(material.roughness,r1,r2);if(dot(V,H)<0.0){H=-H;}*L=normalize(reflect(-V,H));f=LGL_AV(material,si.eta,Cspec0,V,*L,H,pdf);*pdf*=specularWt;}else if(r1<weight[2]){r1=(r1-weight[1])/(weight[2]-weight[1]);var H=ISLGL_AB(material.roughness,r1,r2);if(dot(V,H)<0.0){H=-H;}var R=reflect(-V,H);*L=normalize(refract(-V,H,si.eta));f=LGL_AW(material,si.eta,Cspec0,V,*L,H,pdf);*pdf*=transWt;}
#if ${e.LGL_Ar=="PT"}
else{r1=(r1-weight[2])/(1.0-weight[2]);var H=ISLGL_AA(mix(0.1,0.001,1.-material.clearcoatRoughness),r1,r2);if(dot(V,H)<0.0){H=-H;}*L=normalize(reflect(-V,H));f=LGL_AX(material,V,*L,H,pdf);*pdf*=clearcoatWt;}
#endif
*L=LGL_s(*L,basis);return f;}fn LGL_Ac(si : SurfaceInteraction,material : PrincipledBSDF,V : vec3<f32>,L : vec3<f32>,bsdfPdf : ptr<function,f32>)->vec3<f32>{var f=vec3<f32>(0.0);*bsdfPdf=0.0;var H : vec3<f32>;if(L.z>0.0){H=normalize(L+V);}else{H=normalize(L+V*si.eta);}if(dot(V,H)<0.0){H=-H;}var Cspec0 : vec3<f32>;var Csheen : vec3<f32>;LGL_AZ(material,si.eta,&Cspec0,&Csheen);var diffuseWt : f32;var specularWt : f32;var transWt : f32;var clearcoatWt : f32;var fresnelWeight=LGL_y(material.metalness,si.eta,abs(dot(L,H)));LGL_Aa(material,Cspec0,fresnelWeight,&diffuseWt,&specularWt,&transWt,&clearcoatWt);var pdf : f32;if(diffuseWt>0.0&&L.z>0.0){f+=LGL_AU(material,Csheen,V,L,H,&pdf);*bsdfPdf+=pdf*diffuseWt;}if(specularWt>0.0&&L.z>0.0&&V.z>0.0){f+=LGL_AV(material,si.eta,Cspec0,V,L,H,&pdf);*bsdfPdf+=pdf*specularWt;}if(transWt>0.0&&L.z<0.0){f+=LGL_AW(material,si.eta,Cspec0,V,L,H,&pdf);*bsdfPdf+=pdf*transWt;}
#if ${e.LGL_Ar=="PT"}
if(clearcoatWt>0.0&&L.z>0.0&&V.z>0.0){f+=LGL_AX(material,V,L,H,&pdf);*bsdfPdf+=pdf*clearcoatWt;}
#endif
return f;}`,ss=(i,e)=>i`struct Triangle{p0: vec3<f32>,p1: vec3<f32>,p2: vec3<f32>};struct TriangleIntersect{t: f32,barycentric: vec3<f32>};fn rectIntersect(pos: vec3f,u: vec3f,v: vec3f,plane: vec4f,r: Ray)->f32{var n=plane.xyz;var dt=dot(r.d,n);var t=(plane.w-dot(n,r.o))/dt;if(t>EPS){var p=r.o+r.d*t;var vi=p-pos;var a1=dot(u,vi);if(abs(a1)<=0.5){var a2=dot(v,vi);if(abs(a2)<=0.5){return t;}}}return LGL_A;}fn LGL_Ai(r : Ray,tri : Triangle,tMax : f32)->TriangleIntersect{let v0=tri.p0;let v1=tri.p1;let v2=tri.p2;var ti : TriangleIntersect;let v1v0=v1-v0;let v2v0=v2-v0;let rov0=r.o-v0;let n=cross(v1v0,v2v0);let q=cross(rov0,r.d);let d=1./dot(r.d,n);var uvt : vec4<f32>;uvt.x=d*dot(-q,v2v0);uvt.y=d*dot(q,v1v0);uvt.z=d*dot(-n,rov0);uvt.w=1.0-uvt.x-uvt.y;if(uvt.z>=tMax){return ti;}if(all(uvt>vec4<f32>(0.0))&&uvt.z<LGL_A){ti.t=uvt.z;ti.barycentric=uvt.wxy;}return ti;}fn LGL_Ae(indice : u32)->vec3<f32>{return vec3<f32>(position[indice][0],position[indice][1],position[indice][2]);}fn LGL_Ah(triIndices : vec3<u32>)->Triangle{let posU=LGL_Ae(triIndices.x);let posV=LGL_Ae(triIndices.y);let posW=LGL_Ae(triIndices.z);let tri=Triangle(posU,posV,posW);return tri;}fn LGL_Af(indice : u32)->vec3<f32>{return vec3<f32>(normal[indice][0],normal[indice][1],normal[indice][2]);}fn LGL_Ag(indice : u32)->vec2<f32>{return vec2<f32>(uv[indice][0],uv[indice][1]);}fn LGL_Aj(siPtr : ptr<function,SurfaceInteraction>,tri : Triangle,barycentric : vec3<f32>,index : vec3<u32>){(*siPtr).position=barycentric.x*tri.p0+barycentric.y*tri.p1+barycentric.z*tri.p2;let n0=LGL_Af(index.x);let n1=LGL_Af(index.y);let n2=LGL_Af(index.z);let normal=normalize(barycentric.x*n0+barycentric.y*n1+barycentric.z*n2);let e0=tri.p1-tri.p0;let e1=tri.p2-tri.p0;let faceNormal=normalize(cross(e0,e1));(*siPtr).faceNormal=faceNormal;let uv0=LGL_Ag(index.x);let uv1=LGL_Ag(index.y);let uv2=LGL_Ag(index.z);let uv=barycentric.x*uv0+barycentric.y*uv1+barycentric.z*uv2;let materialIndex=(*siPtr).matID;principledBSDFMaterial=LGL_AT(materialIndex,uv);let dp1=tri.p0-tri.p2;let dp2=tri.p1-tri.p2;let duv1=uv0-uv2;let duv2=uv1-uv2;(*siPtr).normal=LGL_AS(materialIndex,uv,normal,faceNormal,dp1,dp2,duv1,duv2);}`,is=(i,e)=>i`fn LGL_Al(ray : Ray,maxDist : f32)->bool{var tMax=maxDist;var nodesToVisit : array<i32,LGL_L>;var nodesLevel : array<i32,LGL_L>;nodesToVisit[0]=0;nodesLevel[0]=0;var invDirWorld=1./ray.d;var invDirLocal=vec3f(1.);let maxDepth: i32=20;var tlasTransMat: mat4x4<f32>;var tlasTransMatInverse: mat4x4<f32>;var rayTrans:Ray;rayTrans.o=ray.o;rayTrans.d=ray.d;var throughBLASMark=false;var stack: i32=0;while(stack>=0&&stack<maxDepth){var i=nodesToVisit[stack];var level=nodesLevel[stack];stack--;if(throughBLASMark&&i==-1){throughBLASMark=false;rayTrans.o=ray.o;rayTrans.d=ray.d;continue;}if(level==0){var tlasNode=tlasNodes[i];var typeFlag=tlasNode.typeFlag;if(typeFlag==1.){let visible=u32(tlasNode.meshInfoOraabbMax.x);if(visible==0){continue;}let instanceID=i32(tlasNode.idInfoOrAABBMin.z);tlasTransMat=tlasTransNodes[instanceID].LGL_sMat;tlasTransMatInverse=tlasTransNodes[instanceID].LGL_rMat;rayTrans.o=(tlasTransMatInverse*vec4f(ray.o,1.0)).xyz;rayTrans.d=(tlasTransMatInverse*vec4f(ray.d,0.0)).xyz;invDirLocal=1./rayTrans.d;stack++;throughBLASMark=true;nodesToVisit[stack]=-1;nodesLevel[stack]=-1;stack++;let blasNodeIndex=i32(tlasNode.idInfoOrAABBMin.x);nodesToVisit[stack]=blasNodeIndex;nodesLevel[stack]=1;}else{let aabbMin=tlasNode.idInfoOrAABBMin;let aabbMax=tlasNode.meshInfoOraabbMax;if(LGL_q(rayTrans,aabbMin,aabbMax,invDirWorld,tMax)){stack++;nodesToVisit[stack]=i+1;nodesLevel[stack]=0;stack++;nodesToVisit[stack]=i32(tlasNode.nextPtr);nodesLevel[stack]=0;}}}else{var blasNode=blasNodes[i];var typeFlag=blasNode.typeFlag;if(typeFlag==1.){let triIndices=vec3<u32>(blasNode.indicesOrMin);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(rayTrans,tri,tMax);if(hit.t>0.){return true;}}else{let aabbMin=blasNode.indicesOrMin;let aabbMax=blasNode.aabbMax;if(LGL_q(rayTrans,aabbMin,aabbMax,invDirLocal,tMax)){stack++;nodesToVisit[stack]=i+1;nodesLevel[stack]=1;stack++;nodesToVisit[stack]=i32(blasNode.nextPtr);nodesLevel[stack]=1;}}}}return false;}fn LGL_Ak(siPtr : ptr<function,SurfaceInteraction>,ray : Ray,lightSampleRec : ptr<function,LightSampleRec>,depth: i32,maxDist : f32){(*siPtr).hit=false;var tMax=maxDist;var curDist=0.;
#if ${e.supportLightSource}
for(var i: u32=0;i<sceneUniform.lightNum;i++){var lightData=lights.data[i];if(u32(lightData.visible)==0&&depth==0){continue;}var position=lightData.position;var radius=lightData.radius;var emission=lightData.emission;var area=lightData.area;var p1=lightData.p1;var p2=lightData.p2;var lightType=u32(lightData.lightType);if(lightType==0){var normal=normalize(cross(p1,p2));if(dot(normal,ray.d)>0.){continue;}var plane=vec4f(normal,dot(normal,position));p1*=1.0/dot(p1,p1);p2*=1.0/dot(p2,p2);curDist=rectIntersect(position,p1,p2,plane,ray);if(curDist<0.){curDist=LGL_A;}if(curDist<tMax){tMax=curDist;var cosTheta=dot(-ray.d,normal);var pdf=(curDist*curDist)/(area*cosTheta);(*lightSampleRec).emission=emission;(*lightSampleRec).pdf=pdf;(*siPtr).hit=true;(*siPtr).isEmitter=true;}}}
#endif
var nodesToVisit : array<i32,LGL_L>;var nodesLevel : array<i32,LGL_L>;nodesToVisit[0]=0;nodesLevel[0]=0;var invDirWorld=1./ray.d;var invDirLocal=vec3f(1.);var tlasMatID: u32=0;var tlasMeshID: u32=0;var tlasTransMat: mat4x4<f32>;var tlasTransMatInverse: mat4x4<f32>;var rayTrans:Ray;rayTrans.o=ray.o;rayTrans.d=ray.d;var throughBLASMark=false;var stack : i32=0;while(stack>=0&&stack<LGL_L){var i=nodesToVisit[stack];var level=nodesLevel[stack];stack--;if(throughBLASMark&&i==-1){throughBLASMark=false;rayTrans.o=ray.o;rayTrans.d=ray.d;continue;}if(level==0){var tlasNode=tlasNodes[i];var typeFlag=tlasNode.typeFlag;if(typeFlag==1.){let visible=u32(tlasNode.meshInfoOraabbMax.x);if(visible==0){continue;}let instanceID=i32(tlasNode.idInfoOrAABBMin.z);tlasTransMat=tlasTransNodes[instanceID].LGL_sMat;tlasTransMatInverse=tlasTransNodes[instanceID].LGL_rMat;rayTrans.o=(tlasTransMatInverse*vec4f(ray.o,1.0)).xyz;rayTrans.d=(tlasTransMatInverse*vec4f(ray.d,0.0)).xyz;invDirLocal=1./rayTrans.d;stack++;throughBLASMark=true;nodesToVisit[stack]=-1;nodesLevel[stack]=-1;stack++;let blasNodeIndex=i32(tlasNode.idInfoOrAABBMin.x);nodesToVisit[stack]=blasNodeIndex;nodesLevel[stack]=1;tlasMatID=u32(tlasNode.idInfoOrAABBMin.y);tlasMeshID=u32(tlasNode.idInfoOrAABBMin.z);}else{let aabbMin=tlasNode.idInfoOrAABBMin;let aabbMax=tlasNode.meshInfoOraabbMax;if(LGL_q(rayTrans,aabbMin,aabbMax,invDirWorld,tMax)){stack++;nodesToVisit[stack]=i+1;nodesLevel[stack]=0;stack++;nodesToVisit[stack]=i32(tlasNode.nextPtr);nodesLevel[stack]=0;}}}else{var blasNode=blasNodes[i];var typeFlag=blasNode.typeFlag;if(typeFlag==1.){let triIndices=vec3<u32>(blasNode.indicesOrMin);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(rayTrans,tri,tMax);if(hit.t>0.){(*siPtr).hit=true;(*siPtr).t=hit.t;(*siPtr).isEmitter=false;tMax=hit.t;(*siPtr).matID=tlasMatID;(*siPtr).meshID=tlasMeshID;LGL_Aj(siPtr,tri,hit.barycentric,triIndices);(*siPtr).position=(tlasTransMat*vec4((*siPtr).position,1.0)).xyz;let inverseNormalMat=transpose(mat3x3(tlasTransMatInverse[0].xyz,tlasTransMatInverse[1].xyz,tlasTransMatInverse[2].xyz));(*siPtr).normal=normalize(inverseNormalMat*(*siPtr).normal);(*siPtr).faceNormal=normalize(inverseNormalMat*(*siPtr).faceNormal);(*siPtr).normal=(*siPtr).normal*sign(dot((*siPtr).normal,(*siPtr).faceNormal));(*siPtr).ffnormal=select(-(*siPtr).normal,(*siPtr).normal,dot((*siPtr).faceNormal,ray.d)<0.0);(*siPtr).eta=select(principledBSDFMaterial.ior,(1.0/principledBSDFMaterial.ior),dot((*siPtr).normal,(*siPtr).ffnormal)>0.0);}}else{let aabbMin=blasNode.indicesOrMin;let aabbMax=blasNode.aabbMax;if(LGL_q(rayTrans,aabbMin,aabbMax,invDirLocal,tMax)){stack++;nodesToVisit[stack]=i+1;nodesLevel[stack]=1;stack++;nodesToVisit[stack]=i32(blasNode.nextPtr);nodesLevel[stack]=1;}}}}return;}`,as=(i,e)=>i`fn LGL_Ad(triIndex : u32)->vec3<u32>{return vec3<u32>(indices[triIndex][0],indices[triIndex][1],indices[triIndex][2]);}fn LGL_Al(ray : Ray,maxDist : f32)->bool{var tMax=maxDist;var nodesToVisit : array<i32,LGL_L>;nodesToVisit[0]=0;let invDir=1./ray.d;let maxDepth: i32=20;var stack : i32=0;while(stack>=0&&stack<maxDepth){var i=nodesToVisit[stack];stack--;var childAIndex=bvhNodes[i].childA;var childBIndex=bvhNodes[i].childB;if(LGL_q(ray,bvhNodes[childAIndex].aabbMin,bvhNodes[childAIndex].aabbMax,invDir,tMax)){var triIndicesID=bvhNodes[childAIndex].triIndicesID;if(triIndicesID!=0xFFFFFFFF){let triIndices=LGL_Ad(triIndicesID);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(ray,tri,tMax);if(hit.t>0.){return true;}}else{stack++;nodesToVisit[stack]=i32(childAIndex);}}if(LGL_q(ray,bvhNodes[childBIndex].aabbMin,bvhNodes[childBIndex].aabbMax,invDir,tMax)){var triIndicesID=bvhNodes[childBIndex].triIndicesID;if(triIndicesID!=0xFFFFFFFF){let triIndices=LGL_Ad(triIndicesID);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(ray,tri,tMax);if(hit.t>0.){return true;}}else{stack++;nodesToVisit[stack]=i32(childBIndex);}}}return false;}fn LGL_Ak(siPtr : ptr<function,SurfaceInteraction>,ray : Ray,lightSampleRec : ptr<function,LightSampleRec>,depth: i32,maxDist : f32){(*siPtr).hit=false;var tMax=maxDist;var curDist=0.;
#if ${e.supportLightSource}
for(var i: u32=0;i<sceneUniform.lightNum;i++){var lightData=lights.data[i];if(u32(lightData.visible)==0&&depth==0){continue;}var position=lightData.position;var radius=lightData.radius;var emission=lightData.emission;var area=lightData.area;var p1=lightData.p1;var p2=lightData.p2;var lightType=u32(lightData.lightType);if(lightType==0){var normal=normalize(cross(p1,p2));if(dot(normal,ray.d)>0.){continue;}var plane=vec4f(normal,dot(normal,position));p1*=1.0/dot(p1,p1);p2*=1.0/dot(p2,p2);curDist=rectIntersect(position,p1,p2,plane,ray);if(curDist<0.){curDist=LGL_A;}if(curDist<tMax){tMax=curDist;var cosTheta=dot(-ray.d,normal);var pdf=(curDist*curDist)/(area*cosTheta);(*lightSampleRec).emission=emission;(*lightSampleRec).pdf=pdf;(*siPtr).hit=true;(*siPtr).isEmitter=true;}}}
#endif
var nodesToVisit : array<i32,LGL_L>;nodesToVisit[0]=0;let invDir=1./ray.d;var stack : i32=0;while(stack>=0&&stack<LGL_L){var i=nodesToVisit[stack];stack--;var childAIndex=bvhNodes[i].childA;var childBIndex=bvhNodes[i].childB;if(LGL_q(ray,bvhNodes[childAIndex].aabbMin,bvhNodes[childAIndex].aabbMax,invDir,tMax)){var triIndicesID=bvhNodes[childAIndex].triIndicesID;if(triIndicesID!=0xFFFFFFFF){let triIndices=LGL_Ad(triIndicesID);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(ray,tri,tMax);if(hit.t>0.){(*siPtr).hit=true;(*siPtr).t=hit.t;tMax=hit.t;(*siPtr).matID=bvhNodes[childAIndex].materialID;(*siPtr).meshID=bvhNodes[childBIndex].childA;LGL_Aj(siPtr,tri,hit.barycentric,triIndices);(*siPtr).normal=(*siPtr).normal*sign(dot((*siPtr).normal,(*siPtr).faceNormal));(*siPtr).ffnormal=select(-(*siPtr).normal,(*siPtr).normal,dot((*siPtr).faceNormal,ray.d)<0.0);(*siPtr).eta=select(principledBSDFMaterial.ior,(1.0/principledBSDFMaterial.ior),dot((*siPtr).normal,(*siPtr).ffnormal)>0.0);}}else{stack++;nodesToVisit[stack]=i32(childAIndex);}}if(LGL_q(ray,bvhNodes[childBIndex].aabbMin,bvhNodes[childBIndex].aabbMax,invDir,tMax)){var triIndicesID=bvhNodes[childBIndex].triIndicesID;if(triIndicesID!=0xFFFFFFFF){let triIndices=LGL_Ad(triIndicesID);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(ray,tri,tMax);if(hit.t>0.){(*siPtr).hit=true;(*siPtr).t=hit.t;(*siPtr).isEmitter=false;tMax=hit.t;(*siPtr).matID=bvhNodes[childBIndex].materialID;(*siPtr).meshID=bvhNodes[childBIndex].childA;LGL_Aj(siPtr,tri,hit.barycentric,triIndices);(*siPtr).normal=(*siPtr).normal*sign(dot((*siPtr).normal,(*siPtr).faceNormal));(*siPtr).ffnormal=select(-(*siPtr).normal,(*siPtr).normal,dot((*siPtr).faceNormal,ray.d)<0.0);(*siPtr).eta=select(principledBSDFMaterial.ior,(1.0/principledBSDFMaterial.ior),dot((*siPtr).normal,(*siPtr).ffnormal)>0.0);}}else{stack++;nodesToVisit[stack]=i32(childBIndex);}}}return;}`,ns=(i,e)=>i`const MAX_LIGHT_COUNT: u32=16;struct Lights{data: array<Light,MAX_LIGHT_COUNT>,};struct Light{position: vec3<f32>,radius: f32,emission: vec3<f32>,area: f32,p1: vec3<f32>,lightType: f32,p2: vec3<f32>,visible: f32,};`,os=(i,e)=>i`fn sampleAreaLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>,random: vec2f){var r1=random.x-0.5;var r2=random.x-0.5;var lightSurfacePos=light.position+light.p1*r1+light.p2*r2;(*lightSampleRec).direction=lightSurfacePos-surfacePos;(*lightSampleRec).dist=length((*lightSampleRec).direction);var distSq=(*lightSampleRec).dist*(*lightSampleRec).dist;(*lightSampleRec).direction/=(*lightSampleRec).dist;(*lightSampleRec).normal=normalize(cross(light.p1,light.p2));(*lightSampleRec).emission=light.emission*f32(sceneUniform.lightNum);(*lightSampleRec).pdf=distSq/(light.area*abs(dot((*lightSampleRec).normal,(*lightSampleRec).direction)));}fn sampleDirectionLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>){(*lightSampleRec).direction=normalize(light.position-light.p1);(*lightSampleRec).normal=normalize(surfacePos-light.position);if(dot((*lightSampleRec).direction,(*lightSampleRec).normal)>0.0){(*lightSampleRec).normal=-(*lightSampleRec).normal;}(*lightSampleRec).emission=light.emission*f32(sceneUniform.lightNum);(*lightSampleRec).dist=LGL_A;(*lightSampleRec).pdf=1.0;}fn samplePointLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>){(*lightSampleRec).direction=light.position-surfacePos;(*lightSampleRec).dist=length((*lightSampleRec).direction);var distSq=(*lightSampleRec).dist*(*lightSampleRec).dist;(*lightSampleRec).direction=normalize((*lightSampleRec).direction);(*lightSampleRec).normal=normalize(surfacePos-light.position);(*lightSampleRec).emission=light.emission*f32(sceneUniform.lightNum)/distSq;(*lightSampleRec).pdf=1.0;}fn sampleOneLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>,random: vec2f){var lightType=i32(light.lightType);if(lightType==0){sampleAreaLight(light,surfacePos,lightSampleRec,random);}else if(lightType==1){sampleDirectionLight(light,surfacePos,lightSampleRec);}else if(lightType==2){samplePointLight(light,surfacePos,lightSampleRec);}}`,us=(i,e)=>i`struct FrameUniform{viewToWorldMat : mat4x4<f32>,clipToViewMat : mat4x4<f32>,sampleCount: u32,strataSize: f32,jitter: vec2<f32>,cameraAperture: f32,cameraFocus: f32,}struct SceneUniform{envRotMatrix : mat3x3<f32>,invEnvRotMatrix : mat3x3<f32>,backgroundColor : vec3<f32>,envMapIntensity: f32,renderSize: vec2<u32>,bounces: i32,enableBackgroundColor: u32,backgroundAlpha: f32,totalSumValue: f32,lightNum: u32}struct TileUniform{tileOffset: vec2<u32>,tileSize: vec2<u32>,tileEnable: u32}`,ls=(i,e)=>i`fn LGL_Aq(si : SurfaceInteraction,basis : Basis,winputL : vec3<f32>,s1 : vec2<f32>,s2 : vec2<f32>)->vec3<f32>{var surfacePos=si.position+LGL_J*si.ffnormal;var Li=vec3<f32>(0.0);var bsdfSampleRec : BSDFSampleRec;var bsdfPDF : f32;var woutputL : vec3<f32>;var woutputW : vec3<f32>;var uv : vec2<f32>;var lightPdf : f32;woutputW=sceneUniform.invEnvRotMatrix*LGL_Y(s1,&uv,&lightPdf);woutputL=LGL_r(woutputW,basis);var ray=Ray(surfacePos,woutputW);if(!LGL_Al(ray,LGL_A-EPS)){var irr=textureSampleLevel(envMap,texSampler,uv,0.).rgb*sceneUniform.envMapIntensity;bsdfSampleRec.f=LGL_Ac(si,principledBSDFMaterial,winputL,woutputL,&bsdfPDF)*abs(woutputL.z);bsdfSampleRec.pdf=bsdfPDF;var misWeight=LGL_l(lightPdf,bsdfSampleRec.pdf);Li+=misWeight*bsdfSampleRec.f*irr/lightPdf;}
#if ${e.supportLightSource}
var lightSampleRec: LightSampleRec;var i=i32(s2.x*f32(sceneUniform.lightNum));var lightData=lights.data[i];var light=Light(lightData.position,lightData.radius,lightData.emission,lightData.area,lightData.p1,lightData.lightType,lightData.p2,lightData.visible);sampleOneLight(light,surfacePos,&lightSampleRec,s2);if(dot(lightSampleRec.direction,lightSampleRec.normal)<0.0){var ray=Ray(surfacePos,lightSampleRec.direction);if(!LGL_Al(ray,lightSampleRec.dist-EPS)){woutputW=lightSampleRec.direction;woutputL=LGL_r(woutputW,basis);bsdfSampleRec.f=LGL_Ac(si,principledBSDFMaterial,winputL,woutputL,&bsdfPDF)*abs(woutputL.z);bsdfSampleRec.pdf=bsdfPDF;var misWeight=1.0;if(light.area>0.0&&bsdfSampleRec.pdf>0.0){misWeight=LGL_l(lightSampleRec.pdf,bsdfSampleRec.pdf);}if(misWeight>0.0){Li+=misWeight*bsdfSampleRec.f*lightSampleRec.emission/lightSampleRec.pdf;}}}
#endif
return Li;}`,cs=(i,e)=>i`fn LGL_As(pathPt : ptr<function,Path>,siIn : SurfaceInteraction,depth : i32,bsdfSampleRecPt: ptr<function,BSDFSampleRec>,lightSampleRec: LightSampleRec){var si=siIn;var bsdfSampleL : vec3<f32>;var bsdfSamplePDF : f32;if(!si.hit){var envSampleDir=sceneUniform.envRotMatrix*(*pathPt).ray.d;if(depth==0){(*pathPt).li+=select(LGL_V(envSampleDir)*sceneUniform.envMapIntensity,sceneUniform.backgroundColor,sceneUniform.enableBackgroundColor==1);(*pathPt).alpha=sceneUniform.backgroundAlpha;(*pathPt).abort=true;return;}var irr=LGL_V(envSampleDir)*sceneUniform.envMapIntensity;var misWeightEnv=1.0;let lightPdf=LGL_X(envSampleDir);misWeightEnv=LGL_l((*bsdfSampleRecPt).pdf,lightPdf);if(misWeightEnv>0.){(*pathPt).li+=misWeightEnv*irr*(*pathPt).beta;}(*pathPt).abort=true;return;}if(si.isEmitter){(*pathPt).li+=EmitterSample((*pathPt).ray,depth,lightSampleRec,*bsdfSampleRecPt)*(*pathPt).beta;(*pathPt).abort=true;return;}var basis=LGL_p(si.ffnormal);var wiW=-(*pathPt).ray.d;var wiL=LGL_r(wiW,basis);var LGL_fs=LGL_g();(*pathPt).li+=(*pathPt).beta*principledBSDFMaterial.emissiveColor;
#if ${e.enableSSS}
var Cspec0 : vec3<f32>;var Csheen : vec3<f32>;LGL_AZ(principledBSDFMaterial,si.eta,&Cspec0,&Csheen);var sssWt=LGL_AG(principledBSDFMaterial,Cspec0);var sssPath=(rand()<sssWt);if(sssPath){var basis=LGL_p(si.normal);var siExit: SurfaceInteraction;var throughput: vec3<f32>;var sssLightSampleRec : LightSampleRec;var hit=LGL_AH(si,principledBSDFMaterial,basis,LGL_fs.s1,LGL_fs.s2,&throughput,&siExit,&sssLightSampleRec);if(!hit){(*pathPt).abort=true;return;}si=siExit;(*pathPt).beta*=throughput;var normalExit=siExit.normal;var basisExit=LGL_p(normalExit);var bsdfSamplePDF: f32;var dirExitL=LGL_iWithPDF(LGL_fs.s3.x,LGL_fs.s3.y,&bsdfSamplePDF);(*bsdfSampleRecPt).pdf=bsdfSamplePDF;(*bsdfSampleRecPt).L=LGL_s(dirExitL,basisExit);(*bsdfSampleRecPt).f=abs(dot((*bsdfSampleRecPt).L,normalExit))*principledBSDFMaterial.color/LGL_B;(*pathPt).li+=LGL_AI(siExit,principledBSDFMaterial,basisExit,LGL_fs.s1,LGL_fs.s4)*(*pathPt).beta;(*pathPt).beta*=sssWt;}else{
#endif
#if ${e.supportAbsorption}
if(dot(si.normal,si.ffnormal)>0.0){(*pathPt).absorption=vec3(0.0);}(*pathPt).beta*=exp(-(*pathPt).absorption*si.t);
#endif
(*pathPt).li+=LGL_Aq(si,basis,wiL,LGL_fs.s1,LGL_fs.s2)*(*pathPt).beta;if(depth==(sceneUniform.bounces-1)){(*pathPt).abort=true;return;}(*bsdfSampleRecPt).f=LGL_Ab(si,principledBSDFMaterial,basis,LGL_fs.s3,wiL,si.ffnormal,&bsdfSampleL,&bsdfSamplePDF);(*bsdfSampleRecPt).L=bsdfSampleL;(*bsdfSampleRecPt).pdf=bsdfSamplePDF;
#if ${e.supportAbsorption}
let inDielectric : bool=dot(si.ffnormal,(*bsdfSampleRecPt).L)<0.0;if(inDielectric){(*pathPt).absorption=-log(principledBSDFMaterial.extinction)/principledBSDFMaterial.atDistance;}
#endif
(*pathPt).beta*=abs(dot(si.ffnormal,bsdfSampleL));
#if ${e.enableSSS}
(*pathPt).beta*=(1.-sssWt);}
#endif
if((*bsdfSampleRecPt).pdf>0.0){(*pathPt).beta*=(*bsdfSampleRecPt).f/(*bsdfSampleRecPt).pdf;}else{(*pathPt).abort=true;return;}if(depth>=2){let q=1.0-LGL_M((*pathPt).beta);if(LGL_fs.s4.x<q){(*pathPt).abort=true;return;}(*pathPt).beta/=1.0-q;}(*pathPt).ray=Ray(si.position+LGL_J*(*bsdfSampleRecPt).L,(*bsdfSampleRecPt).L);}fn LGL_Ar(ray : Ray)->vec4<f32>{var path : Path;var si : SurfaceInteraction;var bsdfSampleRec : BSDFSampleRec;var lightSampleRec : LightSampleRec;path.ray=ray;path.li=vec3<f32>(0.0);path.alpha=1.0;path.abort=false;path.misWeight=1.0;path.absorption=vec3<f32>(0.0);path.beta=vec3<f32>(1.0);var LGL_Am: u32=0;let LGL_An: u32=3;for(var i : i32=0;i<sceneUniform.bounces;i++){if(path.abort){return vec4<f32>(path.li,path.alpha);}LGL_Ak(&si,path.ray,&lightSampleRec,i,LGL_A);
#if ${e.supportAlpha&&e.geoType=="Mesh"}
if(si.hit&&!si.isEmitter&&principledBSDFMaterial.alpha<1.0&&LGL_Am<LGL_An){if(rand()>principledBSDFMaterial.alpha){path.ray.o=si.position+EPS*path.ray.d;LGL_Am++;i--;continue;}}
#endif
LGL_As(&path,si,i,&bsdfSampleRec,lightSampleRec);}return vec4<f32>(path.li,path.alpha);}@compute @workgroup_size(8,8,1)fn main(@builtin(global_invocation_id)GlobalInvocationID : vec3<u32>){let screenSize=sceneUniform.renderSize;var screenPos=GlobalInvocationID.xy;if(any(GlobalInvocationID.xy>screenSize)){return;}if(tileUniform.tileEnable==1){if(any(GlobalInvocationID.xy>=tileUniform.tileSize)){return;}screenPos+=tileUniform.tileOffset;}var vCoord=vec2f(screenPos)/vec2f(screenSize);vCoord=vCoord+frameUniform.jitter;let sampleCount=frameUniform.sampleCount;LGL_c(sampleCount,vCoord,screenSize);LGL_Z(sampleCount,vCoord,screenSize);var vCoordAntiAlias=(vCoord-0.5)*2.0;var origin=LGL_o(vCoordAntiAlias);var direction : vec3f;if(frameUniform.clipToViewMat[2].w==0.){direction=-frameUniform.viewToWorldMat[2].xyz;}else{direction=normalize(mat3x3(frameUniform.viewToWorldMat[0].xyz,frameUniform.viewToWorldMat[1].xyz,frameUniform.viewToWorldMat[2].xyz)*(frameUniform.clipToViewMat*vec4(vCoordAntiAlias,0.0,1.0)).xyz);}if(frameUniform.cameraAperture>0.0){var focusPoint=origin+frameUniform.cameraFocus*normalize(direction);var lensPoint=frameUniform.cameraAperture*LGL_h(vec2f(rand()));origin=(frameUniform.viewToWorldMat*vec4f(lensPoint,0.0,1.0)).xyz;direction=normalize(focusPoint-origin);}var cam=Ray(origin,direction);var Li=LGL_Ar(cam);if(!(Li.x<LGL_A&&Li.x>-EPS)){Li=vec4<f32>(0.,0.,0.,1.);}if(sampleCount>0){var accColor=textureLoad(accumulateTex,screenPos,0);Li=(Li+accColor*f32(sampleCount))/f32(sampleCount+1);}textureStore(lightTex,screenPos,Li);}`,ds=()=>"struct FrameUniform{viewToWorldMat : mat4x4<f32>,clipToViewMat : mat4x4<f32>,}struct SceneUniform{envRotMatrix : mat3x3<f32>,invEnvRotMatrix : mat3x3<f32>,backgroundColor : vec3<f32>,envMapIntensity: f32,renderSize: vec2<u32>,}struct GBufferInfoRec{hit: bool,position: vec3<f32>,normal: vec3<f32>,color: vec3<f32>,meshID: u32,matID: u32,}var<private>texCoords: vec2<u32>;var<private>texSize: vec2<u32>;const LGL_Av: f32=1.0e-4;const LGL_Aw: f32=1000000.0;fn LGL_G_CR(radianceIn : vec3<f32>)->vec3<f32>{var radiance=radianceIn;if(!(radiance.x<LGL_Aw&&radiance.x>-LGL_Av)){return vec3<f32>(0.0);}var lum=dot(radiance,vec3<f32>(0.2125999927520752,0.7152000069618225,0.0722000002861023));var fireflyClampThreshold=1.0;if(lum>fireflyClampThreshold){radiance*=fireflyClampThreshold/lum;}return radiance;}var<private>LGL_BB: array<f32,9u>=array<f32,9u>(0.0625,0.125,0.0625,0.125,0.25,0.125,0.0625,0.125,0.0625,);var<private>LGL_BC: array<vec2i,9u>=array<vec2i,9u>(vec2i(-1,-1),vec2i(0,-1),vec2i(1,-1),vec2i(-1,0),vec2i(0,0),vec2i(1,0),vec2i(-1,1),vec2i(0,1),vec2i(1,1));fn LGL_M(color : vec3<f32>)->f32{return dot(color,vec3<f32>(0.2125999927520752,0.7152000069618225,0.0722000002861023));}fn LGL_BD(data : u32)->vec3<f32>{let d=vec3<u32>(data,data>>11,data>>21)&vec3<u32>(2047u,1023u,2047u);let v=vec3<f32>(d)*2.0/vec3<f32>(2047.0,1023.0,2047.0)-1.0;return normalize(v);}fn LGL_BE(uv: vec2f)->vec2f{return(uv-0.5)*vec2f(2.,-2.);}fn SampleGBuffer(texCoords: vec2u,gBufferTex: texture_2d<u32>,depthTex: texture_depth_2d)->GBufferInfoRec{var gi : GBufferInfoRec;var texSizeF=vec2f(texSize);var flipUV=vec2u(texCoords.x,texSize.y-texCoords.y);var gInfo=textureLoad(gBufferTex,flipUV,0);var depth=textureLoad(depthTex,flipUV,0);if(depth==1.){gi.hit=false;return gi;}gi.hit=true;var uv=(vec2f(flipUV)+0.5)/texSizeF;var ptCS=vec4f(LGL_BE(uv),depth,1.);var ptWS=frameUniform.viewToWorldMat*frameUniform.clipToViewMat*ptCS;ptWS/=ptWS.w;gi.position=ptWS.xyz;gi.color=unpack4x8unorm(gInfo.x).xyz;gi.normal=LGL_BD(gInfo.y);var idInfo=unpack2x16float(gInfo.z);gi.meshID=u32(idInfo.x);gi.matID=u32(idInfo.y);return gi;}",hs=()=>"@binding(0)@group(0)var<uniform>uniforms : Uniforms;@binding(1)@group(0)var<uniform>meshUniforms : MeshUniforms;struct Uniforms{cameraViewMatrix: mat4x4<f32>,cameraProjViewMatrix : mat4x4<f32>,renderSize: vec2<u32>}struct MeshUniforms{LGL_sMat: mat4x4<f32>,normalMat: mat3x3<f32>,meshID : u32,matID: u32,}struct VertexOutput{@builtin(position)position : vec4<f32>,@location(0)vPosition : vec3<f32>,@location(1)vNormal : vec3<f32>,@location(2)vUv : vec2<f32>,};@vertex fn main(@location(0)position : vec3<f32>,@location(1)normal : vec3<f32>,@location(2)uv : vec2<f32>,)->VertexOutput{var output : VertexOutput;var mvPosition=meshUniforms.LGL_sMat*vec4f(position,1.);output.position=uniforms.cameraProjViewMatrix*mvPosition;output.vPosition=mvPosition.xyz;output.vNormal=normalize(meshUniforms.normalMat*normal);output.vUv=uv;return output;}",fs=(i,e)=>i`@binding(0)@group(0)var<uniform>uniforms : Uniforms;@binding(1)@group(0)var<uniform>meshUniforms : MeshUniforms;@binding(2)@group(0)var<storage,read>materials : array<Material>;@binding(3)@group(0)var textureArray : texture_2d_array<f32>;@binding(4)@group(0)var texSampler : sampler;
#if ${e.supportUVTrans||e.supportTexWrap}
@binding(5)@group(0)var<storage,read>texUVTrans : array<TexUVTrans>;
#endif
fn hash8bit(a : u32)->u32{return(a ^(a>>8))<<24;}struct Uniforms{cameraViewMatrix: mat4x4<f32>,cameraProjViewMatrix : mat4x4<f32>,renderSize: vec2<u32>}struct MeshUniforms{LGL_sMat: mat4x4<f32>,normalMat: mat3x3<f32>,meshID : u32,matID: u32,}struct VertexOutput{@location(0)vPosition : vec3<f32>,@location(1)vNormal : vec3<f32>,@location(2)vUv : vec2<f32>,};struct FragmentOutput{@location(0)gBuffer : vec4<u32>,};fn encodeNormal(norIn: vec3<f32>)->u32{var nor=norIn;nor/=max(max(abs(nor.x),abs(nor.y)),abs(nor.z));let v=0.5+0.5*nor;let d=vec3<u32>(round(v*vec3<f32>(2047.0,1023.0,2047.0)));return d.x|(d.y<<11u)|(d.z<<21u);}fn getFaceNormal(position: vec3<f32>)->vec3<f32>{return normalize(cross(dpdy(position),dpdx(position)));}@fragment fn main(vo : VertexOutput)->FragmentOutput{var output : FragmentOutput;var uv=vo.vUv;let position=vo.vPosition;let matID=meshUniforms.matID;let meshID=meshUniforms.meshID;let color=LGL_AO(matID,uv);output.gBuffer.x=pack4x8unorm(color);let dp1 : vec3<f32>=dpdx(position);let dp2 : vec3<f32>=dpdy(position);let duv1 : vec2<f32>=dpdx(uv);let duv2 : vec2<f32>=dpdy(uv);let faceNormal: vec3<f32>=getFaceNormal(position);var normal=vo.vNormal;output.gBuffer.y=encodeNormal(LGL_AS(matID,uv,normal,faceNormal,dp1,dp2,duv1,duv2));output.gBuffer.z=pack2x16float(vec2<f32>(f32(meshID),f32(matID)));return output;}`;const fe=new Map,Ee=class{constructor(i,e,t){this.device=i,this.context=e,this.rg=t,this._bindGroupCache={},this.cameraProjViewMatrix=new A}async createPipeline(i,e,t){const{device:r,rg:s}=this;this.sceneInfo=e,this.renderSetting=i,this.camera=t;const a={size:ne.getStride(),usage:ne.RES_USAGE};this.frameUniformBuffer=s.resourcePool.getOrCreateResource("GBufferPassframeUniformBuffer",a).raw,this.initMeshUniformBuffer();let n=s.getRenderPipeline(Ee.ID);n||(n=await r.createRenderPipelineAsync({layout:"auto",vertex:{module:r.createShaderModule({code:hs()}),entryPoint:"main",buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]},{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:1,offset:0,format:"float32x3"}]},{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:2,offset:0,format:"float32x2"}]}]},fragment:{module:r.createShaderModule({code:z`
						${Yt(z,i)}
						${qt(z,i)}
						${Jt(z,i)}
						${fs(z,i)}
						`}),entryPoint:"main",targets:[{format:"rgba32uint"}]},primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}}),s.setRenderPipeline(Ee.ID,"",n)),this.pipeline=n}forceUpdateBG(){this._bindGroupCache={}}destroy(){Array.from(fe.values()).forEach(i=>i.destroy())}updateUniform(i){if(this.camera=i,!this.frameUniformBuffer)return;const{device:e,renderSetting:t}=this;this.cameraProjViewMatrix.multiply(i.viewToClipMat,i.worldToViewMat);const r=new ne({cameraViewMatrix:i.worldToViewMat,cameraProjViewMatrix:this.cameraProjViewMatrix,renderSize:t.renderSize}).toArrayBuffer();e.queue.writeBuffer(this.frameUniformBuffer,0,r)}initMeshUniformBuffer(){const{device:i}=this;let{meshes:e}=this.sceneInfo;e=e.filter(r=>!r.tlasMask);const t={size:oe.getStride(),usage:oe.RES_USAGE};e.forEach((r,s)=>{if(fe.get(r.id))return;const a=i.createBuffer(t);this.updateMeshUniformBuffer(a,r,s),fe.set(r.id,a)})}updateMeshUniformBuffer(i,e,t){const{device:r}=this,{materialIndexMap:s}=this.sceneInfo,a=new Z().getNormalMatrix(e.localToWorldMat).toWebGPUFormat(),n=new oe({localToWorldMat:e.localToWorldMat,normalMat:a,meshID:t,matID:s.get(e.material)}).toArrayBuffer();r.queue.writeBuffer(i,0,n)}getBindGroup(i,e){const{device:t,pipeline:r}=this;if(this._bindGroupCache[i])return this._bindGroupCache[i];const{settingBuffer:s,meshUniformBuffer:a,material:n,textureArray:u,sampler:o,uvTrans:l}=e,c=[{binding:0,resource:{buffer:s}},{binding:1,resource:{buffer:a}},{binding:2,resource:{buffer:n}},{binding:3,resource:u.createView()},{binding:4,resource:o}];(this.renderSetting.supportUVTrans||this.renderSetting.supportTexWrap)&&c.push({binding:5,resource:{buffer:l}});const d=t.createBindGroup({layout:r.getBindGroupLayout(0),entries:c});return this._bindGroupCache[i]=d,d}setup(i,e,t){const{context:r,renderSetting:s}=this,a={};a.position=e.read(i.importResource($)),a.uv=e.read(i.importResource(ee)),a.normal=e.read(i.importResource(te)),a.indices=e.read(i.importResource(se)),a.settingBuffer=e.read(i.importResource("GBufferPassframeUniformBuffer")),a.material=e.read(i.importResource(V)),a.textureArray=e.read(i.importResource(K)),a.samplers=["llr"],(s.supportUVTrans||s.supportTexWrap)&&(a.uvTrans=e.read(i.importResource(H)));const n={size:{width:r.width,height:r.height},format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING};let u=i.createTexture("GBufferOutputTexture",n,!0);const o={size:{width:r.width,height:r.height},format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING};let l=i.createTexture("GBufferDepthTexture",o,!0);a.output=e.write(i,u),a.outputDepth=e.write(i,l),t.data=a}execute(i,e,t,r){const s=e.data,a=i.getRenderPipeline(e.name,""),n=i.getPassRawResFromPool(s.output),u=i.getPassRawResFromPool(s.outputDepth),o=r.beginRenderPass({colorAttachments:[{view:n.createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:u.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}}),l=i.getPassRawResFromPool(s.position),c=i.getPassRawResFromPool(s.normal),d=i.getPassRawResFromPool(s.uv),h=i.getPassRawResFromPool(s.indices),f=i.getPassRawResFromPool(s.settingBuffer),m=i.getPassRawResFromPool(s.material),x=i.getPassRawResFromPool(s.textureArray),g=i.samplers[s.samplers[0]],p=i.getPassRawResFromPool(s.uvTrans);let{meshes:v,geometryInfo:b}=this.sceneInfo;const{geometryIndexMap:L,geoInfoSplitIndex:S}=b,y=Float32Array.BYTES_PER_ELEMENT;this.camera.updateFrustum(),v=v.filter(M=>!M.tlasMask),v.forEach((M,T)=>{if(!M.visible)return;const _=fe.get(M.id);if(!_)return void console.error("Need build meshUniformBuffer first");if(!this.camera.frustumIntersectsMesh(M))return;this.updateMeshUniformBuffer(_,M,T);const B=M.geometry,P=L.get(B),{vertexSplitIndex:w,indicesSplitIndex:W}=S[P],I=w*y;o.setVertexBuffer(0,l,I,B.position.array.length*y),o.setVertexBuffer(1,c,I,B.normal.array.length*y),o.setVertexBuffer(2,d,I/3*2,B.uv.array.length*y),o.setIndexBuffer(h,"uint32",W*y,B.indices.array.length*y),o.setPipeline(a);const X=this.getBindGroup(M.id,{settingBuffer:f,meshUniformBuffer:_,material:m,textureArray:x,sampler:g,uvTrans:p});o.setBindGroup(0,X),o.drawIndexed(B.indices.count,1,0,0)}),o.end()}};let Te=Ee;Te.ID="GBufferPass";class Qt{constructor(e){this.device=e}async debugBufferContent(e,t,r=Uint32Array){const{device:s}=this,a=s.createCommandEncoder();this.debugBuffer=s.createBuffer({size:t,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),a.copyBufferToBuffer(e,0,this.debugBuffer,0,t),s.queue.submit([a.finish()]),await s.queue.onSubmittedWorkDone(),await this.debugBuffer.mapAsync(GPUMapMode.READ);const n=new r(this.debugBuffer.getMappedRange()),u=Array.from(n);return console.log(u),this.debugBuffer.unmap(),u}}var ps=()=>"@group(0)@binding(0)var inputTex : texture_2d<f32>;@group(0)@binding(1)var<uniform>setting : Setting;@group(0)@binding(2)var accumulateTex : texture_storage_2d<rgba32float,write>;@group(0)@binding(3)var outputTex : texture_storage_2d<rgba16float,write>;struct Setting{renderSize: vec2<u32>,}@compute @workgroup_size(8,8,1)fn main(@builtin(global_invocation_id)GlobalInvocationID : vec3<u32>){let screenSize=setting.renderSize;if(any(GlobalInvocationID.xy>screenSize)){return;}let screenPos=vec2<i32>(i32(GlobalInvocationID.x),i32(GlobalInvocationID.y));var color=textureLoad(inputTex,screenPos,0);textureStore(accumulateTex,screenPos,color);textureStore(outputTex,screenPos,color);}";const jt=class{constructor(i,e,t){this.device=i,this.context=e,this.rg=t}async createPipeline(i){this.renderSetting=i;const{rg:e}=this;this.settingBuffer=new Je(e,"PTAccumulatePassSettingBuffer","u32",2),this.renderSizeVal=[...i.renderSize],this.settingBuffer.setData(0,i.renderSize[0]),this.settingBuffer.setData(1,i.renderSize[1]),this.settingBuffer.submit(),await e.getOrCreateComputePipeline(jt.ID,"",ps())}syncRenderSetting(i){this.renderSetting=i}syncRenderSize(){const{settingBuffer:i,renderSizeVal:e,renderSetting:t}=this,r=t.renderSize;e[0]==r[0]&&e[1]==r[1]||(this.renderSizeVal=[...r],i.setData(0,r[0]),i.setData(1,r[1]),i.submit())}setup(i,e,t){const{context:r}=this,s={},a=i.getPass(ue.ID);s.input=e.read(a.data.output),s.settingBuffer=e.read(i.importResource("PTAccumulatePassSettingBuffer")),s.accumulate=e.write(i,a.data.accumulate);let n=i.createTexture("AccumulateOutputTexture",{size:{width:r.width,height:r.height},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING},!0);s.output=e.write(i,n),t.data=s}execute(i,e,t,r){const{renderSetting:s}=this,a=i.getComputePipeline(e.name,""),n=i.getBindGroup(e.name,a,t,e.data),{renderSize:u}=s,o=r.beginComputePass();o.setPipeline(a),o.setBindGroup(0,n),o.dispatchWorkgroups(Math.ceil(u[0]/8),Math.ceil(u[1]/8)),o.end()}};let xe=jt;xe.ID="PTAccumulatePass";const $t=class{constructor(i,e,t){this.device=i,this.context=e,this.rg=t,this.tileSetting={},this.tileSetting.enable=Qe}getPipelineCacheKey(i){const e={geoType:i.geoType,sceneMode:i.sceneMode,integrator:i.integrator,enableSSS:i.enableSSS,enableVolume:i.enableVolume,enableAtomsphere:i.enableAtomsphere};return JSON.stringify(Object.values(e))}async createPipeline(i){this.renderSetting=i;const{rg:e}=this,t=function(s){let a=[];if(a.push("var noiseTex : texture_2d<f32>;","var<uniform> frameUniform : FrameUniform;","var<uniform> sceneUniform : SceneUniform;","var<uniform> tileUniform : TileUniform;","var<uniform> stratifiedSamples : StratifiedSamplesUniforms;"),s.supportLightSource&&a.push("var<uniform> lights : Lights;"),a.push("var accumulateTex : texture_2d<f32>;"),s.geoType=="Mesh"){const u=["var<storage, read> position : array<array<f32, 3>>;","var<storage, read> normal : array<array<f32, 3>>;","var<storage, read> uv : array<array<f32, 2>>;"];s.sceneMode=="Static"?u.push("var<storage, read> indices : array<array<u32, 3>>;","var<storage, read> bvhNodes : array<BVHNode>;"):u.push("var<storage, read> tlasNodes : array<TLASNode>;","var<storage, read> blasNodes : array<BLASNode>;","var<storage, read> tlasTransNodes : array<TLASTransNode>;"),u.push("var<storage, read> materials : array<Material>;","var textureArray : texture_2d_array<f32>;"),(s.supportUVTrans||s.supportTexWrap)&&u.push("var<storage, read> texUVTrans : array<TexUVTrans>;"),a.push(...u)}a.push("var envMap : texture_2d<f32>;","var envMarginalWeights : texture_2d<f32>;","var envConditionalWeights : texture_2d<f32>;"),a.push("var lightTex : texture_storage_2d<rgba32float, write>;"),a.push("var texSampler : sampler;","var noiseSampler : sampler;");let n=function(u){let o="";for(let l=0;l<u.length;l++)o+=`@group(0) @binding(${l}) ${u[l]}
`;return o}(a);return z`
		${n}

		${Yt(z,s)}
		${Jr(z,s)}
		${Qr(z)}
		${jr(z)}

		${us(z)}

		${$r(z)}

		#if ${s.supportLightSource}
		${ns(z)}
		${os(z)}
		#endif

		${qt(z,s)}
		${Jt(z,s)}
		${es(z)}
		${ts(z,s)}
		${rs(z,s)}

		${ss(z)}
		
		#if ${s.sceneMode==="Static"}
		${as(z,s)}
		#else
		${is(z,s)}
		#endif

		${ls(z,s)}
		${cs(z,s)}
		`}(i),r=this.getPipelineCacheKey(i);await e.getOrCreateComputePipeline($t.ID,r,t)}syncTileRenderSetting(i,e,t,r,s){this.tileSetting={enable:i,tileXOffset:e,tileYOffset:t,tileWidth:r,tileHeight:s}}syncRenderSetting(i){this.renderSetting=i}setup(i,e,t){const{context:r,renderSetting:s}=this,a={},n=i.createTexture("NoiseTexture");a.noise=e.read(n),a.frameUniform=e.read(i.importResource(k.RES_NAME)),a.sceneUniform=e.read(i.importResource(E.RES_NAME)),a.tileUniform=e.read(i.importResource(Q.RES_NAME)),a.stratifiedSamples=e.read(i.importResource("StratifiedSamplesBuffer")),s.supportLightSource&&(a.light=e.read(i.importResource(ce)));const u=i.createTexture("PTAccumulateTexture",{size:{width:r.width,height:r.height},format:"rgba32float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING},!0);a.accumulate=e.read(u),a.position=e.read(i.importResource($)),a.normal=e.read(i.importResource(te)),a.uv=e.read(i.importResource(ee)),s.sceneMode=="Static"?(a.indices=e.read(i.importResource(se)),a.bvh=e.read(i.importResource(Oe))):(a.tlas=e.read(i.importResource(Le)),a.blas=e.read(i.importResource(ye)),a.tlasTrans=e.read(i.importResource(ae))),a.material=e.read(i.importResource(V)),a.textureArray=e.read(i.importResource(K)),(s.supportUVTrans||s.supportTexWrap)&&(a.uvTrans=e.read(i.importResource(H))),a.envMap=e.read(i.importResource(j.ENVMAP_RES_NAME)),a.envMarginalWeights=e.read(i.importResource(j.ENVMAP_MARGINAL_WEIGHTS_RES_NAME)),a.envConditionalWeights=e.read(i.importResource(j.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME));const o=i.createTexture("RTLightTexture",{size:{width:r.width,height:r.height},format:"rgba32float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING},!0);a.output=e.write(i,o),a.samplers=["llc","nnr"],a.pipelineCacheKey=this.getPipelineCacheKey(s),t.data=a}execute(i,e,t,r){const{renderSetting:s,tileSetting:a}=this,n=i.getComputePipeline(e.name,e.data.pipelineCacheKey),u=i.getBindGroup(e.name,n,t,e.data),o=r.beginComputePass();o.setPipeline(n),o.setBindGroup(0,u);const{renderSize:l}=s,{enable:c,tileHeight:d,tileWidth:h}=a;c?o.dispatchWorkgroups(Math.ceil(h/8),Math.ceil(d/8)):o.dispatchWorkgroups(Math.ceil(l[0]/8),Math.ceil(l[1]/8)),o.end()}};let ue=$t;ue.ID="PTPass";var ms=()=>"@group(0)@binding(0)var inputTex : texture_2d<f32>;@group(0)@binding(1)var output : texture_storage_2d<rgba16float,write>;@group(0)@binding(2)var<uniform>levelConstant : LevelConstant;@group(0)@binding(3)var<uniform>setting : Setting;@group(0)@binding(4)var<uniform>frameUniform : FrameUniform;@group(0)@binding(5)var<uniform>sceneUniform : SceneUniform;@group(0)@binding(6)var gBuffer: texture_2d<u32>;@group(0)@binding(7)var depthTex: texture_depth_2d;struct Setting{sigColor: f32,sigNormal: f32,sigPosition: f32,}struct LevelConstant{level: u32}fn LGL_BL(gi: GBufferInfoRec,texCoords: vec2<u32>)->vec3<f32>{var inputColor=textureLoad(inputTex,texCoords,0).rgb;var normal=gi.normal;var position=gi.position;var meshID=gi.meshID;if(!gi.hit){return inputColor;}var coord=vec2<i32>(texCoords);var size=vec2<i32>(texSize);var colorSum=vec3<f32>(0.);var weightSum=0.0;var stepwidth=1<<levelConstant.level;for(var j=-1;j<=1;j++){for(var i=-1;i<=1;i++){var kernelCoords=coord+vec2<i32>(i,j)*stepwidth;if(any(kernelCoords>size)||any(kernelCoords<vec2<i32>(0))){continue;}var uCoords=vec2<u32>(kernelCoords);var kernelGi=SampleGBuffer(uCoords,gBuffer,depthTex);var kernelPosition=kernelGi.position;var kernelNormal=kernelGi.normal;var kernelMeshID=kernelGi.meshID;var kernelColor=textureLoad(inputTex,uCoords,0).rgb;if(meshID!=kernelMeshID||!kernelGi.hit){continue;}let sigColor=max(setting.sigColor,1e-6);let dc=abs(LGL_M(inputColor)-LGL_M(kernelColor));var wc=exp(-dc/sigColor)+1e-4;let sigNormal=setting.sigNormal;let dn=dot(normal-kernelNormal,normal-kernelNormal);let wn=min(1.,exp(-dn/sigNormal));let sigPosition=setting.sigPosition;let dp=dot(position-kernelPosition,position-kernelPosition);let wp=exp(-dp/sigPosition)+1e-4;let kernelIndex=(j+1)*3+(i+1);var weight=wc*wn*wp*LGL_BB[kernelIndex];weightSum+=weight;colorSum+=kernelColor*weight;}}var res=colorSum/weightSum;if(res.x<0.||res.x>1e8){res=vec3<f32>(0.);}return res;}@compute @workgroup_size(8,8,1)fn main(@builtin(global_invocation_id)GlobalInvocationID : vec3<u32>){texSize=sceneUniform.renderSize;var texCoords=GlobalInvocationID.xy;if(any(GlobalInvocationID.xy>texSize)){return;}var gi=SampleGBuffer(texCoords,gBuffer,depthTex);var res=LGL_BL(gi,texCoords);textureStore(output,texCoords,vec4(res,1.));}";const er=class{constructor(i,e,t){this.device=i,this.context=e,this.rg=t,this.levelConstants=[],this.sigColor=Dt,this.sigNormal=Nt,this.sigPosition=At}async createPipeline(i){this.renderSetting=i;const{rg:e,levelConstants:t}=this;for(let r=0;r<4;r++){const s=new Je(e,`HybridDenoiselevelConstant-${r}`,"u32",1);s.setData(0,r),s.submit(),t.push(s)}this.settingBuffer=e.resourcePool.getOrCreateResource(J.RES_NAME,{size:J.getStride(),usage:J.RES_USAGE}).raw,this.updateSetting(),await e.getOrCreateComputePipeline(er.ID,"",`
			${ds()}
			${ms()}
			`)}updateSetting(){const{device:i,sigColor:e,sigNormal:t,sigPosition:r}=this,s=new J({sigColor:e,sigNormal:t,sigPosition:r}).toArrayBuffer();i.queue.writeBuffer(this.settingBuffer,0,s)}setInputPass(i){this.inputPass=this.rg.getPass(i)}setup(i,e,t){const{renderSetting:r,context:s}=this,a={};a.input=e.read(this.inputPass.data.output),a.settingBuffer=e.read(i.importResource(J.RES_NAME)),a.frameUniform=e.read(i.importResource(k.RES_NAME)),a.sceneUniform=e.read(i.importResource(E.RES_NAME)),a.levelConstants=[];for(let o=0;o<4;o++)a.levelConstants.push(i.importResource(`HybridDenoiselevelConstant-${o}`));const n=i.getPass(Te.ID);a.gBuffer=e.read(n.data.output),a.gBufferDepth=e.read(n.data.outputDepth);let u=i.createTexture("ATourOutputTex",{size:{width:s.width,height:s.height},format:"rgba16float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING},!0);a.output=e.write(i,u),t.data=a}execute(i,e,t,r){const{renderSetting:s}=this,a=e.data,n=i.getComputePipeline(e.name);for(let u=0;u<4;u++){let o=[];o=u%2==0?[a.input,a.output,a.levelConstants[u]]:[a.output,a.input,a.levelConstants[u]],o.push(a.settingBuffer,a.frameUniform,a.sceneUniform,a.gBuffer,a.gBufferDepth);const l=i.getBindGroupByHandles(`${e.name}-${u}`,n,o,e.data),c=8,{renderSize:d}=s,h=r.beginComputePass();h.setPipeline(n),h.setBindGroup(0,l),h.dispatchWorkgroups(Math.ceil(d[0]/c),Math.ceil(d[1]/c)),h.end()}}};let be=er;be.ID="AToursPass";var gs=()=>"@group(0)@binding(0)var inputTex : texture_2d<f32>;@group(0)@binding(1)var outputTex : texture_storage_2d<rgba16float,write>;@compute @workgroup_size(8,8,1)fn main(@builtin(global_invocation_id)GlobalInvocationID : vec3<u32>){let screenSize=textureDimensions(outputTex);if(any(GlobalInvocationID.xy>screenSize)){return;}let screenPos=vec2<i32>(i32(GlobalInvocationID.x),i32(GlobalInvocationID.y));var color=textureLoad(inputTex,screenPos,0);textureStore(outputTex,screenPos,color);}";const tr=class{constructor(i,e,t){this.device=i,this.context=e,this.rg=t}async createPipeline(i){const{rg:e}=this;this.renderSetting=i,await e.getOrCreateComputePipeline(tr.ID,"",gs())}setInputPass(i){this.inputPass=this.rg.getPass(i)}setup(i,e,t){const{context:r}=this,s={};s.input=e.read(this.inputPass.data.output);let a=i.createTexture("BlitConvertOutputTexture",{size:{width:r.width,height:r.height},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING},!0);s.output=e.write(i,a),t.data=s}execute(i,e,t,r){const{renderSetting:s}=this,a=i.getComputePipeline(e.name,""),n=i.getBindGroup(e.name,a,t,e.data),{renderSize:u}=s,o=r.beginComputePass();o.setPipeline(a),o.setBindGroup(0,n),o.dispatchWorkgroups(Math.ceil(u[0]/8),Math.ceil(u[1]/8)),o.end()}};let ve=tr;ve.ID="BlitConvertPass";class xs{constructor(e){this.device=e,this.radixSorter=new Nr(e),this.assignMortonPass=new Vr(e),this.constructNodesPass=new kr(e),this.internalNodePass=new Kr(e),this.buildAABBPass=new Zr(e),this.debugPass=new Qt(e)}calcAABB(e){const t=e.array,r=new N,s=new G;for(let a=0;a<e.count;a++)s.set(t[3*a],t[3*a+1],t[3*a+2]),r.min.min(s),r.max.max(s);return r}async build(e){const{device:t}=this,{position:r,uv:s,normal:a,indices:n,materialMeshIndex:u}=e.geometry,o=n.count/3,l=this.calcAABB(e.geometry.position);this.sceneAABBBuffer||(this.sceneAABBBuffer=new Dr(t)),this.sceneAABBBuffer.set(l,o),this.positionBuffer=t.createBuffer({mappedAtCreation:!0,size:r.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),new Float32Array(this.positionBuffer.getMappedRange()).set(r.array,0),this.positionBuffer.unmap(),this.uvBuffer=t.createBuffer({mappedAtCreation:!0,size:s.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),new Float32Array(this.uvBuffer.getMappedRange()).set(s.array,0),this.uvBuffer.unmap(),this.normalBuffer=t.createBuffer({mappedAtCreation:!0,size:a.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),new Float32Array(this.normalBuffer.getMappedRange()).set(a.array,0),this.normalBuffer.unmap(),this.indicesBuffer=t.createBuffer({mappedAtCreation:!0,size:n.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.INDEX}),new Uint32Array(this.indicesBuffer.getMappedRange()).set(n.array,0),this.indicesBuffer.unmap(),this.materialMeshIndexBuffer=t.createBuffer({mappedAtCreation:!0,size:u.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),new Uint32Array(this.materialMeshIndexBuffer.getMappedRange()).set(u.array,0),this.materialMeshIndexBuffer.unmap();const c=4*this.radixSorter.getAlignedSize(o);this.mortonBuffer=t.createBuffer({size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.idBuffer=t.createBuffer({size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});const d=48*(2*o-1);if(d>=Math.min(t.limits.maxBufferSize,t.limits.maxStorageBufferBindingSize))return void console.error("The total size of loaded models exceeds the browser limit!");this.bvhNodesBuffer=t.createBuffer({size:d,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),await this.assignMortonPass.compute(o,this.positionBuffer,this.indicesBuffer,this.sceneAABBBuffer.buffer,this.mortonBuffer,this.idBuffer),await this.radixSorter.sort(this.mortonBuffer,this.idBuffer,o),await this.constructNodesPass.compute(o,this.idBuffer,this.positionBuffer,this.indicesBuffer,this.materialMeshIndexBuffer,this.bvhNodesBuffer),await this.internalNodePass.compute(o,this.mortonBuffer,this.idBuffer,this.bvhNodesBuffer);const h=Math.ceil(Math.log2(o));for(let f=1;f<=h;f++)await this.buildAABBPass.compute(f,o,this.bvhNodesBuffer);return this.mortonBuffer.destroy(),this.idBuffer.destroy(),{positionBuffer:this.positionBuffer,uvBuffer:this.uvBuffer,normalBuffer:this.normalBuffer,indicesBuffer:this.indicesBuffer,bvhNodesBuffer:this.bvhNodesBuffer,materialMeshIndexBuffer:this.materialMeshIndexBuffer}}destory(){this.sceneAABBBuffer.destroy(),this.mortonBuffer.destroy(),this.idBuffer.destroy()}}function Mt(i,e,t=0,r=i.length,s=Math.floor((t+r)/2)){for(let a=t;a<=s;a++){let n=a,u=i[a];for(let o=a+1;o<r;o++)e(u,i[o])||(n=o,u=i[o],rr(i,a,n))}}function rr(i,e,t){const r=i[t];i[t]=i[e],i[e]=r}let sr,Ke=0,He=0,Ze=0,et=!1;const D=new G;function Gt(i,e){return{primitives:i,bounds:e}}function Tt(i,e,t){let r=t[e]-i.min[e];return i.max[e]>i.min[e]&&(r/=i.max[e]-i.min[e]),r}function Xe(i){return i.getSize(D),2*(D.x*D.z+D.x*D.y+D.z*D.y)}function _e(i,e,t,r=!1){const s=new N;for(let l=e;l<t;l++)s.union(i[l].bounds);et&&(Ze+=1,sr((Ze+He)/Ke));const a=t-e;if(a===1)return Gt(i.slice(e,t),s);{const l=new N;for(let h=e;h<t;h++)l.expandByPoint(i[h].center);const c=(l.getSize(D),D.x>D.z?D.x>D.y?"x":"y":D.z>D.y?"z":"y");let d=Math.floor((e+t)/2);if(a<=4)Mt(i,(h,f)=>h.center[c]<f.center[c],e,t,d);else if(l.max[c]===l.min[c]){if(!r)return Gt(i.slice(e,t),s);Mt(i,(h,f)=>h.center[c]<f.center[c],e,t,d)}else{const f=[];for(let p=0;p<12;p++)f.push({bounds:new N,count:0});for(let p=e;p<t;p++){let v=Math.floor(12*Tt(l,c,i[p].center));v===f.length&&(v=f.length-1),f[v].count++,f[v].bounds.union(i[p].bounds)}const m=[];for(let p=0;p<f.length-1;p++){const v=new N,b=new N;let L=0,S=0;for(let y=0;y<=p;y++)v.union(f[y].bounds),L+=f[y].count;for(let y=p+1;y<f.length;y++)b.union(f[y].bounds),S+=f[y].count;m.push(.1+(L*Xe(v)+S*Xe(b))/Xe(s))}let x=m[0],g=0;for(let p=1;p<m.length;p++)m[p]<x&&(x=m[p],g=p);d=function(p,v,b=0,L=p.length){for(;b!==L;){for(;v(p[b]);)if(++b===L)return b;do if(b===--L)return b;while(!v(p[L]));rr(p,b,L),b++}return b}(i,p=>{let v=Math.floor(f.length*Tt(l,c,p.center));return v===f.length&&(v=f.length-1),v<=g},e,t)}return n=c,u=_e(i,e,d,r),o=_e(i,d,t,r),{child0:u,child1:o,bounds:new N().union(u.bounds).union(o.bounds),splitAxis:n}}var n,u,o}function _t(i){const e=new Float32Array(32*i.length);for(let t=0;t<i.length;t++){const r=i[t],s=r.localToWorldMat,a=r.worldToLocalMat;for(let n=0;n<16;n++)e[32*t+n]=s[n],e[32*t+16+n]=a[n]}return e}function Pt(i,e,t){const r=function(s,a,n){const u=[];for(let o=0;o<s.length;o++){const l=s[o],{material:c,geometry:d}=l,h=new N;h.copy(d.aabb).applyMatrix4(l.localToWorldMat);const f={bounds:h,center:h.getCenter(new G),meshID:o,geometryID:a.get(d),materialID:n.get(c),visible:l.visible};u.push(f)}return u}(i,e,t);return et=!1,_e(r,0,r.length,!0)}function Bt(i,e,t){const{primitiveInfoArr:r}=function(a,n=0){let u=n;const o=[];for(let l=0;l<a.length;l++){const c=[],d=a[l],h=d.indices,f=d.position,m=new G,x=new G,g=new G;for(let p=0;p<h.array.length;p+=3){const v=h.array[p],b=h.array[p+1],L=h.array[p+2],S=new N,y=3,M=v*y;m.x=f.array[M],m.y=f.array[M+1],m.z=f.array[M+2];const T=b*y;x.x=f.array[T],x.y=f.array[T+1],x.z=f.array[T+2];const _=L*y;g.x=f.array[_],g.y=f.array[_+1],g.z=f.array[_+2],S.expandByPoint(m),S.expandByPoint(x),S.expandByPoint(g);const B={bounds:S,center:S.getCenter(new G),indices:[v+u,b+u,L+u]};c.push(B)}u+=d.position.array.length/3,o.push(c)}return{primitiveInfoArr:o}}(i,t),s=[];if(e){Ke=0,He=0,et=!0,sr=e;for(let a=0;a<r.length;a++)Ke+=2*r[a].length-1}for(let a=0;a<r.length;a++){const n=r[a];Ze=0;const u=_e(n,0,n.length);He+=2*n.length-1,s.push(u)}return{blasBVHs:s}}function ir(i,e=0,t=[]){const r=[];let s=1;const a={x:3,y:4,z:5},n=(u,o=1)=>{if(s=Math.max(o,s),u.primitives){const l=u;for(let c=0;c<l.primitives.length;c++){const d=l.primitives[c];if(d.indices!==void 0){const h=d;r.push(h.indices[0],h.indices[1],h.indices[2],1,0,0,0,0)}else{const h=d;r.push(t[h.geometryID],h.materialID,h.meshID,1,Number(h.visible),0,0,0)}}}else{const l=u,c=l.bounds;r.push(c.min.x,c.min.y,c.min.z,a[l.splitAxis],c.max.x,c.max.y,c.max.z,0);const d=r.length-1;n(l.child0,o+1),r[d]=r.length/8+e,n(l.child1,o+1)}};return n(i),{count:r.length/8,maxDepth:s,flatData:r}}function Rt(i,e){return ir(i,0,e)}function wt(i,e=0){const t=[];let r=[],s=1;for(let a=0;a<i.length;a++){const n=ir(i[a],e);s=Math.max(n.maxDepth,s),r.push(e),e+=n.count,t.push(n)}return{blasBufferSplitIndex:r,totalBLASDataLength:8*e,totalBLASDataCount:e,flatBVHInfos:t,maxDepth:s}}const ar="IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NvbnN0IHQ9MWUtNjtmdW5jdGlvbiBuKHQpe3JldHVybiB0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09MSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09MSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdH1mdW5jdGlvbiBpKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl0saD1uWzNdLG89bls0XSxhPW5bNV0sdT1uWzZdLGw9bls3XSxjPW5bOF0sbT1uWzldLGY9blsxMF0seD1uWzExXSx5PW5bMTJdLHA9blsxM10sZz1uWzE0XSxNPW5bMTVdLGQ9aVswXSx6PWlbMV0sdz1pWzJdLGI9aVszXTtyZXR1cm4gdFswXT1kKnMreipvK3cqYytiKnksdFsxXT1kKmUreiphK3cqbStiKnAsdFsyXT1kKnIreip1K3cqZitiKmcsdFszXT1kKmgreipsK3cqeCtiKk0sZD1pWzRdLHo9aVs1XSx3PWlbNl0sYj1pWzddLHRbNF09ZCpzK3oqbyt3KmMrYip5LHRbNV09ZCplK3oqYSt3Km0rYipwLHRbNl09ZCpyK3oqdSt3KmYrYipnLHRbN109ZCpoK3oqbCt3KngrYipNLGQ9aVs4XSx6PWlbOV0sdz1pWzEwXSxiPWlbMTFdLHRbOF09ZCpzK3oqbyt3KmMrYip5LHRbOV09ZCplK3oqYSt3Km0rYipwLHRbMTBdPWQqcit6KnUrdypmK2IqZyx0WzExXT1kKmgreipsK3cqeCtiKk0sZD1pWzEyXSx6PWlbMTNdLHc9aVsxNF0sYj1pWzE1XSx0WzEyXT1kKnMreipvK3cqYytiKnksdFsxM109ZCplK3oqYSt3Km0rYipwLHRbMTRdPWQqcit6KnUrdypmK2IqZyx0WzE1XT1kKmgreipsK3cqeCtiKk0sdH1mdW5jdGlvbiBzKHQsbil7bGV0IGk9blswXStuWzVdK25bMTBdLHM9MDtyZXR1cm4gaT4wPyhzPTIqTWF0aC5zcXJ0KGkrMSksdFszXT0uMjUqcyx0WzBdPShuWzZdLW5bOV0pL3MsdFsxXT0obls4XS1uWzJdKS9zLHRbMl09KG5bMV0tbls0XSkvcyk6blswXT5uWzVdJiZuWzBdPm5bMTBdPyhzPTIqTWF0aC5zcXJ0KDErblswXS1uWzVdLW5bMTBdKSx0WzNdPShuWzZdLW5bOV0pL3MsdFswXT0uMjUqcyx0WzFdPShuWzFdK25bNF0pL3MsdFsyXT0obls4XStuWzJdKS9zKTpuWzVdPm5bMTBdPyhzPTIqTWF0aC5zcXJ0KDErbls1XS1uWzBdLW5bMTBdKSx0WzNdPShuWzhdLW5bMl0pL3MsdFswXT0oblsxXStuWzRdKS9zLHRbMV09LjI1KnMsdFsyXT0obls2XStuWzldKS9zKToocz0yKk1hdGguc3FydCgxK25bMTBdLW5bMF0tbls1XSksdFszXT0oblsxXS1uWzRdKS9zLHRbMF09KG5bOF0rblsyXSkvcyx0WzFdPShuWzZdK25bOV0pL3MsdFsyXT0uMjUqcyksdH1mdW5jdGlvbiBlKHQsbil7bGV0IGk9blswXSxzPW5bMV0sZT1uWzJdLHI9blszXSxoPWkraSxvPXMrcyxhPWUrZSx1PWkqaCxsPXMqaCxjPXMqbyxtPWUqaCxmPWUqbyx4PWUqYSx5PXIqaCxwPXIqbyxnPXIqYTtyZXR1cm4gdFswXT0xLWMteCx0WzFdPWwrZyx0WzJdPW0tcCx0WzNdPTAsdFs0XT1sLWcsdFs1XT0xLXUteCx0WzZdPWYreSx0WzddPTAsdFs4XT1tK3AsdFs5XT1mLXksdFsxMF09MS11LWMsdFsxMV09MCx0WzEyXT0wLHRbMTNdPTAsdFsxNF09MCx0WzE1XT0xLHR9ZnVuY3Rpb24gcih0LG4saSl7cmV0dXJuIHRbMF09blswXStpWzBdLHRbMV09blsxXStpWzFdLHRbMl09blsyXStpWzJdLHR9ZnVuY3Rpb24gaCh0LG4saSl7cmV0dXJuIHRbMF09blswXS1pWzBdLHRbMV09blsxXS1pWzFdLHRbMl09blsyXS1pWzJdLHR9ZnVuY3Rpb24gbyh0LG4saSl7cmV0dXJuIHRbMF09blswXSppLHRbMV09blsxXSppLHRbMl09blsyXSppLHR9ZnVuY3Rpb24gYSh0LG4pe2xldCBpPW5bMF0scz1uWzFdLGU9blsyXSxyPWkqaStzKnMrZSplO3JldHVybiByPjAmJihyPTEvTWF0aC5zcXJ0KHIpLHRbMF09blswXSpyLHRbMV09blsxXSpyLHRbMl09blsyXSpyKSx0fWZ1bmN0aW9uIHUodCxuKXtyZXR1cm4gdFswXSpuWzBdK3RbMV0qblsxXSt0WzJdKm5bMl19bmV3IGNsYXNzIGV4dGVuZHMgQXJyYXl7Y29uc3RydWN0b3IodD0xLG49MCxpPTAscz0wLGU9MCxyPTEsaD0wLG89MCxhPTAsdT0wLGw9MSxjPTAsbT0wLGY9MCx4PTAseT0xKXtyZXR1cm4gc3VwZXIodCxuLGkscyxlLHIsaCxvLGEsdSxsLGMsbSxmLHgseSksdGhpc31nZXQgaXNNYXRyaXg0KCl7cmV0dXJuITB9c2V0IHgodCl7dGhpc1sxMl09dH1nZXQgeCgpe3JldHVybiB0aGlzWzEyXX1zZXQgeSh0KXt0aGlzWzEzXT10fWdldCB5KCl7cmV0dXJuIHRoaXNbMTNdfXNldCB6KHQpe3RoaXNbMTRdPXR9Z2V0IHooKXtyZXR1cm4gdGhpc1sxNF19c2V0IHcodCl7dGhpc1sxNV09dH1nZXQgdygpe3JldHVybiB0aGlzWzE1XX1zZXQodCxuLGkscyxlLHIsaCxvLGEsdSxsLGMsbSxmLHgseSl7cmV0dXJuIHQubGVuZ3RoP3RoaXMuY29weSh0KTooZnVuY3Rpb24odCxuLGkscyxlLHIsaCxvLGEsdSxsLGMsbSxmLHgseSxwKXt0WzBdPW4sdFsxXT1pLHRbMl09cyx0WzNdPWUsdFs0XT1yLHRbNV09aCx0WzZdPW8sdFs3XT1hLHRbOF09dSx0WzldPWwsdFsxMF09Yyx0WzExXT1tLHRbMTJdPWYsdFsxM109eCx0WzE0XT15LHRbMTVdPXB9KHRoaXMsdCxuLGkscyxlLHIsaCxvLGEsdSxsLGMsbSxmLHgseSksdGhpcyl9dHJhbnNsYXRlKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzLGUscixoLG8sYSx1LGwsYyxtLGYseCx5PWlbMF0scD1pWzFdLGc9aVsyXTtuPT09dD8odFsxMl09blswXSp5K25bNF0qcCtuWzhdKmcrblsxMl0sdFsxM109blsxXSp5K25bNV0qcCtuWzldKmcrblsxM10sdFsxNF09blsyXSp5K25bNl0qcCtuWzEwXSpnK25bMTRdLHRbMTVdPW5bM10qeStuWzddKnArblsxMV0qZytuWzE1XSk6KHM9blswXSxlPW5bMV0scj1uWzJdLGg9blszXSxvPW5bNF0sYT1uWzVdLHU9bls2XSxsPW5bN10sYz1uWzhdLG09bls5XSxmPW5bMTBdLHg9blsxMV0sdFswXT1zLHRbMV09ZSx0WzJdPXIsdFszXT1oLHRbNF09byx0WzVdPWEsdFs2XT11LHRbN109bCx0WzhdPWMsdFs5XT1tLHRbMTBdPWYsdFsxMV09eCx0WzEyXT1zKnkrbypwK2MqZytuWzEyXSx0WzEzXT1lKnkrYSpwK20qZytuWzEzXSx0WzE0XT1yKnkrdSpwK2YqZytuWzE0XSx0WzE1XT1oKnkrbCpwK3gqZytuWzE1XSl9KHRoaXMsbix0KSx0aGlzfXJvdGF0ZVgodCxuPXRoaXMpe3JldHVybiBmdW5jdGlvbih0LG4saSl7bGV0IHM9TWF0aC5zaW4oaSksZT1NYXRoLmNvcyhpKSxyPW5bNF0saD1uWzVdLG89bls2XSxhPW5bN10sdT1uWzhdLGw9bls5XSxjPW5bMTBdLG09blsxMV07biE9PXQmJih0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV0pLHRbNF09ciplK3Uqcyx0WzVdPWgqZStsKnMsdFs2XT1vKmUrYypzLHRbN109YSplK20qcyx0WzhdPXUqZS1yKnMsdFs5XT1sKmUtaCpzLHRbMTBdPWMqZS1vKnMsdFsxMV09bSplLWEqc30odGhpcyxuLHQpLHRoaXN9cm90YXRlWSh0LG49dGhpcyl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1NYXRoLnNpbihpKSxlPU1hdGguY29zKGkpLHI9blswXSxoPW5bMV0sbz1uWzJdLGE9blszXSx1PW5bOF0sbD1uWzldLGM9blsxMF0sbT1uWzExXTtuIT09dCYmKHRbNF09bls0XSx0WzVdPW5bNV0sdFs2XT1uWzZdLHRbN109bls3XSx0WzEyXT1uWzEyXSx0WzEzXT1uWzEzXSx0WzE0XT1uWzE0XSx0WzE1XT1uWzE1XSksdFswXT1yKmUtdSpzLHRbMV09aCplLWwqcyx0WzJdPW8qZS1jKnMsdFszXT1hKmUtbSpzLHRbOF09cipzK3UqZSx0WzldPWgqcytsKmUsdFsxMF09bypzK2MqZSx0WzExXT1hKnMrbSplfSh0aGlzLG4sdCksdGhpc31yb3RhdGVaKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPU1hdGguc2luKGkpLGU9TWF0aC5jb3MoaSkscj1uWzBdLGg9blsxXSxvPW5bMl0sYT1uWzNdLHU9bls0XSxsPW5bNV0sYz1uWzZdLG09bls3XTtuIT09dCYmKHRbOF09bls4XSx0WzldPW5bOV0sdFsxMF09blsxMF0sdFsxMV09blsxMV0sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV0pLHRbMF09ciplK3Uqcyx0WzFdPWgqZStsKnMsdFsyXT1vKmUrYypzLHRbM109YSplK20qcyx0WzRdPXUqZS1yKnMsdFs1XT1sKmUtaCpzLHRbNl09YyplLW8qcyx0WzddPW0qZS1hKnN9KHRoaXMsbix0KSx0aGlzfXNjYWxlKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPWlbMF0sZT1pWzFdLHI9aVsyXTt0WzBdPW5bMF0qcyx0WzFdPW5bMV0qcyx0WzJdPW5bMl0qcyx0WzNdPW5bM10qcyx0WzRdPW5bNF0qZSx0WzVdPW5bNV0qZSx0WzZdPW5bNl0qZSx0WzddPW5bN10qZSx0WzhdPW5bOF0qcix0WzldPW5bOV0qcix0WzEwXT1uWzEwXSpyLHRbMTFdPW5bMTFdKnIsdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV19KHRoaXMsbiwibnVtYmVyIj09dHlwZW9mIHQ/W3QsdCx0XTp0KSx0aGlzfW11bHRpcGx5KHQsbil7cmV0dXJuIG4/aSh0aGlzLHQsbik6aSh0aGlzLHRoaXMsdCksdGhpc31pZGVudGl0eSgpe3JldHVybiBuKHRoaXMpLHRoaXN9Y29weSh0KXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09aVswXSxuWzFdPWlbMV0sblsyXT1pWzJdLG5bM109aVszXSxuWzRdPWlbNF0sbls1XT1pWzVdLG5bNl09aVs2XSxuWzddPWlbN10sbls4XT1pWzhdLG5bOV09aVs5XSxuWzEwXT1pWzEwXSxuWzExXT1pWzExXSxuWzEyXT1pWzEyXSxuWzEzXT1pWzEzXSxuWzE0XT1pWzE0XSxuWzE1XT1pWzE1XSx0aGlzfWZyb21QZXJzcGVjdGl2ZSh7Zm92OnQsYXNwZWN0Om4sbmVhcjppLGZhcjpzfT17fSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMsZSl7bGV0IHI9MS9NYXRoLnRhbihuLzIpLGg9MS8ocy1lKTt0WzBdPXIvaSx0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPTAsdFs1XT1yLHRbNl09MCx0WzddPTAsdFs4XT0wLHRbOV09MCx0WzEwXT0oZStzKSpoLHRbMTFdPS0xLHRbMTJdPTAsdFsxM109MCx0WzE0XT0yKmUqcypoLHRbMTVdPTB9KHRoaXMsdCxuLGkscyksdGhpc31mcm9tT3J0aG9nb25hbCh7bGVmdDp0LHJpZ2h0Om4sYm90dG9tOmksdG9wOnMsbmVhcjplLGZhcjpyfSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMsZSxyLGgpe2xldCBvPTEvKG4taSksYT0xLyhzLWUpLHU9MS8oci1oKTt0WzBdPS0yKm8sdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09LTIqYSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09Mip1LHRbMTFdPTAsdFsxMl09KG4raSkqbyx0WzEzXT0oZStzKSphLHRbMTRdPShoK3IpKnUsdFsxNV09MX0odGhpcyx0LG4saSxzLGUsciksdGhpc31mcm9tUXVhdGVybmlvbih0KXtyZXR1cm4gZSh0aGlzLHQpLHRoaXN9c2V0UG9zaXRpb24odCl7cmV0dXJuIHRoaXMueD10WzBdLHRoaXMueT10WzFdLHRoaXMuej10WzJdLHRoaXN9dHJhbnNwb3NlKHQ9dGhpcyl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7aWYodD09PW4pe2xldCBpPW5bMV0scz1uWzJdLGU9blszXSxyPW5bNl0saD1uWzddLG89blsxMV07dFsxXT1uWzRdLHRbMl09bls4XSx0WzNdPW5bMTJdLHRbNF09aSx0WzZdPW5bOV0sdFs3XT1uWzEzXSx0WzhdPXMsdFs5XT1yLHRbMTFdPW5bMTRdLHRbMTJdPWUsdFsxM109aCx0WzE0XT1vfWVsc2UgdFswXT1uWzBdLHRbMV09bls0XSx0WzJdPW5bOF0sdFszXT1uWzEyXSx0WzRdPW5bMV0sdFs1XT1uWzVdLHRbNl09bls5XSx0WzddPW5bMTNdLHRbOF09blsyXSx0WzldPW5bNl0sdFsxMF09blsxMF0sdFsxMV09blsxNF0sdFsxMl09blszXSx0WzEzXT1uWzddLHRbMTRdPW5bMTFdLHRbMTVdPW5bMTVdfSh0aGlzLHQpLHRoaXN9aW52ZXJzZSh0PXRoaXMpe3JldHVybiBmdW5jdGlvbih0LG4pe2xldCBpPW5bMF0scz1uWzFdLGU9blsyXSxyPW5bM10saD1uWzRdLG89bls1XSxhPW5bNl0sdT1uWzddLGw9bls4XSxjPW5bOV0sbT1uWzEwXSxmPW5bMTFdLHg9blsxMl0seT1uWzEzXSxwPW5bMTRdLGc9blsxNV0sTT1pKm8tcypoLGQ9aSphLWUqaCx6PWkqdS1yKmgsdz1zKmEtZSpvLGI9cyp1LXIqbyx2PWUqdS1yKmEscT1sKnktYyp4LEE9bCpwLW0qeCxCPWwqZy1mKngsST1jKnAtbSp5LFA9YypnLWYqeSxTPW0qZy1mKnAsRD1NKlMtZCpQK3oqSSt3KkItYipBK3YqcTtEJiYoRD0xL0QsdFswXT0obypTLWEqUCt1KkkpKkQsdFsxXT0oZSpQLXMqUy1yKkkpKkQsdFsyXT0oeSp2LXAqYitnKncpKkQsdFszXT0obSpiLWMqdi1mKncpKkQsdFs0XT0oYSpCLWgqUy11KkEpKkQsdFs1XT0oaSpTLWUqQityKkEpKkQsdFs2XT0ocCp6LXgqdi1nKmQpKkQsdFs3XT0obCp2LW0qeitmKmQpKkQsdFs4XT0oaCpQLW8qQit1KnEpKkQsdFs5XT0ocypCLWkqUC1yKnEpKkQsdFsxMF09KHgqYi15KnorZypNKSpELHRbMTFdPShjKnotbCpiLWYqTSkqRCx0WzEyXT0obypBLWgqSS1hKnEpKkQsdFsxM109KGkqSS1zKkErZSpxKSpELHRbMTRdPSh5KmQteCp3LXAqTSkqRCx0WzE1XT0obCp3LWMqZCttKk0pKkQpfSh0aGlzLHQpLHRoaXN9Y29tcG9zZSh0LG4saSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMpe2xldCBlPW5bMF0scj1uWzFdLGg9blsyXSxvPW5bM10sYT1lK2UsdT1yK3IsbD1oK2gsYz1lKmEsbT1lKnUsZj1lKmwseD1yKnUseT1yKmwscD1oKmwsZz1vKmEsTT1vKnUsZD1vKmwsej1zWzBdLHc9c1sxXSxiPXNbMl07dFswXT0oMS0oeCtwKSkqeix0WzFdPShtK2QpKnosdFsyXT0oZi1NKSp6LHRbM109MCx0WzRdPShtLWQpKncsdFs1XT0oMS0oYytwKSkqdyx0WzZdPSh5K2cpKncsdFs3XT0wLHRbOF09KGYrTSkqYix0WzldPSh5LWcpKmIsdFsxMF09KDEtKGMreCkpKmIsdFsxMV09MCx0WzEyXT1pWzBdLHRbMTNdPWlbMV0sdFsxNF09aVsyXSx0WzE1XT0xfSh0aGlzLHQsbixpKSx0aGlzfWdldFJvdGF0aW9uKHQpe3JldHVybiBzKHQsdGhpcyksdGhpc31leHRyYWN0Um90YXRpb24odCl7bGV0IG49W107cmV0dXJuIHMobix0KSxlKHRoaXMsbiksdGhpc31mcm9tUm90YXRpb24obixpKXtyZXR1cm4gZnVuY3Rpb24obixpLHMpe2xldCBlLHIsaCxvPXNbMF0sYT1zWzFdLHU9c1syXSxsPU1hdGguc3FydChvKm8rYSphK3UqdSk7TWF0aC5hYnMobCk8dHx8KGw9MS9sLG8qPWwsYSo9bCx1Kj1sLGU9TWF0aC5zaW4oaSkscj1NYXRoLmNvcyhpKSxoPTEtcixuWzBdPW8qbypoK3IsblsxXT1hKm8qaCt1KmUsblsyXT11Km8qaC1hKmUsblszXT0wLG5bNF09byphKmgtdSplLG5bNV09YSphKmgrcixuWzZdPXUqYSpoK28qZSxuWzddPTAsbls4XT1vKnUqaCthKmUsbls5XT1hKnUqaC1vKmUsblsxMF09dSp1KmgrcixuWzExXT0wLG5bMTJdPTAsblsxM109MCxuWzE0XT0wLG5bMTVdPTEpfSh0aGlzLG4saSksdGhpc31nZXRUcmFuc2xhdGlvbih0KXt2YXIgbixpO3JldHVybiBpPXRoaXMsKG49dClbMF09aVsxMl0sblsxXT1pWzEzXSxuWzJdPWlbMTRdLHRoaXN9Z2V0U2NhbGluZyh0KXtyZXR1cm4gZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLHM9blsxXSxlPW5bMl0scj1uWzRdLGg9bls1XSxvPW5bNl0sYT1uWzhdLHU9bls5XSxsPW5bMTBdO3RbMF09TWF0aC5zcXJ0KGkqaStzKnMrZSplKSx0WzFdPU1hdGguc3FydChyKnIraCpoK28qbyksdFsyXT1NYXRoLnNxcnQoYSphK3UqdStsKmwpfSh0LHRoaXMpLHRoaXN9Z2V0TWF4U2NhbGVPbkF4aXMoKXtyZXR1cm4gZnVuY3Rpb24odCl7bGV0IG49dFswXSxpPXRbMV0scz10WzJdLGU9dFs0XSxyPXRbNV0saD10WzZdLG89dFs4XSxhPXRbOV0sdT10WzEwXTtjb25zdCBsPW4qbitpKmkrcypzLGM9ZSplK3IqcitoKmgsbT1vKm8rYSphK3UqdTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KGwsYyxtKSl9KHRoaXMpfWxvb2tBdCh0LG4saSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMpe2xldCBlPW5bMF0scj1uWzFdLGg9blsyXSxvPXNbMF0sYT1zWzFdLHU9c1syXSxsPWUtaVswXSxjPXItaVsxXSxtPWgtaVsyXSxmPWwqbCtjKmMrbSptO2Y+MCYmKGY9MS9NYXRoLnNxcnQoZiksbCo9ZixjKj1mLG0qPWYpO2xldCB4PWEqbS11KmMseT11KmwtbyptLHA9bypjLWEqbDtmPXgqeCt5KnkrcCpwLGY+MCYmKGY9MS9NYXRoLnNxcnQoZikseCo9Zix5Kj1mLHAqPWYpLHRbMF09eCx0WzFdPXksdFsyXT1wLHRbM109MCx0WzRdPWMqcC1tKnksdFs1XT1tKngtbCpwLHRbNl09bCp5LWMqeCx0WzddPTAsdFs4XT1sLHRbOV09Yyx0WzEwXT1tLHRbMTFdPTAsdFsxMl09ZSx0WzEzXT1yLHRbMTRdPWgsdFsxNV09MX0odGhpcyx0LG4saSksdGhpc31sb29rQXRUYXJnZXQoaSxzLGUpe3JldHVybiBmdW5jdGlvbihpLHMsZSxyKXtsZXQgaCxvLGEsdSxsLGMsbSxmLHgseSxwPXNbMF0sZz1zWzFdLE09c1syXSxkPXJbMF0sej1yWzFdLHc9clsyXSxiPWVbMF0sdj1lWzFdLHE9ZVsyXTtNYXRoLmFicyhwLWIpPHQmJk1hdGguYWJzKGctdik8dCYmTWF0aC5hYnMoTS1xKTx0P24oaSk6KG09cC1iLGY9Zy12LHg9TS1xLHk9MS9NYXRoLnNxcnQobSptK2YqZit4KngpLG0qPXksZio9eSx4Kj15LGg9eip4LXcqZixvPXcqbS1kKngsYT1kKmYteiptLHk9TWF0aC5zcXJ0KGgqaCtvKm8rYSphKSx5Pyh5PTEveSxoKj15LG8qPXksYSo9eSk6KGg9MCxvPTAsYT0wKSx1PWYqYS14Km8sbD14KmgtbSphLGM9bSpvLWYqaCx5PU1hdGguc3FydCh1KnUrbCpsK2MqYykseT8oeT0xL3ksdSo9eSxsKj15LGMqPXkpOih1PTAsbD0wLGM9MCksaVswXT1oLGlbMV09dSxpWzJdPW0saVszXT0wLGlbNF09byxpWzVdPWwsaVs2XT1mLGlbN109MCxpWzhdPWEsaVs5XT1jLGlbMTBdPXgsaVsxMV09MCxpWzEyXT0tKGgqcCtvKmcrYSpNKSxpWzEzXT0tKHUqcCtsKmcrYypNKSxpWzE0XT0tKG0qcCtmKmcreCpNKSxpWzE1XT0xKX0odGhpcyxpLHMsZSksdGhpc31kZXRlcm1pbmFudCgpe3JldHVybiBmdW5jdGlvbih0KXtsZXQgbj10WzBdLGk9dFsxXSxzPXRbMl0sZT10WzNdLHI9dFs0XSxoPXRbNV0sbz10WzZdLGE9dFs3XSx1PXRbOF0sbD10WzldLGM9dFsxMF0sbT10WzExXSxmPXRbMTJdLHg9dFsxM10seT10WzE0XSxwPXRbMTVdO3JldHVybihuKmgtaSpyKSooYypwLW0qeSktKG4qby1zKnIpKihsKnAtbSp4KSsobiphLWUqcikqKGwqeS1jKngpKyhpKm8tcypoKSoodSpwLW0qZiktKGkqYS1lKmgpKih1KnktYypmKSsocyphLWUqbykqKHUqeC1sKmYpfSh0aGlzKX1mcm9tQXJyYXkodCxuPTApe2Zvcih2YXIgaT0wO2k8MTY7aSsrKXRoaXNbaV09dFtpK25dO3JldHVybiB0aGlzfXRvQXJyYXkodD1bXSxuPTApe2xldCBpPXRoaXM7cmV0dXJuIHRbbl09aVswXSx0W24rMV09aVsxXSx0W24rMl09aVsyXSx0W24rM109aVszXSx0W24rNF09aVs0XSx0W24rNV09aVs1XSx0W24rNl09aVs2XSx0W24rN109aVs3XSx0W24rOF09aVs4XSx0W24rOV09aVs5XSx0W24rMTBdPWlbMTBdLHRbbisxMV09aVsxMV0sdFtuKzEyXT1pWzEyXSx0W24rMTNdPWlbMTNdLHRbbisxNF09aVsxNF0sdFtuKzE1XT1pWzE1XSx0fXN0YXRpYyBjb3B5VG8odD1bXSxuPVtdKXt0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFs0XT1uWzRdLHRbNV09bls1XSx0WzZdPW5bNl0sdFs3XT1uWzddLHRbOF09bls4XSx0WzldPW5bOV0sdFsxMF09blsxMF0sdFsxMV09blsxMV0sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV19fTtjbGFzcyBsIGV4dGVuZHMgQXJyYXl7Y29uc3RydWN0b3IodD0wLG49dCxpPXQpe3JldHVybiBzdXBlcih0LG4saSksdGhpcy5jb25zdGFudD0xLHRoaXN9Z2V0IGlzVmVjdG9yMygpe3JldHVybiEwfWdldCB4KCl7cmV0dXJuIHRoaXNbMF19c2V0IHgodCl7dGhpc1swXT10fWdldCB5KCl7cmV0dXJuIHRoaXNbMV19c2V0IHkodCl7dGhpc1sxXT10fWdldCB6KCl7cmV0dXJuIHRoaXNbMl19c2V0IHoodCl7dGhpc1syXT10fXNldCh0LG49dCxpPXQpe3JldHVybiB0Lmxlbmd0aD90aGlzLmNvcHkodCk6KGZ1bmN0aW9uKHQsbixpLHMpe3RbMF09bix0WzFdPWksdFsyXT1zfSh0aGlzLHQsbixpKSx0aGlzKX1jb3B5KHQpe3ZhciBuLGk7cmV0dXJuIGk9dCwobj10aGlzKVswXT1pWzBdLG5bMV09aVsxXSxuWzJdPWlbMl0sdGhpc31hZGQodCxuKXtyZXR1cm4gbj9yKHRoaXMsdCxuKTpyKHRoaXMsdGhpcyx0KSx0aGlzfXN1Yih0LG4pe3JldHVybiBuP2godGhpcyx0LG4pOmgodGhpcyx0aGlzLHQpLHRoaXN9bXVsdGlwbHkodCl7dmFyIG4saSxzO3JldHVybiB0Lmxlbmd0aD8oaT10aGlzLHM9dCwobj10aGlzKVswXT1pWzBdKnNbMF0sblsxXT1pWzFdKnNbMV0sblsyXT1pWzJdKnNbMl0pOm8odGhpcyx0aGlzLHQpLHRoaXN9ZGl2aWRlKHQpe3ZhciBuLGkscztyZXR1cm4gdC5sZW5ndGg/KGk9dGhpcyxzPXQsKG49dGhpcylbMF09aVswXS9zWzBdLG5bMV09aVsxXS9zWzFdLG5bMl09aVsyXS9zWzJdKTpvKHRoaXMsdGhpcywxL3QpLHRoaXN9c2NhbGUodCl7cmV0dXJuIG8odGhpcyx0aGlzLHQpLHRoaXN9ZGlzdGFuY2UodCl7cmV0dXJuIHQ/ZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLXRbMF0scz1uWzFdLXRbMV0sZT1uWzJdLXRbMl07cmV0dXJuIE1hdGguc3FydChpKmkrcypzK2UqZSl9KHRoaXMsdCk6ZnVuY3Rpb24odCl7bGV0IG49dFswXSxpPXRbMV0scz10WzJdO3JldHVybiBNYXRoLnNxcnQobipuK2kqaStzKnMpfSh0aGlzKX1zcXVhcmVkRGlzdGFuY2UodCl7cmV0dXJuIHQ/ZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLXRbMF0scz1uWzFdLXRbMV0sZT1uWzJdLXRbMl07cmV0dXJuIGkqaStzKnMrZSplfSh0aGlzLHQpOmZ1bmN0aW9uKHQpe2xldCBuPXRbMF0saT10WzFdLHM9dFsyXTtyZXR1cm4gbipuK2kqaStzKnN9KHRoaXMpfXNxdWFyZWRMZW5ndGgoKXtyZXR1cm4gdGhpcy5zcXVhcmVkRGlzdGFuY2UoKX1uZWdhdGUodD10aGlzKXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09LWlbMF0sblsxXT0taVsxXSxuWzJdPS1pWzJdLHRoaXN9cmVmbGVjdCh0KXtsZXQgbj10LmNsb25lKCk7cmV0dXJuIHRoaXMuc3ViKG4ubXVsdGlwbHkoMip0aGlzLmRvdCh0KSkpfWludmVyc2UodD10aGlzKXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09MS9pWzBdLG5bMV09MS9pWzFdLG5bMl09MS9pWzJdLHRoaXN9bm9ybWFsaXplKCl7cmV0dXJuIGEodGhpcyx0aGlzKSx0aGlzfWRvdCh0KXtyZXR1cm4gdSh0aGlzLHQpfWNyb3NzKHQsbil7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl0saD1pWzBdLG89aVsxXSxhPWlbMl07dFswXT1lKmEtcipvLHRbMV09cipoLXMqYSx0WzJdPXMqby1lKmh9KHRoaXMsdCxuKSx0aGlzfWxlcnAodCxuLGkpe3JldHVybiBmdW5jdGlvbih0LG4saSxzKXtsZXQgZT1uWzBdLHI9blsxXSxoPW5bMl07dFswXT1lK3MqKGlbMF0tZSksdFsxXT1yK3MqKGlbMV0tciksdFsyXT1oK3MqKGlbMl0taCl9KHRoaXMsdCxuLGkpLHRoaXN9aGVybWl0ZSh0LG4saSxzLGUpe3JldHVybiBmdW5jdGlvbih0LG4saSxzLGUscil7bGV0IGg9cipyLG89aCooMipyLTMpKzEsYT1oKihyLTIpK3IsdT1oKihyLTEpLGw9aCooMy0yKnIpO3RbMF09blswXSpvK2lbMF0qYStzWzBdKnUrZVswXSpsLHRbMV09blsxXSpvK2lbMV0qYStzWzFdKnUrZVsxXSpsLHRbMl09blsyXSpvK2lbMl0qYStzWzJdKnUrZVsyXSpsfSh0aGlzLHQsbixpLHMsZSksdGhpc31iZXppZXIodCxuLGkscyxlKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkscyxlLHIpe2xldCBoPTEtcixvPWgqaCxhPXIqcix1PW8qaCxsPTMqcipvLGM9MyphKmgsbT1hKnI7dFswXT1uWzBdKnUraVswXSpsK3NbMF0qYytlWzBdKm0sdFsxXT1uWzFdKnUraVsxXSpsK3NbMV0qYytlWzFdKm0sdFsyXT1uWzJdKnUraVsyXSpsK3NbMl0qYytlWzJdKm19KHRoaXMsdCxuLGkscyxlKSx0aGlzfWFwcGx5TWF0cml4NCh0KXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPW5bMF0sZT1uWzFdLHI9blsyXSxoPWlbM10qcytpWzddKmUraVsxMV0qcitpWzE1XTtoPWh8fDEsdFswXT0oaVswXSpzK2lbNF0qZStpWzhdKnIraVsxMl0pL2gsdFsxXT0oaVsxXSpzK2lbNV0qZStpWzldKnIraVsxM10pL2gsdFsyXT0oaVsyXSpzK2lbNl0qZStpWzEwXSpyK2lbMTRdKS9ofSh0aGlzLHRoaXMsdCksdGhpc31hcHBseU1hdHJpeDModCl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl07dFswXT1zKmlbMF0rZSppWzNdK3IqaVs2XSx0WzFdPXMqaVsxXStlKmlbNF0rcippWzddLHRbMl09cyppWzJdK2UqaVs1XStyKmlbOF19KHRoaXMsdGhpcyx0KSx0aGlzfWFwcGx5UXVhdGVybmlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPW5bMF0sZT1uWzFdLHI9blsyXSxoPWlbMF0sbz1pWzFdLGE9aVsyXSx1PWlbM10sbD11KnMrbypyLWEqZSxjPXUqZSthKnMtaCpyLG09dSpyK2gqZS1vKnMsZj0taCpzLW8qZS1hKnI7dFswXT1sKnUrZiotaCtjKi1hLW0qLW8sdFsxXT1jKnUrZiotbyttKi1oLWwqLWEsdFsyXT1tKnUrZiotYStsKi1vLWMqLWh9KHRoaXMsdGhpcyx0KSx0aGlzfXNldEZyb21NYXRyaXhQb3NpdGlvbih0KXtyZXR1cm4gdGhpcy54PXRbMTJdLHRoaXMueT10WzEzXSx0aGlzLno9dFsxNF0sdGhpc31hbmdsZSh0KXtyZXR1cm4gZnVuY3Rpb24odCxuKXtsZXQgaT1bLi4udF0scz1bLi4ubl07YShpLGkpLGEocyxzKTtsZXQgZT11KGkscyk7cmV0dXJuIGU+MT8wOmU8LTE/TWF0aC5QSTpNYXRoLmFjb3MoZSl9KHRoaXMsdCl9ZXF1YWxzKHQpe3JldHVybiBpPXQsKG49dGhpcylbMF09PT1pWzBdJiZuWzFdPT09aVsxXSYmblsyXT09PWlbMl07dmFyIG4saX1jbG9uZSgpe3JldHVybiBuZXcgbCh0aGlzWzBdLHRoaXNbMV0sdGhpc1syXSl9ZnJvbUFycmF5KHQsbj0wKXtyZXR1cm4gdGhpc1swXT10W25dLHRoaXNbMV09dFtuKzFdLHRoaXNbMl09dFtuKzJdLHRoaXN9bWluKHQpe3JldHVybiB0aGlzWzBdPU1hdGgubWluKHRoaXNbMF0sdC54KSx0aGlzWzFdPU1hdGgubWluKHRoaXNbMV0sdC55KSx0aGlzWzJdPU1hdGgubWluKHRoaXNbMl0sdC56KSx0aGlzfW1heCh0KXtyZXR1cm4gdGhpc1swXT1NYXRoLm1heCh0aGlzWzBdLHQueCksdGhpc1sxXT1NYXRoLm1heCh0aGlzWzFdLHQueSksdGhpc1syXT1NYXRoLm1heCh0aGlzWzJdLHQueiksdGhpc310b0FycmF5KCl7cmV0dXJuIEFycmF5LmZyb20odGhpcyl9c3RhdGljIGNvcHlUbyh0LG4pe3RbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdfX1jb25zdCBjPVtuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbF07Y2xhc3MgbXtjb25zdHJ1Y3Rvcih0PW5ldyBsKDEvMCksbj1uZXcgbCgtMS8wKSl7dGhpcy5taW49dCx0aGlzLm1heD1ufW1ha2VFbXB0eSgpe3JldHVybiB0aGlzLm1pbi54PXRoaXMubWluLnk9dGhpcy5taW4uej0xLzAsdGhpcy5tYXgueD10aGlzLm1heC55PXRoaXMubWF4Lno9LTEvMCx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5tYXgueDx0aGlzLm1pbi54fHx0aGlzLm1heC55PHRoaXMubWluLnl8fHRoaXMubWF4Lno8dGhpcy5taW4uen1nZXRDZW50ZXIodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LmFkZCh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHkoLjUpfWdldFNpemUodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LnN1Yih0aGlzLm1heCx0aGlzLm1pbil9ZXhwYW5kQnlQb2ludCh0KXtyZXR1cm4gdGhpcy5taW4ubWluKHQpLHRoaXMubWF4Lm1heCh0KSx0aGlzfXVuaW9uKHQpe3JldHVybiB0aGlzLm1pbi5taW4odC5taW4pLHRoaXMubWF4Lm1heCh0Lm1heCksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLm1pbi5jb3B5KHQubWluKSx0aGlzLm1heC5jb3B5KHQubWF4KSx0aGlzfWludGVyc2VjdHNCb3godCl7cmV0dXJuISh0Lm1heC54PHRoaXMubWluLnh8fHQubWluLng+dGhpcy5tYXgueHx8dC5tYXgueTx0aGlzLm1pbi55fHx0Lm1pbi55PnRoaXMubWF4Lnl8fHQubWF4Lno8dGhpcy5taW4uenx8dC5taW4uej50aGlzLm1heC56KX1zZXRGcm9tUG9pbnRzKHQpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuPGk7bisrKXRoaXMuZXhwYW5kQnlQb2ludCh0W25dKTtyZXR1cm4gdGhpc31hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpfHwoY1swXS5zZXQodGhpcy5taW4ueCx0aGlzLm1pbi55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxjWzFdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLGNbMl0uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQodCksY1szXS5zZXQodGhpcy5taW4ueCx0aGlzLm1heC55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSxjWzRdLnNldCh0aGlzLm1heC54LHRoaXMubWluLnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLGNbNV0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQodCksY1s2XS5zZXQodGhpcy5tYXgueCx0aGlzLm1heC55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxjWzddLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0RnJvbVBvaW50cyhjKSksdGhpc319ZnVuY3Rpb24gZih0LG4saT0wLHM9dC5sZW5ndGgsZT1NYXRoLmZsb29yKChpK3MpLzIpKXtmb3IobGV0IHI9aTtyPD1lO3IrKyl7bGV0IGk9cixlPXRbcl07Zm9yKGxldCBoPXIrMTtoPHM7aCsrKW4oZSx0W2hdKXx8KGk9aCxlPXRbaF0seCh0LHIsaSkpfX1mdW5jdGlvbiB4KHQsbixpKXtjb25zdCBzPXRbaV07dFtpXT10W25dLHRbbl09c31sZXQgeSxwPTAsZz0wLE09MCxkPSExO2NvbnN0IHo9bmV3IGw7ZnVuY3Rpb24gdyh0LG4pe3JldHVybntwcmltaXRpdmVzOnQsYm91bmRzOm59fWZ1bmN0aW9uIGIodCxuLGkpe2xldCBzPWlbbl0tdC5taW5bbl07cmV0dXJuIHQubWF4W25dPnQubWluW25dJiYocy89dC5tYXhbbl0tdC5taW5bbl0pLHN9ZnVuY3Rpb24gdih0KXtyZXR1cm4gdC5nZXRTaXplKHopLDIqKHoueCp6Lnorei54KnoueSt6Lnoqei55KX1mdW5jdGlvbiBxKHQsbixpLHM9ITEpe2NvbnN0IGU9bmV3IG07Zm9yKGxldCB1PW47dTxpO3UrKyllLnVuaW9uKHRbdV0uYm91bmRzKTtpZihkKXtNKz0xLHkoKE0rZykvcCl9Y29uc3Qgcj1pLW47aWYoMT09PXIpcmV0dXJuIHcodC5zbGljZShuLGkpLGUpO3tjb25zdCB1PW5ldyBtO2ZvcihsZXQgcz1uO3M8aTtzKyspdS5leHBhbmRCeVBvaW50KHRbc10uY2VudGVyKTtjb25zdCBsPSh1LmdldFNpemUoeiksei54Pnouej96Lng+ei55PyJ4IjoieSI6ei56PnoueT8ieiI6InkiKTtsZXQgYz1NYXRoLmZsb29yKChuK2kpLzIpO2lmKHI8PTQpZih0LCgodCxuKT0+dC5jZW50ZXJbbF08bi5jZW50ZXJbbF0pLG4saSxjKTtlbHNlIGlmKHUubWF4W2xdPT09dS5taW5bbF0pe2lmKCFzKXJldHVybiB3KHQuc2xpY2UobixpKSxlKTtmKHQsKCh0LG4pPT50LmNlbnRlcltsXTxuLmNlbnRlcltsXSksbixpLGMpfWVsc2V7Y29uc3Qgcz0xMixyPVtdO2ZvcihsZXQgdD0wO3Q8czt0Kyspci5wdXNoKHtib3VuZHM6bmV3IG0sY291bnQ6MH0pO2ZvcihsZXQgZT1uO2U8aTtlKyspe2xldCBuPU1hdGguZmxvb3IocypiKHUsbCx0W2VdLmNlbnRlcikpO249PT1yLmxlbmd0aCYmKG49ci5sZW5ndGgtMSkscltuXS5jb3VudCsrLHJbbl0uYm91bmRzLnVuaW9uKHRbZV0uYm91bmRzKX1jb25zdCBoPVtdO2ZvcihsZXQgdD0wO3Q8ci5sZW5ndGgtMTt0Kyspe2NvbnN0IG49bmV3IG0saT1uZXcgbTtsZXQgcz0wLG89MDtmb3IobGV0IGU9MDtlPD10O2UrKyluLnVuaW9uKHJbZV0uYm91bmRzKSxzKz1yW2VdLmNvdW50O2ZvcihsZXQgZT10KzE7ZTxyLmxlbmd0aDtlKyspaS51bmlvbihyW2VdLmJvdW5kcyksbys9cltlXS5jb3VudDtoLnB1c2goLjErKHMqdihuKStvKnYoaSkpL3YoZSkpfWxldCBvPWhbMF0sYT0wO2ZvcihsZXQgdD0xO3Q8aC5sZW5ndGg7dCsrKWhbdF08byYmKG89aFt0XSxhPXQpO2M9ZnVuY3Rpb24odCxuLGk9MCxzPXQubGVuZ3RoKXtmb3IoO2khPT1zOyl7Zm9yKDtuKHRbaV0pOylpZigrK2k9PT1zKXJldHVybiBpO2Rve2lmKGk9PT0tLXMpcmV0dXJuIGl9d2hpbGUoIW4odFtzXSkpO3godCxpLHMpLGkrK31yZXR1cm4gaX0odCwodD0+e2xldCBuPU1hdGguZmxvb3Ioci5sZW5ndGgqYih1LGwsdC5jZW50ZXIpKTtyZXR1cm4gbj09PXIubGVuZ3RoJiYobj1yLmxlbmd0aC0xKSxuPD1hfSksbixpKX1yZXR1cm4gaD1sLG89cSh0LG4sYyxzKSxhPXEodCxjLGkscykse2NoaWxkMDpvLGNoaWxkMTphLGJvdW5kczoobmV3IG0pLnVuaW9uKG8uYm91bmRzKS51bmlvbihhLmJvdW5kcyksc3BsaXRBeGlzOmh9fXZhciBoLG8sYX1mdW5jdGlvbiBBKHQsbixpKXtjb25zdHtwcmltaXRpdmVJbmZvQXJyOnN9PWZ1bmN0aW9uKHQsbj0wKXtsZXQgaT1uO2NvbnN0IHM9W107Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49W10scj10W2VdLGg9ci5pbmRpY2VzLG89ci5wb3NpdGlvbixhPW5ldyBsLHU9bmV3IGwsYz1uZXcgbDtmb3IobGV0IHQ9MDt0PGguYXJyYXkubGVuZ3RoO3QrPTMpe2NvbnN0IHM9aC5hcnJheVt0XSxlPWguYXJyYXlbdCsxXSxyPWguYXJyYXlbdCsyXSxmPW5ldyBtLHg9Myx5PXMqeDthLng9by5hcnJheVt5XSxhLnk9by5hcnJheVt5KzFdLGEuej1vLmFycmF5W3krMl07Y29uc3QgcD1lKng7dS54PW8uYXJyYXlbcF0sdS55PW8uYXJyYXlbcCsxXSx1Lno9by5hcnJheVtwKzJdO2NvbnN0IGc9cip4O2MueD1vLmFycmF5W2ddLGMueT1vLmFycmF5W2crMV0sYy56PW8uYXJyYXlbZysyXSxmLmV4cGFuZEJ5UG9pbnQoYSksZi5leHBhbmRCeVBvaW50KHUpLGYuZXhwYW5kQnlQb2ludChjKTtjb25zdCBNPXtib3VuZHM6ZixjZW50ZXI6Zi5nZXRDZW50ZXIobmV3IGwpLGluZGljZXM6W3MraSxlK2kscitpXX07bi5wdXNoKE0pfWkrPXIucG9zaXRpb24uYXJyYXkubGVuZ3RoLzMscy5wdXNoKG4pfXJldHVybntwcmltaXRpdmVJbmZvQXJyOnN9fSh0LGkpLGU9W107aWYobil7cD0wLGc9MCxkPSEwLHk9bjtmb3IobGV0IHQ9MDt0PHMubGVuZ3RoO3QrKylwKz0yKnNbdF0ubGVuZ3RoLTF9Zm9yKGxldCByPTA7cjxzLmxlbmd0aDtyKyspe2NvbnN0IHQ9c1tyXTtNPTA7Y29uc3Qgbj1xKHQsMCx0Lmxlbmd0aCk7Zys9Mip0Lmxlbmd0aC0xLGUucHVzaChuKX1yZXR1cm57Ymxhc0JWSHM6ZX19ZnVuY3Rpb24gQih0LG49MCxpPVtdKXtjb25zdCBzPVtdO2xldCBlPTE7Y29uc3Qgcj17eDozLHk6NCx6OjV9LGg9KHQsbz0xKT0+e2lmKGU9TWF0aC5tYXgobyxlKSx0LnByaW1pdGl2ZXMpe2NvbnN0IG49dDtmb3IobGV0IHQ9MDt0PG4ucHJpbWl0aXZlcy5sZW5ndGg7dCsrKXtjb25zdCBlPW4ucHJpbWl0aXZlc1t0XTtpZih2b2lkIDAhPT1lLmluZGljZXMpe2NvbnN0IHQ9ZTtzLnB1c2godC5pbmRpY2VzWzBdLHQuaW5kaWNlc1sxXSx0LmluZGljZXNbMl0sMSwwLDAsMCwwKX1lbHNle2NvbnN0IHQ9ZTtzLnB1c2goaVt0Lmdlb21ldHJ5SURdLHQubWF0ZXJpYWxJRCx0Lm1lc2hJRCwxLE51bWJlcih0LnZpc2libGUpLDAsMCwwKX19fWVsc2V7Y29uc3QgaT10LGU9aS5ib3VuZHM7cy5wdXNoKGUubWluLngsZS5taW4ueSxlLm1pbi56LHJbaS5zcGxpdEF4aXNdLGUubWF4LngsZS5tYXgueSxlLm1heC56LDApO2NvbnN0IGE9cy5sZW5ndGgtMTtoKGkuY2hpbGQwLG8rMSksc1thXT1zLmxlbmd0aC84K24saChpLmNoaWxkMSxvKzEpfX07cmV0dXJuIGgodCkse2NvdW50OnMubGVuZ3RoLzgsbWF4RGVwdGg6ZSxmbGF0RGF0YTpzfX1zZWxmLm9ubWVzc2FnZT1mdW5jdGlvbih7ZGF0YTp0fSl7Y29uc3R7Z2VvbWV0cmllczpuLHByZVZlcnRleENvdW50OmksbGFzdFNwbGl0SW5kZXg6c309dDtsZXQgZT1wZXJmb3JtYW5jZS5ub3coKTtjb25zdCByPXQ9Pntjb25zdCBuPXBlcmZvcm1hbmNlLm5vdygpOyhuLWU+PTEwfHwxPT09dCkmJihlPW4sc2VsZi5wb3N0TWVzc2FnZSh7ZXJyb3I6bnVsbCxmbGF0QkxBU0JWSEluZm86bnVsbCxwcm9ncmVzczp0fSkpfTt0cnl7Y29uc3R7Ymxhc0JWSHM6dH09QShuLHIsaSksZT1mdW5jdGlvbih0LG49MCl7Y29uc3QgaT1bXTtsZXQgcz1bXSxlPTE7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IGg9Qih0W3JdLG4pO2U9TWF0aC5tYXgoaC5tYXhEZXB0aCxlKSxzLnB1c2gobiksbis9aC5jb3VudCxpLnB1c2goaCl9cmV0dXJue2JsYXNCdWZmZXJTcGxpdEluZGV4OnMsdG90YWxCTEFTRGF0YUxlbmd0aDo4Km4sdG90YWxCTEFTRGF0YUNvdW50Om4sZmxhdEJWSEluZm9zOmksbWF4RGVwdGg6ZX19KHQscyk7c2VsZi5wb3N0TWVzc2FnZSh7ZXJyb3I6bnVsbCxmbGF0QkxBU0JWSEluZm86ZSxwcm9ncmVzczpudWxsfSl9Y2F0Y2goaCl7c2VsZi5wb3N0TWVzc2FnZSh7ZXJyb3I6aCxmbGF0QkxBU0JWSEluZm86bnVsbCxwcm9ncmVzczpudWxsfSl9fX0oKTsK",It=typeof window<"u"&&window.Blob&&new Blob([atob(ar)],{type:"text/javascript;charset=utf-8"});function bs(){const i=It&&(window.URL||window.webkitURL).createObjectURL(It);try{return i?new Worker(i,{}):new Worker("data:application/javascript;base64,"+ar,{type:"module"})}finally{i&&(window.URL||window.webkitURL).revokeObjectURL(i)}}class vs{constructor(){this.worker=new bs,this.building=!1}build(e,t,r,s){if(this.building)throw new Error("BVHWorker is building");this.building=!0;const{worker:a}=this;return new Promise((n,u)=>{a.onmessage=o=>{this.building=!1;const{flatBLASBVHInfo:l,error:c,progress:d}=o.data;c?u(new Error(c)):l?(a.onmessage=null,n(l)):d!=null&&t(d)},a.postMessage({geometries:e,preVertexCount:r,lastSplitIndex:s})})}}class Ls{constructor(e,t){this.device=e,this.useWebWorker=t,this.debugPass=new Qt(e),this.workerBuilder=new vs}async addMeshesToBLAS(e,t,r,s){const{device:a,useWebWorker:n}=this,u=[];Array.from(t.keys()).forEach((b,L)=>{u[L]={};const S=u[L];S.position=b.position,S.indices=b.indices});const o=this.lastFlatBLASBVHInfo.totalBLASDataCount;let l;if(n)l=await this.workerBuilder.build(u,s,r,o);else{const{blasBVHs:b}=Bt(u,s,r);l=wt(b,o)}this.lastFlatBLASBVHInfo.blasBufferSplitIndex.push(...l.blasBufferSplitIndex),this.lastFlatBLASBVHInfo.flatBVHInfos.push(...l.flatBVHInfos),this.lastFlatBLASBVHInfo.totalBLASDataCount=l.totalBLASDataCount,this.lastFlatBLASBVHInfo.totalBLASDataLength=8*this.lastFlatBLASBVHInfo.totalBLASDataCount;const c=this.lastFlatBLASBVHInfo.totalBLASDataLength*Float32Array.BYTES_PER_ELEMENT;if(c>=Math.min(a.limits.maxBufferSize,a.limits.maxStorageBufferBindingSize))return void console.error("The total size of loaded models exceeds the browser limit!");const d=this.blasBuffer=a.createBuffer({mappedAtCreation:!0,size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),h=new Float32Array(d.getMappedRange()),f=this.lastFlatBLASBVHInfo.flatBVHInfos;let m=0;for(let b=0;b<f.length;b++){const L=f[b].flatData;h.set(L,m),m+=L.length}d.unmap();const{positionBuffer:x,uvBuffer:g,normalBuffer:p,indicesBuffer:v}=this.buildGeoBuffer(e);return{positionBuffer:x,uvBuffer:g,normalBuffer:p,indicesBuffer:v}}rebuildTLAS(e,t=!1){const{device:r}=this,{geometryIndexMap:s}=e.geometryInfo;let{meshes:a,materialIndexMap:n}=e;a=a.filter(l=>!l.tlasMask);const u=Rt(Pt(a,s,n),this.lastFlatBLASBVHInfo.blasBufferSplitIndex),o=_t(a);if(t){const l=u.flatData.length*Float32Array.BYTES_PER_ELEMENT;this.tlasBuffer=r.createBuffer({size:l,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});const c=o.byteLength;this.transformBuffer=r.createBuffer({size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST})}r.queue.writeBuffer(this.tlasBuffer,0,new Float32Array(u.flatData)),r.queue.writeBuffer(this.transformBuffer,0,o)}destory(){}buildGeoBuffer(e){const{device:t}=this,{geometryIndexMap:r,vertexTotalCount:s,indicesTotalCount:a}=e.geometryInfo,n=Array.from(r.keys()),u=3*s*Float32Array.BYTES_PER_ELEMENT,o=t.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),l=new Float32Array(o.getMappedRange());let c=0;n.forEach(M=>{const T=M.position.array;l.set(T,c),c+=T.length}),o.unmap();const d=u,h=t.createBuffer({mappedAtCreation:!0,size:d,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),f=new Float32Array(h.getMappedRange());let m=0;n.forEach(M=>{const T=M.normal.array;f.set(T,m),m+=T.length}),h.unmap();const x=2*s*Float32Array.BYTES_PER_ELEMENT,g=t.createBuffer({mappedAtCreation:!0,size:x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),p=new Float32Array(g.getMappedRange());let v=0;n.forEach(M=>{const T=M.uv.array;p.set(T,v),v+=T.length}),g.unmap();const b=a*Uint32Array.BYTES_PER_ELEMENT,L=t.createBuffer({mappedAtCreation:!0,size:b,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.INDEX}),S=new Uint32Array(L.getMappedRange());let y=0;return n.forEach(M=>{const T=M.indices.array;S.set(T,y),y+=T.length}),L.unmap(),{positionBuffer:o,uvBuffer:g,normalBuffer:h,indicesBuffer:L}}async build(e,t){const{device:r,useWebWorker:s}=this,{geometryIndexMap:a}=e.geometryInfo;let{meshes:n,materialIndexMap:u}=e;const o=Array.from(a.keys()),l=[];if(o.forEach((_,B)=>{l[B]={};const P=l[B];P.position=_.position,P.indices=_.indices}),s)this.lastFlatBLASBVHInfo=await this.workerBuilder.build(l,t);else{const{blasBVHs:_}=Bt(l);this.lastFlatBLASBVHInfo=wt(_)}n=n.filter(_=>!_.tlasMask);const c=Rt(Pt(n,a,u),this.lastFlatBLASBVHInfo.blasBufferSplitIndex),d=this.lastFlatBLASBVHInfo.totalBLASDataLength*Float32Array.BYTES_PER_ELEMENT;if(d>=Math.min(r.limits.maxBufferSize,r.limits.maxStorageBufferBindingSize))return void console.error("The total size of loaded models exceeds the browser limit!");const h=this.blasBuffer=r.createBuffer({mappedAtCreation:!0,size:d,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),f=new Float32Array(h.getMappedRange()),m=this.lastFlatBLASBVHInfo.flatBVHInfos;let x=0;for(let _=0;_<m.length;_++){const B=m[_].flatData;f.set(B,x),x+=B.length}h.unmap();const g=c.flatData.length*Float32Array.BYTES_PER_ELEMENT,p=this.tlasBuffer=r.createBuffer({mappedAtCreation:!0,size:g,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});new Float32Array(p.getMappedRange()).set(c.flatData,0),p.unmap();const{positionBuffer:v,uvBuffer:b,normalBuffer:L,indicesBuffer:S}=this.buildGeoBuffer(e),y=_t(n),M=y.byteLength,T=this.transformBuffer=r.createBuffer({mappedAtCreation:!0,size:M,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});return new Float32Array(T.getMappedRange()).set(y,0),T.unmap(),{blasBuffer:h,tlasBuffer:p,positionBuffer:v,uvBuffer:b,normalBuffer:L,indicesBuffer:S,transformBuffer:T}}}const $="PositionBuffer",ee="UVBuffer",te="NormalBuffer",Oe="BVHBuffer",se="IndicesBuffer",Le="TLASBuffer",ye="BLASBuffer",ae="TLASTransformBuffer",V="MaterialBuffer",K="MaterialTextureArray",H="TextureUVTransformBuffer",ce="LightBuffer";class ys{constructor(e,t){this.device=e,this.resourcePool=t,this.bvhBuilder=new xs(e)}destroy(){const{resourcePool:e}=this;e.destoryResourceByName(V),e.destoryResourceByName(K),e.destoryResourceByName(H),e.destoryResourceByName($),e.destoryResourceByName(te),e.destoryResourceByName(ee),e.destoryResourceByName(se),e.destoryResourceByName(Oe),e.destoryResourceByName(ce)}async buildBVH(e){const{resourcePool:t}=this,r=await this.bvhBuilder.build(e);if(!r)return;const{positionBuffer:s,uvBuffer:a,indicesBuffer:n,normalBuffer:u,bvhNodesBuffer:o,materialMeshIndexBuffer:l}=r;t.setResource($,s,"Buffer"),t.setResource(te,u,"Buffer"),t.setResource(ee,a,"Buffer"),t.setResource(se,n,"Buffer"),t.setResource(Oe,o,"Buffer"),t.setResource("MaterialMeshIndexBuffer",l,"Buffer")}async build(e,t){let{meshes:r,materialIndexMap:s,materials:a,lights:n}=e;r=r.filter(f=>f.visible==1);const u=Ve(r,!0);e.geometryInfo=u;const o=Ce(r,s,u),{textureImageMap:l,materialBuffer:c,textureArrayRes:d}=await Me(this.device,a);this.resourcePool.setResource(V,c,"Buffer"),this.resourcePool.setResource(K,d,"Texture");const h=Ge(this.device,s);this.resourcePool.setResource(H,h,"Buffer"),this.curLightBuffer=Zt(this.device,n),this.resourcePool.setResource(ce,this.curLightBuffer,"Buffer"),this.curTextureImageMap=l,this.curUVTransformBuffer=h,await this.buildBVH(o)}updateMaterialParams(e){const{materials:t}=e,{device:r,curTextureImageMap:s,resourcePool:a}=this,n=je(r,t,s);a.updateResource(V,n,"Buffer")}updateLightBuffer(e){const t=e.lights;$e(this.device,this.curLightBuffer,t)}updateUVTransBuffer(e){const{materialIndexMap:t}=e;Ht(this.device,t,this.curUVTransformBuffer)}async rebuildMaterialRelated(e){let{meshes:t,materialIndexMap:r,materials:s,geometryInfo:a}=e;t=t.filter(d=>d.visible==1);const n=Ce(t,r,a),{textureImageMap:u,materialBuffer:o,textureArrayRes:l}=await Me(this.device,s);this.resourcePool.setResource(V,o,"Buffer"),this.resourcePool.setResource(K,l,"Texture");const c=Ge(this.device,r);this.resourcePool.setResource(H,c,"Buffer"),this.curTextureImageMap=u,this.curUVTransformBuffer=c,await this.buildBVH(n)}async rebuildBVH(e){let{meshes:t,materialIndexMap:r,materials:s,geometryInfo:a}=e;t=t.filter(u=>u.visible==1);const n=Ce(t,r,a);await this.buildBVH(n)}}class Ss{constructor(e,t,r=!0){this.device=e,this.resourcePool=t,this.useWebWorker=r,this.bvhBuilder=new Ls(e,r)}destroy(){const{resourcePool:e}=this;e.destoryResourceByName(V),e.destoryResourceByName(K),e.destoryResourceByName(H),e.destoryResourceByName($),e.destoryResourceByName(te),e.destoryResourceByName(ee),e.destoryResourceByName(Le),e.destoryResourceByName(ye),e.destoryResourceByName(ae),e.destoryResourceByName(ae),e.destoryResourceByName(ce)}async buildBVH(e,t){const{resourcePool:r}=this,s=await this.bvhBuilder.build(e,t);if(!s)return;const{positionBuffer:a,uvBuffer:n,normalBuffer:u,indicesBuffer:o,tlasBuffer:l,blasBuffer:c,transformBuffer:d}=s;r.setResource($,a,"Buffer"),r.setResource(te,u,"Buffer"),r.setResource(ee,n,"Buffer"),r.setResource(se,o,"Buffer"),r.setResource(Le,l,"Buffer"),r.setResource(ye,c,"Buffer"),r.setResource(ae,d,"Buffer")}async build(e,t){let{meshes:r,materials:s,materialIndexMap:a,lights:n}=e;this.destroy();const u=Ve(r);e.geometryInfo=u;const{textureImageMap:o,materialBuffer:l,textureArrayRes:c}=await Me(this.device,s);this.resourcePool.setResource(V,l,"Buffer"),this.resourcePool.setResource(K,c,"Texture");const d=Ge(this.device,a);this.resourcePool.setResource(H,d,"Buffer"),this.curLightBuffer=Zt(this.device,n),this.resourcePool.setResource(ce,this.curLightBuffer,"Buffer"),this.curTextureImageMap=o,this.curUVTransformBuffer=d,await this.buildBVH(e,t)}updateLightBuffer(e){const t=e.lights;$e(this.device,this.curLightBuffer,t)}updateMaterialParams(e){const{materials:t}=e,{device:r,curTextureImageMap:s,resourcePool:a}=this,n=je(r,t,s);a.updateResource(V,n,"Buffer")}updateUVTransBuffer(e){const{materialIndexMap:t}=e;Ht(this.device,t,this.curUVTransformBuffer)}rebuildTLAS(e,t=!1){this.bvhBuilder.rebuildTLAS(e,t),t&&(this.resourcePool.updateResource(Le,this.bvhBuilder.tlasBuffer,"Buffer"),this.resourcePool.updateResource(ae,this.bvhBuilder.transformBuffer,"Buffer"))}async rebuildMaterialBuffer(e,t=!1){const{materials:r,materialIndexMap:s}=e;if(t){const{textureImageMap:a,materialBuffer:n,textureArrayRes:u}=await Me(this.device,r);this.resourcePool.updateResource(V,n,"Buffer"),this.resourcePool.updateResource(K,u,"Texture");const o=Ge(this.device,s);this.resourcePool.updateResource(H,o,"Buffer"),this.curTextureImageMap=a,this.curUVTransformBuffer=o}else this.updateMaterialParams(e)}async addMeshesToBLAS(e,t,r){var s;let{meshes:a}=e;const{resourcePool:n}=this,u=(s=e.geometryInfo)==null?void 0:s.vertexTotalCount,o=Ve(a);e.geometryInfo=o;const l=function(x){const g=new Map;for(const p of x){let v=p.geometry;if(g.get(v)==null){const b=g.size;g.set(v,b)}}return g}(t),c=await this.bvhBuilder.addMeshesToBLAS(e,l,u,r);if(!c)return;const{positionBuffer:d,uvBuffer:h,normalBuffer:f,indicesBuffer:m}=c;n.updateResource(ye,this.bvhBuilder.blasBuffer,"Buffer"),n.updateResource($,d,"Buffer"),n.updateResource(te,f,"Buffer"),n.updateResource(ee,h,"Buffer"),n.updateResource(se,m,"Buffer")}}class Ms{constructor(e,t){this.strata=[];const r=e**t;for(let s=0;s<r;s++)this.strata[s]=s;this.index=this.strata.length,this.sample=[],this.strataCount=e,this.dimensions=t}restart(){this.index=0}next(){const{strata:e,strataCount:t,dimensions:r}=this;this.index>=e.length&&(function(a){for(let n=a.length-1;n>0;n--){const u=Math.floor(Math.random()*(n+1)),o=a[n];a[n]=a[u],a[u]=o}}(this.strata),this.restart());let s=e[this.index++];for(let a=0;a<r;a++)this.sample[a]=s%t+Math.random(),s=Math.floor(s/t);return this.sample}}class zt{constructor(e,t){this.strataObjs=[];for(const r of t)this.strataObjs.push(new Ms(e,r));this.combined=[],this.strataCount=e}getFirstBake(){return this.bakeCombined||(this.bakeCombined=this.next()),this.bakeCombined}next(){const{strataObjs:e,combined:t}=this;let r=0;for(const s of e){const a=s.next();for(const n of a)t[r++]=n}return t}restart(){for(const e of this.strataObjs)e.restart()}}class Gs{constructor(e){this.context=e,this.curTileNum=-1,this.totalTileNum=-1,this.columns=0,this.rows=0,this.tileWidth=0,this.tileHeight=0,this.viewWidth=0,this.viewHeight=0}reset(){this.curTileNum=-1}setSize(){const{width:e,height:t}=this.context;this.viewWidth=e,this.viewHeight=t,this.computeTileDimensions()}setTileCount(e){this.totalTileNum=e,this.computeTileDimensions(),this.reset()}computeTileDimensions(){const{viewWidth:e,viewHeight:t}=this,r=Math.sqrt(this.totalTileNum);this.tileWidth=Math.ceil(e/r),this.tileHeight=Math.ceil(t/r),this.columns=Math.ceil(e/this.tileWidth),this.rows=Math.ceil(t/this.tileHeight),this.columns&&this.rows&&(this.totalTileNum=this.columns*this.rows)}nextTile(){const{totalTileNum:e,tileWidth:t,tileHeight:r,viewHeight:s,columns:a,rows:n}=this;this.curTileNum++,this.curTileNum%e==0&&(this.curTileNum=0);const u=this.curTileNum===e-1,o=this.curTileNum%a,l=Math.floor(this.curTileNum/a)%n;return{x:o*t,y:Math.min(s,l*r),tileWidth:t,tileHeight:r,isFirstTile:this.curTileNum===0,isLastTile:u}}}class Ts{constructor(e,t,r){this.device=e,this.context=t,this.rg=r,this.sampleCount=0,this.strataCount=1,this.numUniformSamples=4,this.samplingDimensions=[],this.needsUpdateBG=!1,this.enableTileRender=Qe,this.tilePreFullSample=1,this.tileOffset=[0,0],this.tileSize=[0,0],this.enableDenoise=Ft,this.resourcePool=this.rg.resourcePool,this.integratorPass=new ue(this.device,this.context,this.rg),this.accumulatePass=new xe(this.device,this.context,this.rg),this.screenPass=new ge(this.device,this.context,this.rg),this.clearTexPass=new Ot(this.device,this.context,this.rg),this.gBufferPass=new Te(this.device,this.context,this.rg),this.aToursPass=new be(this.device,this.context,this.rg),this.blitConvertPass=new ve(this.device,this.context,this.rg),this.tileCalculator=new Gs(t),this.pipelineConfig={needsClean:!1}}async buildPipeline(e,t,r){this.camera=t,this.lastCamera=t.clone(),this.renderSetting=mt(e,0,r),await this.initNoise(),this.initRandomSample(),this.initTileBuffer(),this.initUniformBuffer(),await this.integratorPass.createPipeline(this.renderSetting),await this.accumulatePass.createPipeline(this.renderSetting),await this.screenPass.createPipeline(this.renderSetting),await this.clearTexPass.createPipeline(),await this.gBufferPass.createPipeline(this.renderSetting,e,t),await this.aToursPass.createPipeline(this.renderSetting),await this.blitConvertPass.createPipeline(this.renderSetting)}async initNoise(){const{device:e,resourcePool:t}=this;if(t.getResourceByName("NoiseTexture"))return;const r=await async function(n){const u=await fetch(n),o=await u.blob();return await createImageBitmap(o)}("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAEAAAAADfkvJBAAAbsklEQVR4nA3UhQIIvBoA0E830810M91MN9PNdDPd/ulmupluppvpZrqZbqabe89DHCiDv5GzaossZGYBp2PFIFqKdmMXIKW85edCB/RT11SD3JMQidRlL7n2ufRH1jVkFUNVc3NaZ7DP0T7/112kM1Qc3RDG0K/4uN7CPC7OmtFRZK3Jy3fhSSySKIZXopTsnIhN69JjLHJYYnfpZu44hnV+UkhG/lPd/D+fIVwWtdhhupVPJmtsLFIhjHA7UUqY4fPIQ2qdKxviqH2sugJ2nC+1ZdV0vEF3RGNcMd4KdvIXaJnujdPrKj4ifkeX2f04avjEbqO0ogI/rD7zhmy6GKG/2w32IetIX5vE9DbrS+CNy4sbmgXoiaug48lV4bVKZgluwPujd+Ioa+KjuntypepEEvl/YYCYTq6w4aaReGMShwLkC4nvq7jFKJmLpoepHJTag/h2aMklShou+tyip5wm67P2/CnvH7K6zuq+KGvy2rkkrR4mc4dpUNTEFHDId9TXQiST3RxHO0lHNgNFIA/Ub1kC0pOlNBf77EtyZ0ejxvikzySL8C8hNWyyc1GvcBCusv/otvBO3YSj+KvvRlKgoNaF/GEB64prsx8qFRwVJcRmMk8l5E5swfHMPuhlr9DmtrLeqs7KOrCMQSpeGW/zH5F2dc0AXZhcp9IthLZyuxpHrkNnp0JfnsY+55XkAtgSOvsWzps8uoJ5GtpAXRWZ5TK9cEM1WVRWC81ZUstPZHHkC7GDjZfl7BJ+VcXkI8RfVIMW0Jq95oxE0R+MDQnMX97DPhYjEXzHM0LvUNyODhdDCvJdNmXlfFp0RsbBNclTj8hpXofsCgVYsAnwPRTNTiTLxZkQW43BmK6wHk7Y0iSdXIfyK8/aQULdx1/hJc0JkRE/UgNDc/dGZWanTCs2WQ0W6Xh7PZGuDMXEaLtIRMZcZAM4ieOwO661Qf4xVyhLOOA2mLe0JyvIDrBhUA42ioUiMmrHJ9te6jwtbQ6xWrKf/ED3qKJ0qvzO2of57KkcyMBvNZndbLTX/iWNaWTezm9E8cleKOSEXK1B3LDfeGk4yx/b7L5+uAvp6UVC/UYAhvPLvSwTWm+qqO5saYjh79LadBJaAR90ct9S/GGZ7Q1zhKyTOUJ9MzT85IldVjLLduUOqovEaASJbXeZ37oFv0w/sOGhvMzpVrL/2MeQx8+ldfQU/QBXIqn8NtHAHjCzaTJk+CDS0e6Wk8N7GEDgoR4rG5M/Zig/LD6hEr6VHmxzmijoKu/oZ+p84oEeiwegquE7pBZPYXEoyLeQ66wRicLXmOzWoib6mq6KUoWxuriq62OQh647TUmn0RuuIjtPfuEkcMQtwJ/IaJabRRe9fRX2Q8Z1L2UNlMclpfMFdKYr+XkVEeb6vChZuOBfhNl+l/hly9L0/mzYIxPhBq4oimlnB273mkgwnr+S7Vnp8Fff8/3VC7IJCtqZ9AxZRnujo3wjmQ9n7WtayxwgvUhUNtJ0UjlEU9vPFhePxDLfkl6z43hhdQSW+xbyKooJEEwqTOkL1VHWc1vReFaVxbcnTGM2Uq1XNXRPos0bdtI8VBKXcZdCV1dNpLcL3DE7Cqfmi2w5JGhGFqATTUhzy7sG2+a0II4ZtupikC488mt9abdTvpYXVALXBU6wNzYLXUTPQwTxH/nNttjKDA7pQT47mopOQmxzW/f3GVhXWoguEUl5EHcUoKm8LdpiMoZV9JONpzZa7wa7hG4XzxvquHj2s5lsIrFbtrbew3+SKbiK6Ry+whAyXrTBC0kgDfwZHNOMNRnwOjHVVICdOGVo6LuFsn6GTKN6u4IeZqtN7B6vzlegD7ioW8i/u430kbtO2pABrgTPwb+xchSZ7jK/V6KxPEWK+K+oBXFmeuikt+HzrIU66KQsI9bRaGqQfKqSkMNumbnN4/ljkFsPxqnDElSF32L17D8UhxbUI8xnuwk/0znwXXcGGmD4QpPo5n6kTod70Zb2oI8Y6pFJKiuLoab7bXBEj+CXFTOH4A4kV/1JNjNRLrexaEX5Ht0xQ1RRskzmhCd+rmnFi9hLeqHe7svy7Lq+/+Mq6am+A/X8e+iptvqcbIjzqCOfbW6SpKQ22gPt8HgTFUMPd9kWgKd2O45Pr0EuOlK8waXFfriga7sXrLlKZZbrgeaPnmsrurd+n2H8hugjc+i1OCpJj2vYPyQ27+lT6/f4JM0c6sJIHwm/8AJS4tXuuo6g9qOCjvOZIrI9ZpaaauQAjwb9eTG0RMYPr2y5AHv8YhZLHvZl+DdQqrI5Z1L4QawT/FOLoQCOLR+EyTIrjcqb6YtiA4mg0/L27reYYg7JpvSVOM7G+p2uIb1iJ0hE+/DvvLW+qqfL034nLU5GQh02j8aHi/aDLS2b4ncYk/OcE+V+hhNqmF2rs1j4a1qziXYgaaDWQRetSbOwC60J8VhFSIf62k2osy7FXqpdrDAdZbuQxf5ZOCGLy6Reago9xBydmN9HBdUqX9VtUYdIKZOGbGAFxEDXjLxDmeVXsd5WIOmlhN0kqe2r84o1upy+z9KLRjY/ui5qGkhNiqoL5iXN6hPbeyGa+ckKwRM6l51Ao+EG/yKruXNsrWvHkuDPKKctS4bYRnq7eIQX+at4s8lD2ovy+D/xlXUWuf2jsNiNQx9xDRwjLAgJUSd5AvfTD80U0Qk91fP8DTkBfaXx1Qhv7FMXifZRMw0MlxtxVFVNzoOTrnjoK9ObCZy5HOwjbWgTib1kFo3BJa9t7oojdJK5RpGcifO66LQ2xuIHBvxcnMcLdEoUWc0QjVhs0k3f4dnoXvREODRB5KWJ2UFTX60WcXERxFQ7uo9mDz1YVbzQddDBHQ3QxD0MPfBnsdX+p9+xg+Sybmtum4hKoJW+CG0NGSQxP/TC0AulZ1tozfATr9Ld/QfURp1kg2FqaOQ2QBZ9JNyCoeQfO0eS+SOCa0lLshW6hnulWqHi/qrMTj6Z03gzB/LMzuaXmZXJSUm7nSKACjQDVzafbiNTqUayYpjDNpqhqIzf4SfRU/KF6S+vo0MhAS/v36BoolU4JbKQO3S3nmAL88puH0GoN6tF3vg2rCzscLVcUbmKzHS/dFroBdGk8bP4Hx8DRotKtJdMa4YZKhvR2OgbnULv+lzYUfjhFusD6KaLR8aHFSSPjYmT2MP6tU1L76u4uqJYrqawEqqpW+Onm4G6KIw2CU0Z29/EIc9gKVwjH3wxNV5v8fmxVunIGB94PxYBV+I3RRM4IO8x7Ab6ZXi3aoEeoUXmtzqHVrGCsrUYpOvIFXSMgX4YQp1Qmp6xf/Ae8gR1U19NUzEdSOjApK9nPuoItqt5HE7TXPIm3sff2fm+SbioN9GcPLltyTLKeeGBjGr668sYsfuymdjM8uHjYqL5BLn4SFqRdjbnZJKgyFHIA51lEjEebtEMfqN7LlORlgreiM3B26G2g82iqssbZBQq6k+rGn5J+MMvsVRus95vMpFR9K9K4errLmJFSMO/iepoBu6CfptR4QzqxpOYH6ERP4xmqS4uKzz3V2RS0SnMNwnYKvdW5Bd16FdS0kWlDeQ2VIMEJtgeVJ7GZIdDYQldWQ6UVK2mM1l000/MRyn5GpGZDkRbQ1RUCs/HLcMDV4hV1/OkEZFpRX+f5zfSHGQR7W2obdeiMnK3qQarTK7wEiq5vTqWXayqhyF4By5l6+HDPKK4AZtVRnoHjVBv8Syd1VocyY2UP9g8c15PpXBNVIET8MnVd8/oNlaGcnZJBZoQ7uAe4SjJAWNdX3AkNrQTQ+ClmMxO23i4nXseStC+4agkPDYeChdcOzLRJ2f/2S+ukJqsW/tvKoN4bP5/sOpHxuN5qC3p5VbaizIefWBKkKWkCc+DO5paPAHAP7wQj+VFRVp/zhPy3Ufw+8I4VsE1QVPtS1ZLf6eJ5Qr3Se3GxfURld71EhvEHJXVbLdJzUL/2nk6nX1mGcxdXUpvIg2gt7rADrkoYq0ogKbYXyK1pOwljuEO0rykAh5k2pMp6hR7rVO7h3IY2Y6gOYpsBqhWfp/sQcbbZa6m7uge0dx8pUgjd9GY5CyUldNEXX3L5JRLaHP2G5UhDtfnn8Qk3sak8Y1dUR5BatyTnyTR2PWwnCVCZe09NdwLG8tpvl3nJCd8dfzPNFMp1Wb4YuuihKIPWkP2k5I0o4OVJB96wDby2Oy2TAwv9VAxh8dFJ9EvU1S390Pdekx8d0jrxgik35GaLDoeZR7ZhH4IqyzO+/WiNzkkGNrOm8MvN4dmom9kbtuCzgy14K097SrhJuoeDEMJ7CI5Tjwn+3AmfjkUQpXUTR+DzdDPKVRgh23w1c0MUoI1EYchky6st4hefmS4bhZhr5vJ9/QYfUpbywukv9iib4S8msMqOE6iqH86px6L3oubJike6fJBB1ODDTZb6V+fAvapLL6DTGQ+2hm2k1svL8litoeKxZaRIXq2/U3HsDb6ghQBJqP4OB29iP4Lv/FaVZlctV9QM5tC1UGRbCWRBSfQs/UOFAGtlhX8VJJMLTD7VQY6HRU23ehdXAYlJHN5FlkRvXQHdDzx2I8Lx1A3sxTd8MXdOjVKH4BCOp2pIx6zrHwar6qO6uYB3FaXXdYNycNXCUNlY9TFLwq5SFuemg60UdhieVa8hml4v/2sHOsDNV1JGM5zmx/U2qKhk/lq+7jXaCuuYxaTPba1OuMHhY16GiuJVonzKBUtjEDVtwPxJP+cXUaRfD/1w5zS0Ulr9DXcQPnIK39Xdgkn+WJahGzGkI1cda/xFhfNn6KP1R7c2Y4JZSBnWK26kkJhs51E/tGk8m5oInvSjOI5risjuorqlI8X0oZh+JmKQeuhn7KLjKmvmd6iCVnIKtMH5KOM6zGu5nP5hmixMLo8Ge0P6jWyD0ukR7F0lqIPEMc/gv0OIsqZvCSug8eZ964gnYXr+LsqPmojHrG0apiIzg6TtkyHc7BHIDzTXuL/yQ38Dhsnm5OPfCorYK/LFTKPOU4xr+m/6WzydVCmPWwM5+UuN9e1Ce/8TRbfdJVzbCrWQJTUO+R8V5Ouh6m6T2jpqllYDfew5Ylcb1teraRxUFb8xxp6zFWH+eqtbIhzomc+DRunqvv3doVoKfOEJGoRKilzmAt4B69k+0FyN0m2ED5ss6NkNLTbn1LDAmHU/QDBj5oU8j9cxLxi2dUd+z5E8RfNT9NUHvApzRU/Bv1R0MEPlER9Nzuhpb/lhmsLxUJfP8EkYWdUCbyW3QzlbTco4AfhKEDNUfeY7pLt8U/a063mUaGD+4wtofwtmo0L2WWqlSxHErH0aDltYsbwqHqNq2CnuJ3qdKjJh/hlYYrsKLKwwTy2eOnzyrIMB1A0rmhiNc3Iz9tkvJt44ZqhJQ70F+jhW8CIgNQuO49/Q8bcJ5NxWlaVj6Yx/VVIZWeY2uK+zuw3hSEhIu2hE5NLfiC9p//I7vq6i6+fioJwF2Uyf2lzHoGt521FPlUJrH+AioQzvJtcJnaGEwHewSXxGFExyX7y81hVsQGng6shr9lG74TM5KdX/LyLIevpKyin6sz/Qj/0MjTQh2g594Yct6NVPL5QNUC3QlX/RR3hOXE9th5Nhf2hBswWfdVZVJsvMQNoGnOVfvNx6Qudgo9Ra/hMVJV8wdF1XQwFSYqwzgxjkVQ9kS+cZjHEhzAK6qMKYlZIjg+ZGqIvykCWBy4T0dlkBykCq33WsIAOAoJaQjH/V5w1uekes5plQOPRfBuTFmGvWRueVX9VW2V7GcccoE90CTSW7cXzaU+9hdflUeUTkk001/PDCAnbTRXb2h4jPeCZ2O0Gh1JuOu2M97PnZjBd6QrJDuqBL60+kuH4BK+Fo8uzLjmaoO4Z4DvsCpZM9DJtlWKvUEnVmTVVj/SOUFmOxBHCZV7CJJETIKA8rIuZKavxzKaxvQSlxD/exg9g130ifoH20pBJPKAz2F+bwyVUq2Qrd98mshdVNhVTtjJXSFx4wzegSfhAKECfcY1u4Wamu3pPqogO+Fu4bifDU1MZRfepxAh8EeLYn0i4Ey6NWwYD4Yhp6hfK8uiGimFPubcsYXiI/nO58QmN5V4+zm1kpdl3AtoeFLF0MT0Wbqk5KJ37rmqFTWYR+4vLsGN4BM3uGoYUJgLv5irINGiw+upKhA3qOIxkiQjVGfR+uo7dRAv4B1WLbqApcD472903Hz2T6/0jmR6G0xWmEWz2g3U7uYZF1FNgKX7PK5p85lXoGMBAMzzA17Kb+EnZmFfk/eghNI4W9r1pGjGZ14YvbIHcHQbYy/Cbb0FTcW61x83ySGRGjc0SOC/qqKE+p28MfV0hfJhNV0P4VdGQdICcYrKPz/Lb306IfSKl+66z83LiKPokGeuq4pI5oqFMzY6FSQC50RXxgifnnckXEUfkZS9kFNJCn0b38Q4aWXRRt2Rl/pLMkll4fdwuPNaRXW11xT1lBdE2KfBblwAdDz/dNhIJtSZZzFtdWq+BqHZPKB8ukbZwCkf0Ne19X1hMFAvsLZIWFyPGnTe36TC9Ej8U5Tkk8J/0Ai9JpnCJ7iLz+VWzFqqEdyaXGqSWk8I4vYovWonifKW2Iok7p8boFaozGsinis86MpknWoeJoazD4OW5UEXvcxNoUvdDdDdP5Ag7V2xypbHy/eGcjY56yF2qGQwUz1xSaE2jit++h9mpYZpqYwuYyrAGT+QlXDsjVSrUXcwiiaCxfsYOm2lmszyrh4tY/LbrY9+GQqK8+SdSyYO2qsmqbvEi+old7nrCaL1Ed7Gx8B05gJ82C1FGFds3FM9tDvUJa9E4vNJVZTLzy89i2dg4sLQmFMGZ8TkH61lUf4Q94D1xRPTYMZst/IK9vjhskJdJeTdKfXNMdOfvVR5eDS3STUlGczIYHEvdhxZ2LR1ud/NYpqYIMqEs7P6yTbIpz8eru61QjH4mg1AybF17mgESqAN4PRnl8uvTsBpT9SlsJ4tgBKtjIZXua36TRmirSIo+iqX8FIol7pKx5CNEox1EdpGC3WWR5C4/Qf+wm3Rc9Z+fhdraPGi8KsWdT0Y7idMylzVwldSXGf1MeGZSiFGe+1tin67kr6ixag26TYYaSi771i5ueEjr+U4+neqPY6H37KaEFzBGFqfpuZIXUEsyIJST01xd2walDwvtGd0Xr7al/ALSXKbRNHSh1/xe9cHVDs+1hv7ul6xPX5ppZAjlZm446vuIsuiiW+rf8Yhmil+Bc0N3Ej3UxAXcTzWdZxEhaN3HRJaX5VMyyR3jLXxZDTnkbrsM3cA1eD52UGL2imx3xA7FB2wN+c9Opo3UG3rZDeIn9Wz2kCfTRVwEesH2oCn0MRHFzZWZcHm4y8GmVp/4BBzd7pXZbBd+3Kehjfw/N0duh2e4hTmuouCuvjrbo4uZaX5DqOyT+PxsJXTBMIOfstFd2/BF/8fnyximG1rFk/Bb6AWOywqHHSYhPhjy0zjuOWSndcUAMwVVtGtDZrFT1FCF+Bboxaz+wYujXVBNPSRt3TBel3xHhVk/9xASyFLqjEhr+/FFxMh7YiKktkftn5CDNDW7xTd7kcU1MJRWMm9Vb55YbVIl5D36BxqFk6osFmqjl8GTjLp7qCnHWMPa24NoufkdWuo7+j/zxUx0N+hbaBqQW6VGia52kcsnkb1p1/I5vgo26CIertrZgMfT8jqxrkeJfAMtwmAWX95Uo/g814vXll5BStHMzzG50EN8RE4g1WgWNNwtUpG10jl8S1zZvvfT7Urzi5eCKOEtweoMJWKejoFKoTY0TliqpCCU+WsqI7ywhpzipVFyeKKikfE+o63t11qguWAP/Wau6OEQE52l5dkq3BGeqwimFMnktyn4J4uoS3aNakAj8XbqStjpC/nXpL354q/zo3SxATjjuEtpr7H5uiodjVHoivbLhvoxnCDdMdZn/RMz0x/k0UIz3lv/EdN0K3pYdrO72VeeH24La2aqJ7wjWeFLhjlus/jC89FaKC05oN6biWqpgGjYshGQTpdTP8ggEQ9mkuTmgqglsFkrE4UBUNreIbnEMHcE9xRN8P2wlZTjr0xKv1HOEvn531ApJFLt1WdXRk/UKSyjmdxIkke903Ftc7EEC1PVDiaNfToRT/c2j0km6I6mKqcW44GqobuOOyp4goU26hWewpfxE/QZaoo2+L50vx5N8rmG/IefiDeJeuqDiAUFwjqeWX3VU11fdoFn04N9PVhNJoSdZoDMztbZ42YhfaMvueW4Irkmp+sS+hlJLmL5y6aI2KYvhGr6kG1kopid1vuiNlY4aXO5KhJmmTo8AWmF8/qUugcq5rLxb7gCiunu2jnQhZ2C2CGD6gw71CMzw13kQ0xEVogsZdVtHHjLD4j7LiIvxpxswLwYRguoCG6H7isSi/qwwQ0Rp8U4/IeuNq/oSDsDfto8dJx9ExJJyVqwX3S9Hi2TazjLCsNtu1984NXMdnbPLbaTdCv1Xpf02+UTqMZe8QWquBlDKoeEtp3e6+qTa7gV+SnG+VIhOeWop/0g56o0EFf+QC1wOdwRPyJH1U/AvgPJYffZMqEtzo4jhfoiKdOyrT7uqqA1NIvricqK3ei1gBW8DwE5zM8Jl3CCUC8MRpH0EbscEoihOptLBntDP+/CH5RWLkfvQhn1TCahR/w201XcYEvUGZbJbnajXRWyh/Xgt/TqkIBOcEXkPBsZHtiaaKlMbWbDSdGf7ab3aSl51fe3qf3nMM3e9vF5W5/BwQT/21ZQ611W2YGPtb8hHbuuiBP+nG6Op6HVqJUlEMUexs1YH5qbTBILRCY2nORVUeh0V1X/hwrwJuy5u2KWupx0Bj1NXtBsuKkezra58+Ez9NGN1R3x0VRindg7mRGZMA8XNOd4jXCIL+IfXYMAN3RSbVUT+oTFdmfMOl1R72SvPQtpwl95zZUxn+g9MtnVMOvDbXVcRnOd+Hr6iDcWH0g6/xRvD99FYtwJR/YlbD05AmFUneyl71x3W17k8xNRMrnJR1djaUGxlsThY6ARjgBPUSc7kkeH/GQIKilgG+8KRCv8mVLcW+Z300I7NBzNJ0XZZhSR1OPSLmHdMOJF8Wf5HzD9K5zFFXG/sFIewu1RPFSOrULH1JTwUR1UMdUvNQAv5jHwTb3KxuWt8StXkuz3mfklNIcc0z3DPyhn9opkrClsVI/xqRBbwytYQq7gQTYNXi4bmGPyjk+CYuiHfj8fp3vDMZ+QZSRvzW6Yq7OilGQHFMfx3GyZXBa2DMa7S2YeuWeHyMy6p3lo29LNtDR3rq5Ljf+RI2guPkcHy9rkF2mJEvvqNI+4jRUs50FfgWy+u5uDaynIAq15dF4tPIB9KIp8L7PDUv1NVoWWJht6iQrIdfgcLu05vsbHBkGc5mECeyC2spv8F4rG++C80ICkoNXwOlIwXEOJzSyX23UIU0h/mklVoY9lfNdVL/E36VD20u4QbVxm6GeKyfGkEvrFUqPR/H9s/XjiBWp1EAAAAABJRU5ErkJggg=="),s={size:{width:r.width,height:r.height},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT},a=t.getOrCreateResource("NoiseTexture",s).raw;e.queue.copyExternalImageToTexture({source:r},{texture:a},{width:r.width,height:r.height})}initRandomSample(){const{resourcePool:e}=this;for(let r=1;r<=8;r++)this.samplingDimensions.push(2,2,2,2);this.samples=new zt(1,this.samplingDimensions);const t={size:64*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};this.stratifiedSamplesBuffer=e.getOrCreateResource("StratifiedSamplesBuffer",t).raw}initUniformBuffer(){const{resourcePool:e}=this,t={size:k.getStride(),usage:k.RES_USAGE};this.frameUniformBuffer=e.getOrCreateResource(k.RES_NAME,t).raw,this.updateFrameUniform();const r={size:E.getStride(),usage:E.RES_USAGE};this.sceneUniformBuffer=e.getOrCreateResource(E.RES_NAME,r).raw,this.updateSceneUniform()}updateFrameUniform(){const{context:e,device:t,camera:r,sampleCount:s,numUniformSamples:a}=this;s==0?(this.samples.restart(),this.strataCount=1):s==a&&(this.strataCount=6,this.samples=new zt(this.strataCount,this.samplingDimensions));const n=new Float32Array(this.samples.next());t.queue.writeBuffer(this.stratifiedSamplesBuffer,0,n);let u=0,o=0;u=(Math.random()-.5)/e.width,o=(Math.random()-.5)/e.height,this.enableDenoise&&this.gBufferPass.updateUniform(r);const l=new k({viewToWorldMat:r.viewToWorldMat,clipToViewMat:r.clipToViewMat,sampleCount:s,strataSize:1/this.strataCount,jitter:[u,o],cameraAperture:r.aperture,cameraFocus:r.focus}).toArrayBuffer();t.queue.writeBuffer(this.frameUniformBuffer,0,l)}updateSceneUniform(){const{device:e,renderSetting:t}=this,{renderSize:r,bounces:s,backgroundColor:a,enableBackgroundColor:n,backgroundAlpha:u,envMapIntensity:o,envRotMatrix:l,invEnvRotMatrix:c,totalSumValue:d,lightNum:h}=t,f=new E({envRotMatrix:l.toWebGPUFormat(),invEnvRotMatrix:c.toWebGPUFormat(),backgroundColor:a,envMapIntensity:o,renderSize:r,bounces:s,enableBackgroundColor:n,backgroundAlpha:u,totalSumValue:d,lightNum:h}).toArrayBuffer();e.queue.writeBuffer(this.sceneUniformBuffer,0,f)}async updateScene(e,t){const{camera:r}=this;this.renderSetting=mt(e,0,t),await this.integratorPass.createPipeline(this.renderSetting),this.accumulatePass.syncRenderSetting(this.renderSetting),await this.gBufferPass.createPipeline(this.renderSetting,e,r)}async updateMaterialParams(e){this.renderSetting.enableSSS=e.includeSSS,await this.integratorPass.createPipeline(this.renderSetting),this.gBufferPass.forceUpdateBG()}initTileBuffer(){const{resourcePool:e}=this;this.tileUniformBuffer=e.getOrCreateResource(Q.RES_NAME,{size:Q.getStride(),usage:Q.RES_USAGE}).raw,this.updateTileUniform()}updateTileNumber(e){this.tileCalculator.setTileCount(e),this.reset()}setTileCountSyncRender(e){this.tileCalculator.setTileCount(e),this.updateTileUniform(),this.syncAllPassTileRenderSetting(!1,0,0,0,0),this.tileCalculator.reset()}updateTileUniform(){if(!this.tileUniformBuffer)return;const{device:e,tileOffset:t,tileSize:r,enableTileRender:s,sampleCount:a}=this,n=new Q({tileOffset:t,tileSize:r,tileEnable:Number(s&&a>this.tilePreFullSample)}).toArrayBuffer();e.queue.writeBuffer(this.tileUniformBuffer,0,n)}syncTracerSetting(e){Object.assign(this.renderSetting,e),this.updateSceneUniform(),this.screenPass.setToneMapping(e.toneMapping)}updateRenderSize(e){this.screenPass.setDownsamplingFactor(e),this.accumulatePass.syncRenderSize(),this.reset()}syncAllPassTileRenderSetting(e,t,r,s,a){this.integratorPass.syncTileRenderSetting(e,t,r,s,a)}reset(){this.sampleCount=0,this.pipelineConfig.needsClean=!0,this.updateTileUniform(),this.syncAllPassTileRenderSetting(!1,0,0,0,0),this.tileCalculator.reset()}setSize(){this.rg.setSize(),this.screenPass.setSize(),this.tileCalculator.setSize(),this.reset()}updateBindingGroup(){this.rg.forceUpdateBG()}addPass(){this.needsUpdateBG&&(this.updateBindingGroup(),this.needsUpdateBG=!1);const{rg:e,enableDenoise:t}=this;e.addPass(ue.ID,this.integratorPass),e.addPass(xe.ID,this.accumulatePass),t?(this.blitConvertPass.setInputPass(ue.ID),e.addPass(ve.ID,this.blitConvertPass),e.addPass(Te.ID,this.gBufferPass),this.aToursPass.setInputPass(ve.ID),e.addPass(be.ID,this.aToursPass),this.screenPass.setInputPass(be.ID),e.addPass(ge.ID,this.screenPass)):(this.screenPass.setInputPass(xe.ID),e.addPass(ge.ID,this.screenPass))}renderFull(e){this.updateFrameUniform(),this.integratorPass.tileSetting.enable=!1,this.addPass(),this.rg.execute(e),this.sampleCount++}renderTile(e){const{x:t,y:r,tileWidth:s,tileHeight:a,isFirstTile:n,isLastTile:u}=this.tileCalculator.nextTile();n&&this.updateFrameUniform(),this.tileOffset=[t,r],this.tileSize=[s,a],this.updateTileUniform(),this.syncAllPassTileRenderSetting(!0,t,r,s,a),this.addPass(),this.rg.execute(e),u&&this.sampleCount++}render(e){var t;const{pipelineConfig:r}=this;if(r.needsClean){const s=(t=this.resourcePool.getResourceByName("RTLightTexture"))==null?void 0:t.raw;s&&this.clearTexPass.clear(e,s),r.needsClean=!1}this.enableTileRender&&this.sampleCount>this.tilePreFullSample?this.renderTile(e):this.renderFull(e)}}navigator.gpu&&navigator.gpu.getPreferredCanvasFormat||(window.GPUBufferUsage={},window.GPUTextureUsage={});var nr=(i=>(i[i.Linear=0]="Linear",i[i.ACES=1]="ACES",i))(nr||{});class re{constructor(e,t={}){this.pixelRatio=1,this.geoType="Mesh",this.integrator="PT",this.targetSampleCount=0,this._viewportSize=[],this._downsamplingSize=[],this.inited=!1,this.isBuilding=!1,this.needsUpdate=!1,this.movingDownsampling=xr,this._bounces=2,this._backgroundColor=new F,this._enableBackgroundColor=!1,this._backgroundAlpha=1,this._envMapIntensity=1,this._envRotation=0,this._envRotMatrix=new Z,this._totalSumValue=0,this._invEnvRotMatrix=new Z,this._toneMapping="Linear",this._preSampleCount=0,this._downsamplingFactor=gr,this._enableTileRender=Qe,this._tileNumber=br,this._enableDenoise=Ft,this._denoiseColorFactor=Dt,this._denoiseNormalFactor=Nt,this._denoisePositionFactor=At,this.forceUpdateOneFullSample=!1,this.forceDownsamplingDraw=!1,this.onBuildingBeginCallback=()=>{},this.onBuildingProgressCallback=r=>{},this.onBuildingEndCallback=()=>{},this.onSampleFinCallback=()=>{},this.device=e,this.canvas=t.canvas||document.createElement("canvas"),this.canvasAlpha=t.canvasAlpha==null||t.canvasAlpha,this.sceneMode=t.sceneMode||"Static",this.useWebWorker=t.useWebWorker==null||t.useWebWorker,this.renderToScreen=t.renderToScreen==null||t.renderToScreen,this.rg=new yr(e),this.environmentLoader=new j(e,this.rg.resourcePool),this.context=new ur(this.device,this.canvas,this.pixelRatio,this.canvasAlpha),this.renderer=new Ts(this.device,this.context,this.rg),this.sceneMode=="Static"?this.sceneBuilder=new ys(e,this.rg.resourcePool):this.sceneBuilder=new Ss(e,this.rg.resourcePool,this.useWebWorker),this.featureOption={supportSGWorkflow:!0,supportUVTrans:!0,supportTexWrap:!0,supportLightSource:!0,supportAlpha:!0,supportAbsorption:!1},t.featureOption&&Object.assign(this.featureOption,t.featureOption)}set bounces(e){this._bounces=kt(e,2,8),this._syncTracerSetting()}get bounces(){return this._bounces}set envMapIntensity(e){this._envMapIntensity=e,this._syncTracerSetting()}get envMapIntensity(){return this._envMapIntensity}set enableBackgroundColor(e){this._enableBackgroundColor=e,this._syncTracerSetting()}get enableBackgroundColor(){return this._enableBackgroundColor}set backgroundColor(e){typeof e=="string"?this._backgroundColor.fromHex(e):Array.isArray(e)&&this._backgroundColor.fromArray(e),this._syncTracerSetting()}get backgroundColor(){return this._backgroundColor}set backgroundAlpha(e){this._backgroundAlpha=e,this._syncTracerSetting()}get backgroundAlpha(){return this._backgroundAlpha}set envRotation(e){this._envRotation=e;let t=function(r){return r*Math.PI/180}(e);this._envRotMatrix.fromMatrix4(new A().rotateY(t)),this._invEnvRotMatrix.inverse(this._envRotMatrix),this._syncTracerSetting()}get envRotation(){return this._envRotation}set toneMapping(e){this._toneMapping=e,this.forceUpdateOneFullSample=!0,this._syncTracerSetting()}get toneMapping(){return this._toneMapping}set downsamplingFactor(e){this._downsamplingFactor=Math.floor(Math.max(e,1)),this._downsamplingSize=[this._viewportSize[0]/this._downsamplingFactor,this._viewportSize[1]/this._downsamplingFactor]}get downsamplingFactor(){return this._downsamplingFactor}get sampleCount(){return this.renderer.sampleCount}get size(){return this._viewportSize}set enableTileRender(e){this._enableTileRender=e,this.renderer.enableTileRender=e,this.renderer.reset()}get enableTileRender(){return this._enableTileRender}set tileNumber(e){this._tileNumber=e,this.renderer.updateTileNumber(e)}get tileNumber(){return this._tileNumber}set enableDenoise(e){this._enableDenoise=e,this.renderer.enableDenoise=e,this.forceUpdateOneFullSample=!0}get enableDenoise(){return this._enableDenoise}set denoiseColorFactor(e){e=Math.max(e,1e-4),this._denoiseColorFactor=e;const t=this.renderer.aToursPass;t.sigColor=e,this.inited&&t.updateSetting(),this.forceUpdateOneFullSample=!0}get denoiseColorFactor(){return this._denoiseColorFactor}set denoiseNormalFactor(e){e=Math.max(e,1e-4),this._denoiseNormalFactor=e;const t=this.renderer.aToursPass;t.sigNormal=e,this.inited&&t.updateSetting(),this.forceUpdateOneFullSample=!0}get denoiseNormalFactor(){return this._denoiseNormalFactor}set denoisePositionFactor(e){e=Math.max(e,1e-4),this._denoisePositionFactor=e;const t=this.renderer.aToursPass;t.sigPosition=e,this.inited&&t.updateSetting(),this.forceUpdateOneFullSample=!0}get denoisePositionFactor(){return this._denoisePositionFactor}_syncSeparateRenderModeSetting(){const{enableTileRender:e,tileNumber:t}=this;let r=this.renderer;r.enableTileRender=e,r.tileCalculator.setSize(),r.updateTileNumber(t)}_syncTracerSetting(){const{context:e,geoType:t,integrator:r,sceneMode:s,bounces:a,backgroundColor:n,enableBackgroundColor:u,backgroundAlpha:o,canvasAlpha:l,envMapIntensity:c,featureOption:d,renderToScreen:h,_envRotMatrix:f,_invEnvRotMatrix:m,_toneMapping:x,_totalSumValue:g}=this;this.tracerSetting={renderSize:[e.width,e.height],geoType:t,integrator:r,sceneMode:s,bounces:a,backgroundColor:n,enableBackgroundColor:u,backgroundAlpha:o,envMapIntensity:c,envRotMatrix:f,invEnvRotMatrix:m,totalSumValue:g,toneMapping:nr[x],supportCanvasAlpha:l,supportSGWorkflow:d.supportSGWorkflow,supportUVTrans:d.supportUVTrans,supportTexWrap:d.supportTexWrap,supportLightSource:d.supportLightSource,supportAlpha:d.supportAlpha,supportAbsorption:d.supportAbsorption,renderToScreen:h},this.inited&&this.renderer.syncTracerSetting(this.tracerSetting)}_updateRenderSizeSetting(e,t=1){this.tracerSetting.renderSize=[e[0],e[1]],this.inited&&(this.renderer.syncTracerSetting(this.tracerSetting),this.renderer.updateRenderSize(t))}async buildPipeline(e,t){const{sceneInfo:r,camera:s}=function(a,n){return{sceneInfo:ze(a,!0),camera:xt(n)}}(e,t);this.sceneInfo=r,this.camera=s,this.onBuildingBeginCallback&&this.onBuildingBeginCallback(),this.environmentLoader.load(this.environment),this._totalSumValue=this.environmentLoader.totalSumValue,this._syncTracerSetting(),await this.sceneBuilder.build(r,this.onBuildingProgressCallback),await this.renderer.buildPipeline(r,s,this.tracerSetting),this.setSize(this.canvas.width/this.pixelRatio,this.canvas.height/this.pixelRatio),this._syncSeparateRenderModeSetting(),this.inited=!0,this.onBuildingEndCallback&&this.onBuildingEndCallback()}getRenderResGPUTexture(){if(!this.renderToScreen)return this.rg.getRawResFromPool("ScreenPassOutputTexture");console.error("Need to set init tracer renderToScreen to false first")}getMeshByTHREEID(e){const{meshes:t}=this.sceneInfo,r=`LGL_${e}`;return t.find(s=>r==s.id)}getLightByTHREEID(e){const{lights:t}=this.sceneInfo,r=`LGL_${e}`;return t.find(s=>r==s.id)}static linkMeshWithTHREEMesh(e,t){var r;e.id=`LGL_${t.id}`,e.name=`LGL_${t.name}`,e.tlasMask=!!((r=t.userData)!=null&&r.lgl_tlasMask),e.visible=t.visible,e.localToWorldMat.fromArray(t.matrixWorld.elements)}static linkLightWithTHREELight(e,t){e.id=`LGL_${t.id}`,e.name=`LGL_${t.name}`,e.visible=t.visible}async addMeshFromTHREE(e){if(this.sceneMode=="Static")return void console.error("SceneMode need to be Dynamic!");if(this.isBuilding)return;this.isBuilding=!0;const{sceneInfo:t}=this,{geometryConvertMap:r}=t;let s=me(e.material),a=r.get(e.geometry.id);const n=!a;n&&(a=Vt(e.geometry),r.set(e.geometry.id,a));const u=new le(a,s);if(re.linkMeshWithTHREEMesh(u,e),n)return this.sceneInfo.meshes.push(u),await this.sceneBuilder.addMeshesToBLAS(this.sceneInfo,[u],this.onBuildingProgressCallback),await this.updateSceneStructure(s.isIncludeTexture()),this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1,u;this.addTracerInstanceMeshes([u])}async removeMeshFromTHREE(e){const t=this.getMeshByTHREEID(e.id),{meshes:r}=this.sceneInfo;if(!r.length||this.isBuilding)return;this.isBuilding=!0;const s=r.indexOf(t);r.splice(s,1),await this.updateSceneStructure(),this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1}cloneMeshFromTHREE(e,t,r=!0){const s=this.getMeshByTHREEID(e).clone(r);return re.linkMeshWithTHREEMesh(s,t),s}updateMeshTransformFromTHREE(e){e.updateMatrixWorld(!0),this.getMeshByTHREEID(e.id).localToWorldMat.fromArray(e.matrixWorld.toArray())}async updateMeshMaterialParamsFromTHREE(e){me(e.material,this.getMeshByTHREEID(e.id).material),await this.updateMaterialParams()}updateTextureParamsFromTHREE(e){Ut(e.material,this.getMeshByTHREEID(e.id).material),this.sceneBuilder.updateUVTransBuffer(this.sceneInfo),this.needsUpdate=!0}async rebuildMeshMaterialFromTHREE(e){if(this.isBuilding)return;this.isBuilding=!0;const t=me(e.material);if(this.getMeshByTHREEID(e.id).material=t,this.sceneMode=="Dynamic")await this.updateSceneStructure(t.isIncludeTexture());else{const r=Ne(this.sceneInfo.meshes);this.sceneInfo.materialIndexMap=r,this.sceneInfo.materials=Array.from(r.keys()),await this.sceneBuilder.rebuildMaterialRelated(this.sceneInfo)}this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1}addLightFromTHREE(e){const t=Ae(e);this.sceneInfo.lights.push(t),re.linkLightWithTHREELight(t,e),this.sceneBuilder.updateLightBuffer(this.sceneInfo),this.renderer.renderSetting.lightNum=this.sceneInfo.lights.length,this.renderer.updateSceneUniform(),this.needsUpdate=!0}removeLightFromTHREE(e){const{lights:t}=this.sceneInfo,r=this.getLightByTHREEID(e.id);if(!t.length||!r)return;const s=t.indexOf(r);t.splice(s,1),this.sceneBuilder.updateLightBuffer(this.sceneInfo),this.renderer.renderSetting.lightNum=this.sceneInfo.lights.length,this.renderer.updateSceneUniform(),this.needsUpdate=!0}updateLightFromTHREE(e){const t=this.getLightByTHREEID(e.id),r=Ae(e);t.copy(r),this.sceneBuilder.updateLightBuffer(this.sceneInfo),this.needsUpdate=!0}async addSceneFromTHREE(e){if(this.isBuilding)return;this.isBuilding=!0,this.onBuildingBeginCallback&&this.onBuildingBeginCallback();const t=this.sceneInfo.geometryConvertMap.size,r=ze(e,!1,this.sceneInfo.geometryConvertMap),s=r.meshes,a=s.some(u=>u.material.isIncludeTexture()),n=t!=this.sceneInfo.geometryConvertMap.size;this.sceneInfo.meshes.push(...s),n&&(this.sceneInfo.geometryConvertMap=new Map([...this.sceneInfo.geometryConvertMap,...r.geometryConvertMap]),await this.sceneBuilder.addMeshesToBLAS(this.sceneInfo,s,this.onBuildingProgressCallback)),await this.updateSceneStructure(a),r.includeSSS&&!this.sceneInfo.includeSSS&&(this.sceneInfo.includeSSS=r.includeSSS,await this.renderer.updateMaterialParams(this.sceneInfo)),this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1,this.onBuildingEndCallback&&this.onBuildingEndCallback()}async replaceMainSceneFromTHREE(e){if(this.isBuilding)return;this.isBuilding=!0,this.onBuildingBeginCallback&&this.onBuildingBeginCallback();const t=ze(e);await this.sceneBuilder.build(t,this.onBuildingProgressCallback),this.sceneInfo=t,await this.renderer.updateScene(t,this.tracerSetting),this.renderer.needsUpdateBG=!0,this.needsUpdate=!0,this.isBuilding=!1,this.onBuildingEndCallback&&this.onBuildingEndCallback()}setMeshTLASMaskStatusFromTHREE(e,t){const r=this.getMeshByTHREEID(e.id);return r&&(r.tlasMask=t),r}setMeshVisibleFromTHREE(e,t){const r=this.getMeshByTHREEID(e.id);return r&&(r.visible=t),r}async addTracerInstanceMeshes(e){if(this.isBuilding||!e.length)return;this.isBuilding=!0,this.sceneInfo.meshes.push(...e);const t=e.some(r=>r.material.isIncludeTexture());await this.updateSceneStructure(t),this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1}updateEnvLight(e){this.environment=e,this.environmentLoader.load(this.environment),this._totalSumValue=this.environmentLoader.totalSumValue,this._syncTracerSetting(),this.renderer.needsUpdateBG=!0,this.needsUpdate=!0}async updateMaterialParams(){this.isBuilding||(this.isBuilding=!0,function(e){const{materials:t}=e;let r=!1;t.forEach(s=>{s.subsurface>0&&(r=!0)}),e.includeSSS=r}(this.sceneInfo),await this.renderer.updateMaterialParams(this.sceneInfo),this.sceneBuilder.updateMaterialParams(this.sceneInfo),this.renderer.needsUpdateBG=!0,this.renderer.reset(),this.isBuilding=!1)}updateTLAS(){this.sceneMode=="Static"||this.isBuilding||(this.sceneBuilder.rebuildTLAS(this.sceneInfo),this.needsUpdate=!0,this.forceDownsamplingDraw=!0)}rebuildTLAS(){this.sceneMode=="Static"||this.isBuilding||(this.sceneBuilder.rebuildTLAS(this.sceneInfo,!0),this.rg.forceUpdateBG(),this.needsUpdate=!0)}async rebuildBVH(){this.sceneMode=="Dynamic"||this.isBuilding||(this.isBuilding=!0,await this.sceneBuilder.rebuildBVH(this.sceneInfo),this.rg.forceUpdateBG(),this.isBuilding=!1,this.needsUpdate=!0)}async updateSceneStructure(e=!1){if(this.sceneMode=="Static")return void console.error("SceneMode need to be Dynamic!");const t=Ne(this.sceneInfo.meshes);this.sceneInfo.materialIndexMap=t,this.sceneInfo.materials=Array.from(t.keys()),await this.sceneBuilder.rebuildMaterialBuffer(this.sceneInfo,e),this.renderer.gBufferPass.initMeshUniformBuffer(),this.renderer.gBufferPass.forceUpdateBG(),this.sceneBuilder.rebuildTLAS(this.sceneInfo,!0)}updateDenoiseParams(e,t,r){const s=this.renderer.aToursPass;typeof e=="number"&&(s.sigColor=e),typeof t=="number"&&(s.sigNormal=t),typeof r=="number"&&(s.sigPosition=r),s.updateSetting()}areCamerasEqual(e,t){return e.type!=t.type?(t=e.clone(),!1):e.type==="OrthographicCamera"?bt(e.viewToWorldMat,t.viewToWorldMat)&&e.zoom==t.zoom:bt(e.viewToWorldMat,t.viewToWorldMat)}syncCamera(e){if(!e)throw new Error("Need to pass camera into render(camera) method!");e.updateMatrixWorld(!0),xt(e,this.renderer.camera)}setTileCountSyncRender(e){this._tileNumber=e,this.renderer.setTileCountSyncRender(e)}setSize(e,t,r=!0){const{canvas:s,context:a,_downsamplingFactor:n}=this,u=Math.floor(e*a.pixelRatio),o=Math.floor(t*a.pixelRatio);s.width=u,s.height=o,this._viewportSize=[u,o],this._downsamplingSize=[u/n,o/n],r&&(s.style.width=`${e}px`,s.style.height=`${t}px`),this._updateRenderSizeSetting(this._viewportSize),this.inited&&this.renderer.setSize()}setPixelRatio(e,t=!1){const{context:r,_viewportSize:s}=this;r.pixelRatio=e,this.setSize(s[0]/e,s[1]/e,t)}setCanvasSizeByPixelRatio(e){const{canvas:t,context:r,_downsamplingFactor:s}=this,a=[vt(t.style.width),vt(t.style.height)];r.pixelRatio=e;const n=Math.floor(a[0]*r.pixelRatio),u=Math.floor(a[1]*r.pixelRatio);this._viewportSize=[n,u],this._downsamplingSize=[n/s,u/s],t.width=n,t.height=u}renderCommand(e,t=!1){const{device:r}=this,{camera:s,lastCamera:a}=this.renderer;this._preSampleCount=this.renderer.sampleCount,this.targetSampleCount!==0&&this._preSampleCount>=this.targetSampleCount&&!this.forceUpdateOneFullSample||(this.renderer.enableTileRender=this.enableTileRender&&!t,this.renderer.render(e),r.queue.submit([e.finish()]),a.copy(s),this.onSampleFinCallback&&this._preSampleCount!=this.renderer.sampleCount&&r.queue.onSubmittedWorkDone().then(()=>{typeof this.onSampleFinCallback=="function"&&this.onSampleFinCallback()}),this._preSampleCount!=this.renderer.sampleCount&&this.forceUpdateOneFullSample&&(this.forceUpdateOneFullSample=!1))}render(e){if(!this.inited||this.isBuilding)return;this.syncCamera(e);const{_downsamplingSize:t,downsamplingFactor:r,movingDownsampling:s,_viewportSize:a,tracerSetting:n}=this,{device:u,camera:o,lastCamera:l}=this.renderer,c=u.createCommandEncoder();if(!this.areCamerasEqual(o,l)||this.forceDownsamplingDraw){if(this.forceDownsamplingDraw&&(this.forceDownsamplingDraw=!1),s)return this._updateRenderSizeSetting(t,r),void this.renderCommand(c,!0);this.renderer.reset()}n.renderSize[0]==a[0]&&n.renderSize[1]==a[1]||this._updateRenderSizeSetting(a),this.needsUpdate&&(this.needsUpdate=!1,this.renderer.reset()),this.renderCommand(c)}}export{re as LGLTracer,qe as Light,le as Mesh,de as PrincipledBSDFMaterial};
